<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda Pandas</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda Pandas</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-pandas-1.html" onclick="alert('Você já Está na Matéria desse Link!'); return false">Tudo sobre Pandas Parte 1!</a></li>
                    <li><a href="tudo-sobre-pandas-2.html">Tudo sobre Pandas Parte 2!</a></li>
                </menu>
            </header>
            
<h2>Tudo sobre Pandas Parte 1</h2>

<h3>Dataframe</h3>

<p>Vamos começar criando um novo projeto em Python e instalando as bibliotecas pra <code>pandas</code> e <code>jupyter</code>.</p>

<p>Pra começar, faça assim:</p>

<pre>
<code>
import pandas as pd

df = pd.DataFrame()

print(df)
</code>
</pre>

<p>O dataframe é uma maneira que temos de armazenar os dados, como um banco mesmo. Por ser uma classe, ele tem vários atributos e métodos.</p>

<p>PS: Apesar de trabalharmos com Python, o back-end do Pandas é escrito em C.</p>

<p>Para passarmos os dados, podemos fazer assim:</p>

<pre>
<code>
import pandas as pd

df = pd.DataFrame(((1, "Jorge", 0.4), (177, 8, ("João"))))

print(df)
</code>
</pre>

<p>Como observado, podemos armazenar vários tipo de conteúdos, como string, int e float.</p>

<p>Pra exibir as colunas e índices, fazemos assim:</p>

<pre>
<code>
print(df.columns)
print(df.index)
</code>
</pre>

<p>Podemos mudar os nomes dos índices, assim:</p>

<pre>
<code>
import pandas as pd

df = pd.DataFrame(((1, "Jorge", 0.4), (177, 8, ("João"))), index = (45, "Maria"))

print(df)
</code>
</pre>

<p>E das colunas também:</p>

<pre>
<code>
df = pd.DataFrame(((1, "Jorge", 0.4), (177, 8, ("João"))), index = (45, "Maria"), columns = ("Brasil", "US", "Laranja"))
</code>
</pre>

<p>E pra ver o tamanho dos índices e colunas:</p>

<pre>
<code>
print(df.shape)
</code>
</pre>

<p>E pra ver os tipos das variáveis das colunas:</p>

<pre>
<code>
print(df.dtypes)
</code>
</pre>

<h3>Base de Dados</h3>

<p>Vamos pegar esse repositório como exemplo pras próximas lições: <a href="https://github.com/CSSEGISandData/COVID-19/blob/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv" target="_blank">https://github.com/CSSEGISandData/COVID-19/blob/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv</a></p>

<p>E deixe o código assim:</p>

<pre>
<code>
import pandas as pd

# Base de dados - Covid global
link = "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv"

dfNotif = pd.read_csv(link)

print(dfNotif)
</code>
</pre>

<p>Podemos fazer o mesmo com esse link aqui:</p>

<pre>
<code>
link = "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/refs/heads/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv"

dfNotif = pd.read_csv(link)

print(dfNotif)
</code>
</pre>

<h3>Comando Drop</h3>

<p>Podemos remover alguns campos dos dados recebidos pelo Pandas, como no caso acima, a latitude e longitude, que não são necessários no momento. Podemos filtrar assim:</p>

<pre>
<code>
print(dfNotif.drop(["Lat", "Long"], axis = 1))
</code>
</pre>

<p>PS: Isso não altera o dataframe original, apenas exibe sem as colunas especificadas. Para criar uma nova atribuição, faça assim:</p>

<pre>
<code>
dfNotif = dfNotif.drop(["Lat", "Long"], axis = 1)
</code>
</pre>

<p>Ou, de forma mais inteligente, assim:</p>

<pre>
<code>
dfNotif.drop(["Lat", "Long"], axis = 1, inplace = True)
</code>
</pre>

<h3>Comando Loc</h3>

<p>Para localizar determinadas coisas dentro de um dataframe, podemos usar o comando loc, veja como encontramos o índice 0 de um dataframe:</p>

<pre>
<code>
print(dfNotif.loc[0])
</code>
</pre>

<p>Pra filtrar por uma coluna, fazemos assim:</p>

<pre>
<code>
print(dfNotif.loc[0, "Country/Region"])
</code>
</pre>

<p>Podemos pegar a coluna por número também, apenas trocando loc por iloc, assim:</p>

<pre>
<code>
print(dfNotif.iloc[0, 1])
</code>
</pre>

<p>Pra pegar todas as ocorrências, mas filtrando apenas por uma coluna:</p>

<pre>
<code>
print(dfNotif.loc[:, "Country/Region"])
</code>
</pre>

<p>Pra pegar determinadas linhas e colunas:</p>

<pre>
<code>
print(dfNotif.loc[(54, 66, 87), ("Country/Region", "12/14/21")])
</code>
</pre>

<p>Com mais uma coluna:</p>

<pre>
<code>
print(dfNotif.loc[(54, 66, 87), ("Province/State", "Country/Region", "12/14/21")])
</code>
</pre>

<p>Pra pegar um intervalo de ocorrências:</p>

<pre>
<code>
print(dfNotif.loc[54:66, ("Province/State", "Country/Region", "12/14/21")])
</code>
</pre>

<p>Podemos mostrar o objeto com um fatiamento de lista, como por exemplo, exibindo apenas dados de uma só coluna:</p>

<pre>
<code>
print(dfNotif["Country/Region"])
print(dfNotif.loc[:, "Country/Region"]) # Basicamente faz a mesma coisa do print acima
</code>
</pre>

<p>Podemos filtrar as colunas assim também:</p>

<pre>
<code>
print(dfNotif[["Province/State", "Country/Region", "12/14/21"]])
</code>
</pre>

<p>Podemos verificar conteúdos assim:</p>

<pre>
<code>
print(dfNotif["Country/Region"] == "Brazil")
</code>
</pre>

<p>E podemos fazer assim também:</p>

<pre>
<code>
print(dfNotif.loc[dfNotif["Country/Region"] == "Brazil"])
</code>
</pre>

<p>Da mesma forma:</p>

<pre>
<code>
print(dfNotif["Country/Region"] == "US")
</code>
</pre>

<p>E pra escolhe entre um ou outro:</p>

<pre>
<code>
print(dfNotif.loc[(dfNotif["Country/Region"] == "Brazil") | (dfNotif["Country/Region"] == "US")])
</code>
</pre>

<p>O Pandas não utiliza os mesmos operadores lógicos do Python, como o and e or literais. E sim esses aqui:</p>

<table>
    <tr>
        <th>Operador</th>
        <th>Operação</th>
    </tr>
    <tr>
        <td><code>&amp;</code></td>
        <td>AND</td>
    </tr>
    <tr>
        <td><code>|</code></td>
        <td>OR</td>
    </tr>
    <tr>
        <td><code>~</code></td>
        <td>NOT</td>
    </tr>
</table>

<p>Lembrando que as condições devem usar parênteses, como exemplificado acima.</p>

<p>Podemos fazer essa filtragem:</p>

<pre>
<code>
print(dfNotif.loc[dfNotif["12/24/21"] &lt; 1e06]) # Experimente trocar o "&lt;" pelo "&gt;", o 1e06 significa 1 milhão
</code>
</pre>

<h3>Comando Isna</h3>

<p>Podemos também filtrar os dados, de forma que não pegue dados faltantes.</p>

<p>Como a base de dados é muito grande, podemos usar o método isna pra ver se o dataframe tem dados considerados <q>NaN</q> (not a number):</p>

<pre>
<code>
print(dfNotif.isna())
</code>
</pre>

<p>E pra ver se tem algo em uma linha considerado falso:</p>

<pre>
<code>
print(dfNotif.isna().any(axis = 0))
</code>
</pre>

<p>Pra pegar todas as linhas e as colunas que obedeçam à condição especificada:</p>

<pre>
<code>
print(dfNotif.loc[:, dfNotif.isna().any(axis = 0)])
</code>
</pre>

<p>E pra transformar os dados em booleanos e somar os dados true:</p>

<pre>
<code>
print(dfNotif.loc[:, dfNotif.isna().any(axis = 0)].isna().sum())
</code>
</pre>

<p>E para ver a quantidade de dados faltantes:</p>

<pre>
<code>
print(100 * dfNotif.loc[:, dfNotif.isna().any(axis = 0)].isna().sum() / dfNotif.shape[0])
</code>
</pre>

<h3>Comando sort_values</h3>

<p>Podemos também organizar nossos registros no dataframe.</p>

<p>Para pegar o último registro da nossa base de dados, fazemos assim:</p>

<pre>
<code>
print(dfNotif.columns[-1])
</code>
</pre>

<p>E pra ordenar de forma reversa:</p>

<pre>
<code>
lastDay = dfNotif.columns[-1]

print(dfNotif.sort_values(by = lastDay, ascending = False))
</code>
</pre>

<p>E pra ler somente 10 registros:</p>

<pre>
<code>
print(dfNotif.sort_values(by = lastDay, ascending = False).head(10))
</code>
</pre>

<h3>Comando Group By</h3>

<p>Esse comando serve pra agrupar os registros na base de dados usando uma coluna de referência. Veja um exemplo:</p>

<pre>
<code>
print(dfNotif.groupby(by = ["Country/Region"]))
</code>
</pre>

<p>Só que isso mostrará apenas a chamada do objeto, para mostrar os registros, devemos fazer assim, com uma operação:</p>

<pre>
<code>
print(dfNotif.groupby(by = ["Country/Region"]).sum())
</code>
</pre>

<p>Nesse caso, as colunas repetidas não aparecem, como a Province/State, até porque ele não soma strings (NaN é considerada uma string, no caso).</p>

<h3>Comando Stack</h3>

<p>O comando stack reorganiza (ou <q>empilha</q>) as colunas de um DataFrame dentro do índice das linhas, criando uma estrutura mais compacta. Veja um exemplo simples de uso:</p>

<pre>
<code>
dfNotif.drop(["Province/State", "Lat", "Long"], axis = 1, inplace = True)

dfNotif = dfNotif.groupby(by = ["Country/Region"]).sum()

print(dfNotif.stack())
</code>
</pre>

<p>Pra salvar o empilhamento (não apague nada além dos prints anteriores):</p>

<pre>
<code>
dfNotif = dfNotif.stack()

print(dfNotif)
</code>
</pre>

<p>Pra colocar nomes personalizados nas colunas (não apague nada além dos prints anteriores):</p>

<pre>
<code>
dfNotif = dfNotif.stack()

dfNotif.index.set_names(("País/Região", "Datas"), inplace = True)

print(dfNotif)
</code>
</pre>

<p>E pra colocar um nome para o frame (mesma regra, só apague os prints anteriores):</p>

<pre>
<code>
dfNotif = dfNotif.stack()

dfNotif.index.set_names(("País/Região", "Datas"), inplace = True)

dfNotif = dfNotif.to_frame(name = "Notificações")

print(dfNotif)
</code>
</pre>

<ul>
    <li><a href="tudo-sobre-pandas-2.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>