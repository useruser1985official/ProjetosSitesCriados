<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda Algoritmos</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda Algoritmos</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-algoritmos-1.html">Tudo sobre Algoritmos Parte 1!</a></li>
                    <li><a href="tudo-sobre-algoritmos-2.html">Tudo sobre Algoritmos Parte 2!</a></li>
                    <li><a href="tudo-sobre-algoritmos-3.html">Tudo sobre Algoritmos Parte 3!</a></li>
                    <li><a href="tudo-sobre-algoritmos-4.html">Tudo sobre Algoritmos Parte 4!</a></li>
                    <li><a href="tudo-sobre-algoritmos-5.html">Tudo sobre Algoritmos Parte 5!</a></li>
                </menu>
            </header>

<h2>Orientação a Objetos - Parte 1</h2>

<h3>O Que é a Programação Orientada a Objetos</h3>

<p>A Programação Orientada a Objetos (POO) é uma forma de organizar programas usando objetos, que representam coisas com características e ações. Lembrando que a programação orientada a objetos não tem nada a ver com arrastar componentes em telinhas, como alguns leigos erroneamente pensam. A programação orientada a objetos é uma forma especial de codificar programas, na verdade.</p>

<p>Na programação orientada a objetos temos as seguintes coisas:</p>

<ul>
    <li><b>Objeto: </b>Algo que tem características e ações (como um carro).</li>
    <li><b>Classe: </b>O molde que descreve como os objetos serão (classe vem de classificação, classificar algo).</li>
    <li><b>Atributos: </b>As características do objeto (como cor e modelo). São como as variáveis da classe.</li>
    <li><b>Métodos: </b>As ações que o objeto pode fazer (como acelerar e frear). São como as funções/procedimentos da classe.</li>
    <li><b>Estado: </b>É o conjunto de valores atuais dos atributos pertencentes a um objeto.</li>
    <li><b>Instância: </b>Um objeto real criado a partir de uma classe.</li>
</ul>

<p>Por exemplo, a classe <q>Carro</q> define que todo carro tem cor, modelo e velocidade (atributos) e pode acelerar e frear (métodos). Um carro específico, como um Uno vermelho, é uma instância dessa classe (o objeto em si).</p>

<p>PS: Na programação orientada a objetos, várias coisas podem ser usadas para exemplificar classes e objetos, não apenas objetos literais como um carro ou um livro, mas também coisas como uma planta (tipo uma árvore), um animal (como um gato ou cachorro), uma pessoa (incluindo usuário, cliente, aluno e coisas do tipo) e até mesmo coisas conceituais como aula, consulta, reunião, conta bancária, etc.</p>

<p>Nas linguagens de programação, os objetos são utilizados para várias coisas, como listas, exceções e erros, conexões com banco de dados, para trabalhar com redes, criptografia, etc., além de componentes diversos. No Java mesmo, tirando os tipos primitivos padrão, tudo nele são objetos (incluindo a String), no C# e no Python tudo neles também são objetos.</p>

<p>Esses são os pilares da Programação Orientada a Objetos:</p>

<ol>
    <li><b>Abstração: </b>É focar apenas no que é importante. Você cria modelos simplificados (classes) que representam algo do mundo real sem mostrar detalhes desnecessários.</li>    
    <li><b>Encapsulamento: </b>É proteger os dados. Atributos ficam privados e são acessados de forma controlada, geralmente por meio de getters e setters.</li>    
    <li><b>Herança: </b>É quando uma classe herda características de outra. Permite reaproveitar código, criando classes mais específicas a partir de uma classe mais geral.</li>    
    <li><b>Polimorfismo: </b>É quando diferentes classes podem responder ao mesmo método de maneiras diferentes. Um mesmo nome de método gera comportamentos diferentes dependendo do objeto.</li>    
</ol>

<p>Algumas das linguagens mais populares que são orientadas a objetos são o Java, PHP, C++, C#, Visual Basic, Python, Ruby, Objective-C, Swift, Javascript e Kotlin, no entanto, nem todas são compatíveis com todos os conceitos, por exemplo:</p>

<ul>
    <li>Java, C# e Python, por exemplo, são linguagens que obrigatoriamente temos que programar orientado a objetos, já que quase tudo ou tudo nessas linguagens são objetos, no entanto, Python tem algumas limitações com alguns conceitos.</li>
    <li>PHP é um exemplo de linguagem, que apesar de compatível com a maioria dos conceitos, ela não é obrigatoriamente orientada a objetos, pois surgiu inicialmente como linguagem estruturada.</li>
    <li>C++ é uma linguagem orientada a objetos, considerada uma das primeiras a popularizar esse paradigma, no entanto, muita coisa dele ainda é oriunda do C, que é uma linguagem estruturada.</li>
    <li>Javascript, apesar de considerada uma linguagem orientada a objetos, ela é baseada em protótipos, em versões mais antigas nem ao menos existiam classes.</li>
</ul>

<p>Muitos consideram como a primeira linguagem orientada a objetos o Simula 67, mas os conceitos amadureceram mesmo com a linguagem Smalltalk.</p>

<p>Para aprender a programação orientada a objetos, deve-se saber a programação básica (estruturada) primeiro, pois praticamente tudo delas pode ser usados em programas orientados a objetos (como estruturas condicionais e de repetição, além do conceito de variáveis e funções/procedimentos, que são equivalentes aos atributos e métodos em POO). O ideal é saber o básico de uma linguagem que suporte POO para estudar esse paradigma, como o Java ou o C#. A maioria dos exercícios aqui usaremos o Java como base, mas mostraremos códigos de outras linguagens também, e as lições aqui podem ser adaptadas pras principais linguagens orientadas a objetos.</p>

<h3>Primeiro Exemplo de Programa Orientado a Objetos</h3>

<p>Veja um exemplo em Java da classe Carro, que escreve como um carro é e o que ele pode fazer:</p>

<pre>
<code>
public class Carro {
    // Atributos (Características, como variáveis)
    String cor;
    String modelo;
    int velocidade;

    // Métodos (Ações, como funções ou procedimentos)
    void acelerar() {
        this.velocidade += 10;
    }

    void frear() {
        this.velocidade -= 10;
    }
}
</code>
</pre>

<p>Dentro de qualquer método, o <code>this</code> aponta para o próprio objeto em memória. Ele é usado principalmente para diferenciar atributos do objeto de variáveis locais ou parâmetros que têm o mesmo nome. Na maioria das vezes você não precisa usá-lo, mas ele é útil quando existe ambiguidade (nome de variável local igual ao nome de atributo). Dentro de métodos numa classe, o this funciona como <q>eu, o próprio objeto</q>.</p>

<p>PS: Assim como na programação estruturada, não use comandos de saída em métodos <q>void</q> para exibir dados, prefira retornar valores para não ficar <q>engessado</q> no formato de exibição da linguagem (como o console ou uma interface gráfica). Nesse caso a função deverá ter, ao invés do void, o tipo primitivo retornado, como <code>int</code>, <code>char</code> ou mesmo outros objetos (incluindo a <code>String</code>). Prefira o void para tratar dados que não são exibidos ou retornados no método especificado. Usaremos alguns prints de console em alguns métodos void aqui, mas são pra questões puramente didáticas.</p>

<p>O diagrama dessa classe é esse:</p>

<img src="imagens/diagrama-carro.png" alt="Diagrama Carro"/>

<p>PS: O uso desse tipo de diagrama em POO, se chama UML.</p>

<p>Código principal, onde criamos os objetos:</p>

<pre>
<code>
// Criando uma instância (objeto) da classe Carro
Carro cr = new Carro();

// Definindo valores para os atributos
cr.cor = "Vermelho";
cr.modelo = "Uno";
cr.velocidade = 0;

// Usando os métodos
cr.acelerar();
System.out.println("Cor: " + cr.cor);
System.out.println("Modelo: " + cr.modelo);
System.out.println("Velocidade atual: " + cr.velocidade);

cr.frear();
System.out.println("Velocidade atual: " + cr.velocidade);
</code>
</pre>

<p>O objeto é como uma variável especial que, além de guardar dados (atributos), também têm funcionalidades (métodos), que atuam sobre o próprio objeto ao qual pertencem.</p>

<p>No caso do Java, o <q>tipo</q> do objeto é a classe da qual ele pertence, basicamente. Ali o tipo da variável <code>cr</code> (nosso objeto) é o tipo <q>Carro</q>.</p>

<p>Fazendo a classe uma vez, podemos criar quantos objetos quisermos oriundos da mesma:</p>

<pre>
<code>
// Criando uma instância (objeto) da classe Carro
Carro cr = new Carro();

// Definindo valores para os atributos
cr.cor = "Vermelho";
cr.modelo = "Uno";
cr.velocidade = 0;

// Usando os métodos
cr.acelerar();
System.out.println("Cor: " + cr.cor);
System.out.println("Modelo: " + cr.modelo);
System.out.println("Velocidade atual: " + cr.velocidade);

cr.frear();
System.out.println("Velocidade atual: " + cr.velocidade);

System.out.println("------------------------------------");

// Criando outra instância (objeto) da classe Carro
Carro cr2 = new Carro();

// Definindo valores para os atributos
cr2.cor = "Preto";
cr2.modelo = "Gol";
cr2.velocidade = 0;

// Usando os métodos
cr2.acelerar();
cr2.acelerar();
System.out.println("Cor: " + cr2.cor);
System.out.println("Modelo: " + cr2.modelo);
System.out.println("Velocidade atual: " + cr2.velocidade);

cr2.frear();
System.out.println("Velocidade atual: " + cr2.velocidade);
</code>
</pre>

<p>Observe que, mesmo os dois objetos sendos oriundos da mesma classe, cada objeto tem suas características e comportamentos distintos, e funcionam isoladamente entre si.</p>

<p>Utilizando a mesma classe, podemos fazer por exemplo assim no código principal, utilizando arrays:</p>

<pre>
<code>
// Criando os objetos e colocando no array
Carro[] carros = new Carro[3];

carros[0] = new Carro();

carros[0].cor = "Vermelho";
carros[0].modelo = "Uno";
carros[0].velocidade = 0;

carros[1] = new Carro();

carros[1].cor = "Preto";
carros[1].modelo = "Gol";
carros[1].velocidade = 0;

carros[2] = new Carro();

carros[2].cor = "Azul";
carros[2].modelo = "Civic";
carros[2].velocidade = 0;

// Usando métodos em cada objeto
carros[0].acelerar();
carros[1].acelerar();
carros[2].acelerar();

// Mostrando resultados
for(int i = 0; i &lt; carros.length; i++) {
    System.out.println("Carro " + i + ":");
    System.out.println("Modelo: " + carros[i].modelo);
    System.out.println("Cor: " + carros[i].cor);
    System.out.println("Velocidade: " + carros[i].velocidade);
    System.out.println("------------------------------------");
}
</code>
</pre>

<p>PS: No Java, os arrays em si, de qualquer tipo, também são considerados objetos.</p>

<p>Algumas linguagens também permitem usar listas (que muitas vezes são classes nativas delas), como no Java mesmo:</p>

<pre>
<code>
// Criando uma lista de Carro usando ArrayList
List&lt;Carro&gt; listaCarros = new ArrayList&lt;&gt;(); // Importe java.util.List e java.util.ArrayList

// Criando os objetos e adicionando na lista
Carro cr1 = new Carro();

cr1.cor = "Vermelho";
cr1.modelo = "Uno";
cr1.velocidade = 0;

listaCarros.add(cr1);

Carro cr2 = new Carro();

cr2.cor = "Preto";
cr2.modelo = "Gol";
cr2.velocidade = 0;

listaCarros.add(cr2);

Carro cr3 = new Carro();

cr3.cor = "Azul";
cr3.modelo = "Civic";
cr3.velocidade = 0;

listaCarros.add(cr3);

// Usando métodos em cada carro da lista com for iterator
for(Carro c: listaCarros) {
    c.acelerar();
}

// Mostrando os dados da lista com for normal
for(int i = 0; i &lt; listaCarros.size(); i++) {
    System.out.println("Carro " + i + ":");
    System.out.println("Modelo: " + listaCarros.get(i).modelo);
    System.out.println("Cor: " + listaCarros.get(i).cor);
    System.out.println("Velocidade: " + listaCarros.get(i).velocidade);
    System.out.println("------------------------------------");
}
</code>
</pre>

<p>Como visto, a orientação a objetos facilita o reuso de código, já que, uma vez pronta a classe (mesmo que tenhamos que escrever muito pra criar tudo que precisarmos), podemos utilizar ela pra criarmos quantos objetos precisarmos, e o programa principal fica mais simples, natural e muitas vezes menor. Cada objeto funciona isolado do outro, mas eles podem se comunicar, se preciso.</p>

<h3>Encapsulamento</h3>

<p>Encapsulamento é o ato de proteger os atributos de uma classe, deixando-os privados (<code>private</code>) para impedir acesso direto. Para ler ou alterar esses valores de forma controlada, usamos métodos públicos (<code>public</code>):</p>

<ul>
    <li><b>Getters: </b>Pegam o valor. Normalmente são do mesmo <q>tipo</q> do atributo correspondente (como <code>int</code>, <code>char</code> ou mesmo outro objeto) que deverá ser retornado.</li>
    <li><b>Setters: </b>Modificam o valor. Normalmente não retornam nada (definidos como <code>void</code>).</li>
</ul>

<p>Isso evita uso incorreto dos dados e deixa o código mais seguro e organizado.</p>

<p>Veja a classe Carro alterada com o encapsulamento de atributos:</p>

<pre>
<code>
public class Carro {
    // Atributos privados (encapsulados)
    private String cor;
    private String modelo;
    private int velocidade;

    // Métodos públicos
    public void acelerar() {
        this.velocidade += 10;
    }

    public void frear() {
        this.velocidade -= 10;
    }

    // Getter de cor
    public String getCor() {
        return this.cor;
    }

    // Setter de cor
    public void setCor(String cor) {
        this.cor = cor;
    }

    // Getter de modelo
    public String getModelo() {
        return this.modelo;
    }

    // Setter de modelo
    public void setModelo(String modelo) {
        this.modelo = modelo;
    }

    // Getter de velocidade
    public int getVelocidade() {
        return this.velocidade;
    }

    // Setter de velocidade
    public void setVelocidade(int velocidade) {
        this.velocidade = velocidade;
    }
}
</code>
</pre>

<p>Lembrando, a variável com o <q>this</q> é o atributo da classe, a variável que está sem ele é o parâmetro do método.</p>

<p>O diagrama dessa classe fica assim, com o <q>+</q> representando o que é público e <q>-</q> representando o que é privado:</p>

<img src="imagens/diagrama-carro-completo.png" alt="Diagrama Carro Completo"/>

<p>Aí, no código principal, não poderemos usar os atributos definidos como <q>private</q>, então deveremos usar os getters e setters para manipular os mesmos fora da classe:</p>

<pre>
<code>
Carro cr = new Carro();

// Definindo valores para os atributos
cr.setCor("Vermelho");
cr.setModelo("Uno");
cr.setVelocidade(0);

// Usando os métodos
cr.acelerar();
System.out.println("Cor: " + cr.getCor());
System.out.println("Modelo: " + cr.getModelo());
System.out.println("Velocidade atual: " + cr.getVelocidade());

cr.frear();
System.out.println("Velocidade atual: " + cr.getVelocidade());
</code>
</pre>

<p>Podemos ter apenas os getters ou apenas os setters nas classes também.</p>

<p>Sobre o privado e público, entenda o seguinte sobre a visibilidade dos atributos e métodos:</p>

<ul>
    <li><b>Público</b>: Possível manipular em todo o programa, normalmente definido como <code>public</code>.</li>
    <li><b>Privado</b>: Possível manipular somente dentro da classe que ele pertence, normalmente definido como <code>private</code>.</li>
    <li><b>Protegido</b>: Possível manipular dentro da classe e suas herdeiras, tipo um meio-termo entre o público e o privado, normalmente definido como <code>protected</code>.</li>
</ul>

<p>Lembrando que os modificadores <code>public</code>, <code>private</code> e <code>protected</code> também podem ser usados nos métodos, seguindo a mesma regra dos atributos.</p>

<p>Num diagrama de classes, podemos identificar os símbolos assim:</p>

<table>
    <tr>
        <th>Símbolo</th>
        <th>Significado</th>
    </tr>
    <tr>
        <td>+</td>
        <td>Público</td>
    </tr>
    <tr>
        <td>-</td>
        <td>Privado</td>
    </tr>
    <tr>
        <td>#</td>
        <td>Protegido</td>
    </tr>
</table>

<ul>
    <li><a href="poo-algoritmos-2.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>