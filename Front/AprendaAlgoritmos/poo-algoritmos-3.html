<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda Algoritmos</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda Algoritmos</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-algoritmos-1.html">Tudo sobre Algoritmos Parte 1!</a></li>
                    <li><a href="tudo-sobre-algoritmos-2.html">Tudo sobre Algoritmos Parte 2!</a></li>
                    <li><a href="tudo-sobre-algoritmos-3.html">Tudo sobre Algoritmos Parte 3!</a></li>
                    <li><a href="tudo-sobre-algoritmos-4.html">Tudo sobre Algoritmos Parte 4!</a></li>
                    <li><a href="tudo-sobre-algoritmos-5.html">Tudo sobre Algoritmos Parte 5!</a></li>
                </menu>
            </header>

<h2>Orientação a Objetos - Parte 3</h2>

<h3>Herança</h3>

<p>Herança é um mecanismo da POO onde uma classe herda características de outra classe. A classe <q>filha</q> reaproveita atributos e métodos da classe <q>mãe</q>, podendo também adicionar novos comportamentos ou modificar os existentes. Serve para evitar repetição de código e para organizar as classes de forma mais lógica.</p>

<p>Exemplo, classe Animal (mãe):</p>

<pre>
<code>
public class Animal {
    protected String nome;

    public void dormir() {
        System.out.println(this.nome + " está dormindo...");
    }

    public String getNome() {
        return this.nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }
}
</code>
</pre>

<p>PS: Note que usamos o atributo como <q>protegido</q> dessa vez, o que permite que ele só seja manipulado na própria classe e em suas descendentes. Se colocar como <q>privado</q> as classes filhas não poderão acessá-lo diretamente.</p>

<p>Para uma classe herdar características de outra, usamos no Java a palavra <code>extends</code>.</p>

<p>Classe Cachorro (filha):</p>

<pre>
<code>
public class Cachorro extends Animal {
    // Método adicionado somente em Cachorro.
    public void latir() {
        System.out.println(this.getNome() + " está latindo!");
    }
}
</code>
</pre>

<p>Classe Gato (outra filha):</p>

<pre>
<code>
public class Gato extends Animal {
    // Método adicionado somente em Gato.
    public void miar() {
        System.out.println(this.getNome() + " está miando!");
    }
}
</code>
</pre>

<p>No caso acima, é encorajado usarmos o método getter, mas o atributo <q>nome</q> está acessível nas classes filhas por estar como <q>protegido</q>, e não <q>privado</q>.</p>

<p>E no código principal:</p>

<pre>
<code>
Cachorro cao = new Cachorro();

cao.setNome("Rex");
cao.dormir(); // Herdado da classe Animal.
cao.latir(); // Próprio de Cachorro.

Gato gat = new Gato();

gat.setNome("Frajola");
gat.dormir(); // Herdado.
gat.miar(); // Próprio de Gato.
</code>
</pre>

<p>Lembrando do caso das interfaces, poderíamos até declarar os dois objetos acima como do tipo <q>Animal</q>, mas nesse caso só poderia ser usado os métodos descritos nesta classe (no caso, o <q>dormir</q>), já os métodos <q>latir</q> e <q>miar</q> não poderiam ser usados.</p>

<p>Veja os diagramas dessas classes:</p>

<table style="float: left">
    <tr>
        <th>Animal</th>
    </tr>
    <tr>
        <td>
            # nome: String
        </td>
    </tr>
    <tr>
        <td>
            + dormir(): void
        </td>
    </tr>
</table>

<table style="float: left; margin-left: 25px">
    <tr>
        <th>Cachorro</th>
    </tr>
    <tr>
        <td>
            (receberá elementos de Animal)<br/>
            + latir(): void
        </td>
    </tr>
</table>

<table style="margin: auto auto 75px 425px">
    <tr>
        <th>Gato</th>
    </tr>
    <tr>
        <td>
            (receberá elementos de Animal)<br/>
            + miar(): void
        </td>
    </tr>
</table>

<p>Para trabalhar com construtores em heranças, temos métodos especiais para isso. No caso do Java, é o <code>super()</code>, mas outras linguagens podem ter outros nomes (no PHP é o <code>parent::__construct()</code>, no C# é o <code>base()</code>, C++ e outras linguagens chamam a classe mãe diretamente, como <code>Animal()</code>).</p>

<p>Independente do nome, esses métodos são usados para:</p>

<ul>
    <li>Acessar métodos da classe mãe.</li>
    <li>Acessar atributos da classe mãe.</li>
    <li>Chamar o construtor da classe mãe (mesmo se for vazio, em alguns casos).</li>
</ul>

<p>Veja a classe Animal alterada:</p>

<pre>
<code>
public class Animal {
    protected String nome;

    public void dormir() {
        System.out.println(this.nome + " está dormindo...");
    }

    public Animal(String nome) {
        this.nome = nome;
        System.out.println("Animal criado: " + this.nome); // Não é recomendado usar comandos de saída no construtor, apenas está como exemplo.
    }

    public String getNome() {
        return this.nome;
    }
}
</code>
</pre>

<p>Classe Cachorro:</p>

<pre>
<code>
public class Cachorro extends Animal {
    public void latir() {
        System.out.println(this.getNome() + " está latindo!");
    }

    public Cachorro(String nome) {
        super(nome); // chama o construtor da classe Animal
        System.out.println("Cachorro criado: " + this.getNome());
    }
}
</code>
</pre>

<p>Classe Gato:</p>

<pre>
<code>
public class Gato extends Animal {
    public void miar() {
        System.out.println(this.getNome() + " está miando!");
    }

    public Gato(String nome) {
        super(nome); // chama o construtor da classe Animal
        System.out.println("Gato criado: " + this.getNome());
    }
}
</code>
</pre>

<p>Código principal:</p>

<pre>
<code>
Cachorro cao = new Cachorro("Rex");

cao.dormir(); // Herdado da classe Animal.
cao.latir(); // Próprio de Cachorro.

Gato gat = new Gato("Frajola");

gat.dormir(); // Herdado.
gat.miar(); // Próprio de Gato.
</code>
</pre>

<p>Nas classes herdeiras, podemos não só chamar o método construtor, mas qualquer outro método das classes ascendentes, no caso do Java é na sintaxe <code>super.nomeDoMetodo()</code>, desde que sejam públicos ou protegidos.</p>

<p>Podemos ter uma hierarquia de heranças, onde as classes mais altas na hierarquia são mais gerais, e as classes mais baixas são mais específicas. Por exemplo: a classe Animal pode ser herdada por Mamifero, que pode ser herdada por Felino, que por sua vez pode ser herdada por Gato.</p>

<p>Algumas linguagens, como o C++, permitem herança múltipla, quando uma classe herda de mais de uma classe ao mesmo tempo (na sintaxe <code>class ClasseHerdeira : public ClasseMae1, ClasseMae2</code>), mas como isso é mais sujeito a erros de implementação, muitas linguagens, como o C#, PHP e Java, não permitem isso, tendo que herdar somente de uma classe por vez (o que pode ter é a hierarquia de classes, mas somente uma herança por vez, no entanto, estas linguagens permitem implementar várias interfaces, como por exemplo em Java, <code>public class ClasseHerdeira extends ClasseMae implements NomeInterface1, NomeInterface2</code>.</p>

<p>Interfaces também podem herdar características de outras interfaces, usando a mesma lógica, no Java seria algo como <code>public interface InterfaceHerdeira extends InterfaceMae</code>. Nesse caso podemos ter mais de uma herança numa mesma interface.</p>

<h3>Polimorfismo de Sobreposição</h3>

<p>Polimorfismo de sobreposição acontece quando uma classe filha substitui (redefine) um método que veio da classe mãe, mudando o comportamento dele. O nome do método é o mesmo, mas o comportamento é diferente dependendo do objeto.</p>

<p>Exemplo de classe mãe:</p>

<pre>
<code>
public class Alimento {
    public void consumir() {
        System.out.println("Consumindo alimento...");
    }
}
</code>
</pre>

<p>Classe filha 1:</p>

<pre>
<code>
public class Fruta extends Alimento {
    @Override
    public void consumir() {
        super.consumir(); // Chamando método da classe mãe.
        System.out.println("Comendo uma fruta fresca.");
    }
}
</code>
</pre>

<p>Classe filha 2:</p>

<pre>
<code>
public class Verdura extends Alimento {
    @Override
    public void consumir() {
        super.consumir(); // Chamando método da classe mãe.
        System.out.println("Comendo uma verdura saudável.");
    }
}
</code>
</pre>

<p>Para trabalhar com métodos de classes mães em heranças, temos métodos especiais para isso. Da mesma forma que usamos nos construtores, podemos usar o super como citado acima no Java (no caso ficou <code>super.consumir()</code>, no PHP ficaria algo como <code>parent::consumir()</code>, e no C# <code>base.consumir()</code>, C++ e outras linguagens chamam a classe mãe diretamente (como <code>Alimento::consumir()</code>).</p>

<p>Como acontecia com as interfaces em Java, devemos colocar a notação <code>@Override</code> em métodos sobrepostos de outras classes.</p>

<p>No C# não colocávamos <code>override</code> nos métodos sobrescritos da interface, mas no caso de métodos de classes é necessário.</p>

<p>Veja os diagramas das classes acima:</p>

<table style="float: left">
    <tr>
        <th>Alimento</th>
    </tr>
    <tr>
        <td>
            + consumir(): void
        </td>
    </tr>
</table>

<table style="float: left; margin-left: 25px">
    <tr>
        <th>Fruta</th>
    </tr>
    <tr>
        <td>
            (receberá elementos de Alimento)
        </td>
    </tr>
</table>

<table style="margin: auto auto 75px 450px">
    <tr>
        <th>Verdura</th>
    </tr>
    <tr>
        <td>
            (receberá elementos de Alimento)
        </td>
    </tr>
</table>

<p>Código principal:</p>

<pre>
<code>
Alimento a1 = new Fruta();
Alimento a2 = new Verdura();

a1.consumir();  // chama o método da classe Fruta.
a2.consumir();  // chama o método da classe Verdura.
</code>
</pre>

<p>PS: Lembrando que, assim como acontecia com as interfaces, poderemos usar apenas métodos definidos na classe mãe, no caso, a Alimento.</p>

<p>Por padrão, no Java, assim como no PHP, todo método pode ser sobreposto, no caso da classe acima, para bloquear a sobreposição de um método, devemos colocar o final no método, de forma semelhante com as constantes. Na classe Alimento ficaria assim:</p>

<pre>
<code>
public class Alimento {
    public final void consumir() {
        System.out.println("Consumindo alimento...");
    }
}
</code>
</pre>

<p>Aí deveremos só implementar assim:</p>

<pre>
<code>
Alimento a1 = new Alimento();

a1.consumir();
</code>
</pre>

<p>Já no caso do C# e do C++, nenhum método pode ser sobreposto por padrão. Aí nesse caso deveremos colocar o <code>virtual</code> nos métodos que queremos sobrepôr, como nesse exemplo em C#:</p>

<pre>
<code>
class Alimento {
    public virtual void consumir() {
        Console.WriteLine("Consumindo alimento...");
    }
}
</code>
</pre>

<p>E no método que o sobrescrever na classe filha, colocamos <code>public override void consumir()</code> e o bloco de implementação do mesmo.</p>

<p>No caso do C#, podemos fazer com que um atributo ou método não seja sobrescrito com o <code>sealed</code> também.</p>

<h3>Abstração</h3>

<p>Voltando ao Java, podemos, assim como podemos fazer no C#, PHP, Python e outras linguagens, que um método seja abstrato também, para que possa ser sobreposto por classes filhas.</p>

<p>Um método abstrato é um método sem corpo, ou seja, sem código dentro dele. Ele apenas diz o que deve existir, mas não diz como funciona. Ele é criado em uma classe abstrata, e todas as classes filhas são obrigadas a implementar esse método, cada uma do seu jeito.</p>

<p>Veja um exemplo com a alteração da classe Alimento:</p>

<pre>
<code>
public abstract class Alimento {
    public abstract void consumir();
}
</code>
</pre>

<p>Se uma classe tiver pelo menos um método abstrato, ela obrigatoriamente deve ser declarada como abstrata. Por isso usamos a palavra-chave abstract tanto na classe quanto no método.</p>

<p>No entanto, uma classe pode ser abstrata mesmo sem ter métodos abstratos, isso acontece quando queremos impedir que ela seja instanciada diretamente ou quando ela serve apenas como modelo para outras classes.</p>

<p>No C++, não existe o <q>abstract</q>, nesse caso usamos métodos virtuais puros, que funcionam basicamente da mesma forma, no qual ele é associado a 0 sem nenhuma implementação, assim:</p>

<pre>
<code>
class Alimento {
    public:
        virtual void consumir() = 0;
        virtual ~Alimento() = 0; // Toda classe abstrata deve ter um método destrutor virtual puro, mesmo que os outros métodos não os sejam
};

Alimento::~Alimento() { // Bloco vazio mesmo, padrão no C++.

}
</code>
</pre>

<p>Daí, nas classes filhas podemos manter a implementação dos métodos normalmente:</p>

<p>Classe filha 1:</p>

<pre>
<code>
class Fruta extends Alimento {
    @Override
    public void consumir() {
        System.out.println("Comendo uma fruta fresca.");
    }
}
</code>
</pre>

<p>Classe filha 2:</p>

<pre>
<code>
class Verdura extends Alimento {
    @Override
    public void consumir() {
        System.out.println("Comendo uma verdura saudável.");
    }
}
</code>
</pre>

<p>No caso do C#, o <code>override</code> também é obrigatório na sobreposição de métodos abstratos, assim como acontece no Java, visto acima.</p>

<p>Aí no código principal, podemos chamar os objetos tipando eles com a classe abstrata:</p>

<pre>
<code>
Alimento a1 = new Fruta();
Alimento a2 = new Verdura();

a1.consumir();  // chama o método da classe Fruta
a2.consumir();  // chama o método da classe Verdura
</code>
</pre>

<p>PS: Lembrando que, assim como acontecia com as interfaces e classes normais, poderemos usar apenas métodos definidos na classe mãe, no caso, a Alimento, no entanto, por esta ser abstrata, não poderá ser instanciada (com <code>new Alimento()</code>).</p>

<p>Lembrando também que mesmo que uma classe tenha apenas métodos abstratos, ela ainda é uma classe, enquanto a interface é um contrato puro. Como visto, uma classe, mesmo abstrata, pode ter tudo que uma normal tem, já as interfaces são puramente contratos de métodos. Mesmo classes abstratas só podem ser herdadas uma vez por classes filhas, exceto no C++ que permite herança múltipla, e nessa linguagem usamos classes virtuais puras (equivalente as abstratas) para simular interfaces por esta não as ter por padrão.</p>

<p>No caso do polimorfismo de sobreposição, o método tem a mesma assinatura em classes diferentes.</p>

<h3>Polimorfismo de Sobrecarga</h3>

<p>Polimorfismo de sobrecarga acontece quando uma mesma classe tem vários métodos com o mesmo nome, mas com parâmetros diferentes (quantidade ou tipos). Ou seja, o método se chama igual, mas aceita entradas diferentes e executa ações parecidas. É usado para facilitar a vida do programador, permitindo fazer a mesma ação de maneiras diferentes.</p>

<p>Tanto métodos comuns como métodos construtores podem ter sobrecarga, desde que os parâmetros sejam diferentes.</p>

<p>Veja esse exemplo com o Microondas, onde o método ligar têm parâmetros e implementações diferentes, mesmo tendo o mesmo nome:</p>

<pre>
<code>
public class Microondas {
    // 1. Ligar sem parâmetros.
    public void ligar() {
        System.out.println("Microondas ligado com tempo padrão.");
    }

    // 2. Ligar com minutos e segundos (dois inteiros).
    public void ligar(int minutos, int segundos) {
        if((minutos &gt;= 1 && segundos &gt;= 0) || (minutos == 0 && segundos &gt;= 1)) {
            System.out.println("Microondas ligado por " + minutos + " min e " + segundos + " s.");
        }
        else {
            System.out.println("ERRO! Tempo inválido!");
        }
    }

    // 3. Ligar com comando aquecer (true/false).
    public void ligar(boolean aquecer) {
        if(aquecer) {
            System.out.println("Microondas ligado no modo aquecer.");
        }
        else {
            System.out.println("ERRO! Não posso aquecer!");
        }
    }

    // 4. Ligar usando programas especiais (String).
    public void ligar(String programa) {
        if(programa.equals("Pipoca")) {
            System.out.println("Microondas ligado para estourar pipoca.");
        }
        else if(programa.equals("Pizza")) {
            System.out.println("Microondas ligado para assar pizza.");
        }
        else {
            System.out.println("ERRO! Programa desconhecido!");
        }
        
    }
}
</code>
</pre>

<p>Diagrama da classe acima:</p>

<table>
    <tr>
        <th>Microondas</th>
    </tr>
    <tr>
        <td>
            + ligar(): void<br/>
            + ligar(minutos: int, segundos: int): void<br/>
            + ligar(aquecer: boolean): void<br/>
            + ligar(programa: String): void
        </td>
    </tr>
</table>

<p>E na implementação:</p>

<pre>
<code>
Microondas micro = new Microondas();

micro.ligar(); // Sem parâmetros.
micro.ligar(1, 30); // Minutos e segundos.
micro.ligar(true); // Comando aquecer.
micro.ligar("Pipoca"); // Programa Pipoca.
micro.ligar("Pizza"); // Programa Pizza.
</code>
</pre>

<p>No caso acima, todos os métodos se chamam <q>ligar</q>. A diferença está nos parâmetros. Isso é polimorfismo de sobrecarga, pois a classe oferece várias formas de executar a mesma ação.</p>

<p>No caso do polimorfismo de sobrecarga, o método tem assinaturas diferentes na mesma classe.</p>

<p>PS: O polimorfismo de sobrecarga só é possível em linguagens estaticamente tipadas como o Java, C# e C++, mas não em todas (Objective-C, por exemplo, não o têm). Em linguagens dinamicamente tipadas como o PHP, Python e Javascript, não é possível implementá-lo.</p>



<ul>
    <li><a href="poo-algoritmos-2.html">Parte Anterior da Matéria!</a></li>
    <li><a href="poo-algoritmos-4.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>