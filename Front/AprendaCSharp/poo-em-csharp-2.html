<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda C#</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda C#</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-csharp-1.html">Tudo sobre C# Parte 1!</a></li>
                    <li><a href="tudo-sobre-csharp-2.html">Tudo sobre C# Parte 2!</a></li>
                    <li><a href="tudo-sobre-csharp-3.html">Tudo sobre C# Parte 3!</a></li>
                    <li><a href="tudo-sobre-csharp-4.html">Tudo sobre C# Parte 4!</a></li>
                    <li><a href="tudo-sobre-csharp-5.html">Tudo sobre C# Parte 5!</a></li>
                    <li><a href="tudo-sobre-csharp-6.html">Tudo sobre C# Parte 6!</a></li>
                    <li><a href="tudo-sobre-csharp-7.html">Tudo sobre C# Parte 7!</a></li>
                    <li><a href="tudo-sobre-csharp-8.html">Tudo sobre C# Parte 8!</a></li>
                    <li><a href="tudo-sobre-csharp-9.html">Tudo sobre C# Parte 9!</a></li>
                    <li><a href="tudo-sobre-csharp-10.html">Tudo sobre C# Parte 10!</a></li>
                </menu>
            </header>
                           
<h2>Orientação a Objetos em C# - Parte 2</h2>

<h3>Classes - Atributos e Métodos Estáticos</h3>

<p>Nem todo método pertence naturalmente a uma instância de classe, e podemos utilizar alguns métodos sem ter que instânciar as classes (sem criar objetos), isso é possível graças ao static. Ou seja, o método static acessa campos marcados como estáticos.</p>

<p>Crie esse método na classe Caixa:</p>

<pre>
<code>
public static int caixaLado2() {
    int lat = 2;
    int vol = lat * lat * lat;

    return vol;
}
</code>
</pre>

<p>E no programa principal, podemos chamar o método estático sem ter que instanciar a classe onde ela está:</p>

<pre>
<code>
Console.WriteLine(Caixa.caixaLado2());
</code>
</pre>

<p>Veja um exemplo de uso de métodos e atributos estáticos numa classe denominada Lampada:</p>

<pre>
<code>
class Lampada {
    private static float preco = 9.50f;
    private static bool acesa = false;

    public static void custo() {
        Console.WriteLine("A lâmpada custa R$ {0:0.00}.", preco);

        // Note que não usamos this para exibir atributos estáticos.
    }

    public static void acender() {
        Console.WriteLine("A lâmpada está acesa!");
        acesa = true;
    }

    public static void apagar() {
        Console.WriteLine("A lâmpada está apagada!");
        acesa = false;
    }
}
</code>
</pre>

<p>E no código principal:</p>

<pre>
<code>
static void Main(string[] args) {
    Lampada.custo(); // Método estático.

    Lampada.acender();
    Lampada.apagar();
}
</code>
</pre>

<p>PS: Não é recomendado chamar atributos e métodos estáticos através de objetos (tanto que algumas linguagens nem permitem isso), pois são atributos e métodos da classe, por isso devem ser chamados diretamente através dela.</p>

<p>Também podemos fazer novas atribuições em atributos estáticos no código principal, desde que sejam públicos, e toda instância feita por ele também é alterada, por exemplo:</p>

<pre>
<code>
Lampada.preco = 7.25f; // Atributo estático, deixe ele público
</code>
</pre>

<p>O static, teoricamente, significa que só uma alocação de memória é criada para esse atributo ou método, não tendo duas cópias na memória em simultâneo.</p>

<p>Em outras palavras, o static manipula os atributos e métodos na classe toda, não apenas em uma instância, e todo objeto criado com ela também terá essa alteração. São atributos e métodos globais.</p>

<p>PS: Métodos estáticos só podem trabalhar outros métodos e atributos quando estes também forem estáticos, e não podem ser sobrepostos. E atributos estáticos é recomendável eles serem inicializados.</p>

<h3>Classes - Campos Compartilhados</h3>

<p>Como visto, podemos criar métodos estáticos, que são compartilhadas com todos objetos instânciados pela mesma classe. Também podemos criar atributos estáticos.</p>

<p>Crie uma nova classe com o nome Acumula, e esse código aqui:</p>

<pre>
<code>
class Acumula {
    public static int soma;

    public Acumula() {
        soma = 0;
    }

    public void incrementa() {
        soma++;
    }

    public void incrementa(int valor) {
        soma += valor;
    }
}
</code>
</pre>

<p>Note que ele tem um atributo estático (que também pode ser chamado pela classe, sem criar um objeto). Também tem um polimorfismo de sobrecarga com incremento, onde escolhemos o incremento do número.</p>

<p>No programa principal, coloque isso:</p>

<pre>
<code>
Acumula[] obj = new Acumula[2];

obj[0] = new Acumula();
obj[1] = new Acumula();

obj[0].incrementa();
Console.WriteLine("O valor é {0}.",  Acumula.soma.ToString());

obj[1].incrementa(8);
Console.WriteLine("O valor é {0}.",  Acumula.soma.ToString());
</code>
</pre>

<p>Como o campo é compartilhado, ele altera o valor do atributo na classe, e todas as instâncias serão alteradas dessa mesma forma.</p>

<p>PS: Métodos getters e setters de atributos estáticos também devem ser estáticos, e não se utiliza o this dentro deles. Lembre-se também que qualquer método estático só pode trabalhar com atributos e métodos que também sejam estáticos. E atributos estáticos é recomendável os iniciar dentro da classe. Métodos estáticos não podem ser sobrepostos.</p>

<p>Também é melhor usarmos listas ao invés de arrays, quando estamos trabalhando com objetos, dessa forma:</p>

<pre>
<code>
List&lt;Acumula&gt; obj = new List&lt;Acumula&gt;();

obj.Add(new Acumula());
obj.Add(new Acumula());
</code>
</pre>
            
<p>Ou assim, mais simplificado:</p>

<pre>
<code>
List&lt;Acumula&gt; obj = new List&lt;Acumula&gt; {
    new Acumula(),
    new Acumula()
};
</code>
</pre>

<h3>Herança - Parte 1</h3>

<p>Herança é um conceito extremamente importante em orientação a objetos. Usamos a herança, por exemplo, para evitar repetição ao definirmos classes com características em comum e são relacionadas entre si. A herança é um relacionamento entre classes, que permite que uma classe adquira os membros de outra classe.</p>

<p>Um exemplo clássico de herança seria a classificação de mamíferos no reino animal. Homens, baleias e gatos são mamíferos, que cimpartilham muitas características entre si, mas claramente possuem atriutos que os diferem uns dos outros. Como podemos modelar baleias, gatos e humanos em um software? Podemos criar classes distintas para cada animal, mas essas classes teriam muitos comportamentos (métodos) em comum entre eles, como respirar, mamar e reproduzir-se, o que ocasionaria repetição desnecessária de código. Usamos então herança para resolver esse problema.</p>

<p>Podemos então criar uma classe chamada Mamifero que possua as funcionalidades comuns a todos os animais mamíferos, e então criar as classes Humano, Baleia e Gato, herando essas funcionalidades e também implementando as funcionalidades específicas de cada animal, como falar, nadar e arranhar.</p>

<p>Para declarar uma herança, coloque após o nome da classe, dois pontos e o nome da classe da qual ela herdará. A classe derivada herda da classe base, e os métodos da classe base se tornam parte da classe derivada. Em C# uma classe pode derivar no máximo de uma classe base. Mas uma classe pode derivar de uma classe já derivada de outra.</p>

<p>Veja a classe Mamifero abaixo:</p>

<pre>
<code>
class Mamifero {
    public void respirar() {
        Console.WriteLine("Eu Respiro!");
    }
    public void mamar() {
        Console.WriteLine("Eu Mamo");
    }
}
</code>
</pre>

<p>O da classe Gato, herdando de Mamifero:</p>

<pre>
<code>
class Gato : Mamifero {
    public void arranhar() {
        Console.WriteLine("Eu Arranho!");
    }
}
</code>
</pre>

<p>E o da classe Humano, também herdando de Mamifero:</p>

<pre>
<code>
class Humano : Mamifero {
    public void falar() {
        Console.WriteLine("Eu Falo!");
    }
}
</code>
</pre>

<p>E no programa principal, podemos declarar normalmente, assim:</p>

<pre>
<code>
Mamifero bicho = new Mamifero();
Humano homem = new Humano();
Gato bichano = new Gato();

homem.falar();
homem.respirar();

bichano.arranhar();
bichano.respirar();
</code>
</pre>

<p>PS: Não é possível herança múltipla, mas podemos fazer uma ou mais implementações, separadas por vírgula, seria algo tipo <code>class NomeDaClasse2 : NomeDaClasse1, NomeDaInterface</code>, sempre separados por vírgulas, a indicação da classe sempre vem antes das interfaces. E é possível usar herança em interfaces, no caso de uma interface herdar os métodos de outras (em interfaces podemos ter herança de mais de uma interface).</p>

<p>Também podemos chamar métodos da classe base nas classes filhas, usando a palavra-chave base, como por exemplo <code>base.nomeDoMetodo()</code>.</p>

<h3>Métodos Virtuais e Override - Herança - Parte 2</h3>

<p>Um método virtual é um método que pode ser sobreescrito em uma classe derivada. Isso significa que o método pode ser chamado e usado como foi originalmente escrito na classe base, mas também podemos escrever uma nova implementação dele que substitua o método original. Assim, os métodos são relacionados pois realizam tarefas similares, mas de forma específica em cada classe.</p>

<p>Marcamos um método como virtual usando a palavra-chave <code>virtual</code>. Veja um exemplo de método, que será colocado na classe Mamifero:</p>

<pre>
<code>
public virtual void lutar() { // Método virtual
    Console.WriteLine("Mamíferos Lutam entre Si!");
}
</code>
</pre>

<p>Um método override (sobreescrever) é um método em uma classe derivada que pode declarar uma outra implementação de um método virtual da classe base. Lembrando que:</p>

<ul>
    <li>Um método virtual não pode ser privado.</li>
    <li>As assinaturas do método virtual e do sobreescrito devem ser idênticas.</li>
    <li>Só é possível sobreescrever métodos virtuais.</li>
    <li>Um método sobreescrito é implicitamente virtual, pode ser sobreescrito em uma classe derivada.</li>
</ul>

<p>Podemos também tornar o método da classe mamífero abstrato, mas nesse caso a classe também terá a indicação abstract antes, o que não permitirá instanciar ela, apenas ser utilizada em heranças:</p>

<pre>
<code>
abstract class Mamifero {
    public abstract void lutar();
    
    public void respirar() {
        Console.WriteLine("Eu Respiro!");
    }
    public void mamar() {
        Console.WriteLine("Eu Mamo");
    }
}
</code>
</pre>

<p>PS: Nem toda classe abstrata precisa ter métodos abstratos. E de certa forma, a interface é como uma classe puramente abstrata.</p>

<p>Na classe Humano, podemos colocar uma nova implementação do método lutar(), dessa forma:</p>

<pre>
<code>
public override void lutar() { // Método sobreescrito
    base.lutar(); // Chamará o método da classe mãe, Mamifero, mas só pode ser usado caso não seja abstrato.
    Console.WriteLine("Humanos Lutam com Armas!");
}
</code>
</pre>

<p>E na classe Gato, também teremos que implementar o método lutar, assim:</p>

<pre>
<code>
public override void lutar() {
    base.lutar(); // Chamará o método da classe mãe, Mamifero, mas só pode ser usado caso não seja abstrato.    Console.WriteLine("Gatos Lutam Arranhando!");
}
</code>
</pre>

<p>PS: Métodos abstratos também usam override, assim como os virtuais, mas métodos implementados de interfaces não se utiliza override. Mas qualquer um deles faz parte do polimorfismo.</p>

<p>Lembrando que podemos colocar a tipagem como uma interface ou classe (de preferência abstrata), mas a declaração do objeto com new deve ser de uma classe não-abstrata que implemente ou herde os métodos dela, por exemplo:</p>

<pre>
<code>
Mamifero bichano = new Gato();
</code>
</pre>

<p>Isso é útil para ganharmos em polimorfismo, onde podemos usar vários tipos de objetos em, por exemplo, parâmetros, desde que eles tenham a mesma classe pai em comum. Isso é o polimorfismo de inclusão.</p>

<p>E no programa principal, usamos assim:</p>

<pre>
<code>
Mamifero homem = new Humano();
Mamifero bichano = new Gato();

homem.lutar();

bichano.lutar();
</code>
</pre>

<p>Como podemos ver, o método da classe Gato não foi alterado, apenas o da classe Humano. Isso é chamado de polimorfismo de sobreposição.</p>

<p>Também podemos fazer que os construtores de classes pai sejam herdados pros construtores filhos, dessa forma:</p>

<pre>
<code>
public Humano() : base() {
    // Código a ser inicializado aqui.
}
</code>
</pre>

<p>PS: Caso existissem parâmetros, eles só seriam especificados os tipos de todos nos primeiros, no segundo parenteses iriam só os parâmetros da classe pai sem declaração de tipo. Seria algo tipo <code>public ClasseFilha(int n1, int n2) : base(n1)</code>.</p>

<p>E também podemos fazer sobreposição de destrutores normalmente.</p>

<p>PS: Caso deseje que uma classe seja final (ou seja, que não possa ser herdada), coloque antes da classe a palavra sealed, algo como <code>sealed class NomeDaClasse</code>. Para métodos, usamos da mesma forma, algo como <code>sealed override void nomeDoMetodo()</code> (apenas métodos que sobrepõe outros podem ser selados). No caso de atributos use const, sempre inicializada, como <code>const int numero = 5</code>.</p>

<h3>Acesso Protegido - Herança - Parte 3</h3>

<p>Métodos e campos públicos em uma classe são acessíveis a todos. Já os privados são acessíveis apenas à classe em si. Porém, às vezes, é importante que uma classe base permita que as classes derivadas acessem alguns de seus membros, ao mesmo tempo em que esconde esses membros de outras classes fora da hierarquia de herança. Neste caso, usamos a palavra <code>protected</code>.</p>

<p>Se uma classe X é derivada de uma classe derivada Y, ela pode acessar os membros protegidos de Y. Já uma classe W, não derivada, não poderá acessar os membros protegidos da classe Y.</p>

<p>Crie a classe Veiculo, dessa forma:</p>

<pre>
<code>
class Veiculo { // Classe base
    protected string placa; // Campo protegido
    private string chassis;
    public int portas;

    public Veiculo() { // Construtor
        this.placa = "AAA-0000";
        this.chassis = "00000000000";
        this.portas = 4;
    }

    public void mostraChassis() {
        Console.WriteLine("O chassis é {0}", this.chassis); // this.chassis só é acessível dentro da própria classe
    }
}
</code>
</pre>

<p>PS: O this vai ser substituído pelo nome do objeto. Ele verifica um atributo dentro de um método da própria classe e será substituído pela classe chamadora.</p>

<p>E crie a classe Automovel, que herda de veículo:</p>

<pre>
<code>
class Automovel : Veiculo {
    public void dadosAuto() {
        Console.WriteLine("A placa do auto é {0}", this.placa);
    }
}
</code>
</pre>

<p>No caso acima, na classe Automovel não podemos usar o atributo chassis, mas podemos invocar pelo método que criamos.</p>

<p>No programa principal, podemos colocar isso:</p>

<pre>
<code>
Automovel meuCarro = new Automovel();

meuCarro.dadosAuto();
meuCarro.mostraChassis();

Console.WriteLine(meuCarro.portas.ToString());

Veiculo carro = new Veiculo();

carro.mostraChassis();
</code>
</pre>

<p>PS: Além de public, private e protected, um atributo ou método em C# pode ser declarado como <code>internal</code> (disponível para classes dentro do mesmo Assembly) e <code>private protected</code> (disponível para a mesma classe e derivadas dentro do mesmo Assembly).</p>

<ul>
    <li><a href="poo-em-csharp-1.html">Parte Anterior da Matéria!</a></li>
    <li><a href="poo-em-csharp-3.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>