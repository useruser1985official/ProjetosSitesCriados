<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda Python</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda Python</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-python-1.html">Tudo sobre Python Parte 1!</a></li>
                    <li><a href="tudo-sobre-python-2.html">Tudo sobre Python Parte 2!</a></li>
                    <li><a href="tudo-sobre-python-3.html">Tudo sobre Python Parte 3!</a></li>
                    <li><a href="tudo-sobre-python-4.html">Tudo sobre Python Parte 4!</a></li>
                    <li><a href="tudo-sobre-python-5.html">Tudo sobre Python Parte 5!</a></li>
                    <li><a href="tudo-sobre-python-6.html">Tudo sobre Python Parte 6!</a></li>
                    <li><a href="tudo-sobre-python-7.html" onclick="alert('Você já Está na Matéria desse Link!'); return false">Tudo sobre Python Parte 7!</a></li>
                    <li><a href="tudo-sobre-python-8.html">Tudo sobre Python Parte 8!</a></li>
                </menu>
            </header>
           
<h2>Tudo sobre Python Parte 7</h2>

<h3>Funções - Parte 2</h3>

<p>A interactive help (ajuda interativa) é algo fácil de ser usado em Python, já que tem a função nativa <code>help()</code>. Podemos ir direto no console Python e digitar isso para o visualizarmos, aí ele entrará no modo help e podemos digitar o nome da função ou atributo interno do Python (por exemplo, o print, o input, o len e o datetime). Ao digitar <code>quit</code> ele sairá desse modo.</p>

<p>Podemos também colocar a ajuda diretamente no script, com a função ou atributo especificado dentro dos parênteses (por exemplo, <code>help(print)</code>.</p>

<p>Podemos imprimir o documento da função ou atributo digitando ele, seguido de __doc__, como por exemplo, <code>print(input.__doc__)</code>.</p>

<p>As docstrings são basicamente, as strings de documentação, como a que acabamos de ver com a função __doc__.</p>

<p>Vamos supor que exista uma função chamada contador com três parâmetros, para início, fim e passo, por exemplo:</p>

<pre>
<code>
def contador(i, f, p):
    c = i
    while c <= f:
        print(f"{c} ", end="")
        c += p

    print("FIM!")

contador(2, 10, 2)
</code>
</pre>

<p>Como nós que criamos a função, sabemos como funciona, mas se outro programador ver essa mesma função, poderá não saber como ela funciona exatamente.</p>

<p>Para criar uma docstring, basta colocar dentro da função, antes de qualquer código, um comentário de várias linhas, assim:</p>

<pre>
<code>
def contador(i, f, p):
    """
    -> Faz uma contagem e mostra na tela.
    Parâmetro i: Início da Contagem.
    Parâmetro f: Fim da Contagem.
    Parâmetro p: Passo da Contagem.
    """
    c = i
    while c <= f:
        print(f"{c} ", end="")
        c += p

    print("FIM!")

contador(2, 10, 2)

help(contador)
</code>
</pre>

<p>PS: Podemos colocar outros comentários dentro dessas aspas, que aparecerá no help também.</p>

<p>Podemos também usar parâmetros opcionais, para entendermos como funciona, vamos supor uma função soma, assim:</p>

<pre>
<code>
def somar(a, b, c):
    s = a + b + c
    print(f"A soma vale {s}.")

somar(3, 2, 5)
</code>
</pre>

<p>Se colocarmos menos de três parâmetros, ele dará erro, para isso, podemos colocar atribuições padrão nos parâmetros, por exemplo:</p>

<pre>
<code>
def somar(a = 0, b = 0, c = 0):
    s = a + b + c
    print(f"A soma vale {s}.")

somar(3, 2, 5)
somar(8, 4)
somar(7)
somar()
</code>
</pre>

<p>Nesse caso, se ele não receber nenhum valor, ele será atribuído à zero, se receber ele será substituído pelo valor passado.</p>

<p>PS: Nem todos os parâmetros precisam ser inicializados, nesse caso, coloque os parâmetros nos à direita.</p>

<p>Podemos também, na mesma função acima, definir qual valor será passado em cada parâmetro, independente da ordem, por exemplo:</p>

<pre>
<code>
somar(b = 4, c = 2)
somar(c = 3, a = 2)
</code>
</pre>

<p>Escopo é o local onde ela existe, se ela existirá no programa todo ou dentro de alguma função.</p>

<p>Veja um exemplo de uso de variável global:</p>

<pre>
<code>
def teste():
    print(f"Na função teste, n vale {n}.")

n = 2 # Variável Global

print(f"No programa principal, n vale {n}.")
teste()
</code>
</pre>

<p>Pode ver que n existe no programa todo, por isso é uma variável global, acessada dentro e fora da função.</p>

<p>Vamos criar uma variável local da função teste, assim:</p>

<pre>
<code>
def teste():
    x = 8 # Variável Local
    
    print(f"Na função teste, n vale {n}.")
    print(f"Na função teste, x vale {x}.")

n = 2 # Variável Global

print(f"No programa principal, n vale {n}.")
print(f"No programa principal, x vale {x}.") # Dará erro porque a variável x é local da função.
teste()
</code>
</pre>

<p>Como visto acima, o programa não conseguiu acessar x fora da função teste, ela só existe dentro dela. Remova o print do x fora da função e funcionará normalmente.</p>

<p>PS: Variáveis de parâmetros também são locais da função.</p>

<p>Veja outro exemplo:</p>

<pre>
<code>
def teste2(b):
    b += 4 # Variável Local
    c = 2 # Variável Local
    print(f"A dentro vale {a}.")
    print(f"B dentro vale {b}.")
    print(f"C dentro vale {c}.")

a = 5 # Variável Global

teste2(a)
print(f"A fora vale {a}.")
</code>
</pre>

<p>Como visto acima, a não se alterou e é acessível tanto pra função quanto pra fora dela, e tem escopo global. As b e c são de escopo local.</p>

<p>Caso criemos uma variável a dentro da função, ela será outra variável, de escopo local, por exemplo:</p>

<pre>
<code>
def teste2(b):
    a = 8 # Variável Local, Não é o Mesmo a do Programa Principal
    b += 4 # Variável Local
    c = 2 # Variável Local
    print(f"A dentro vale {a}.")
    print(f"B dentro vale {b}.")
    print(f"C dentro vale {c}.")

a = 5 # Variável Global

teste2(a)
print(f"A fora vale {a}.")
</code>
</pre>

<p>Como visto acima, o a da função local tem valor diferente do a global.</p>

<p>Podemos também indicar que a variável é global dentro da função, de forma que ele não crie outra local com o mesmo nome, assim:</p>

<pre>
<code>
def teste2(b):
    global a
    a = 8 # Variável Global Alterada.
    b += 4 # Variável Local
    c = 2 # Variável Local
    print(f"A dentro vale {a}.")
    print(f"B dentro vale {b}.")
    print(f"C dentro vale {c}.")

a = 5 # Variável Global

teste2(a)
print(f"A fora vale {a}.")
</code>
</pre>

<p>No caso acima, o a global é alterado para 8 ao chamar a função. O b recebeu o parâmetro antes do a ser alterado.</p>

<p>Outro exemplo:</p>

<pre>
<code>
def funcao():
    n1 = 4
    print(f"N1 dentro vale {n1}.")

n1 = 2
funcao()
print(f"N1 fora vale {n1}.")
</code>
</pre>

<p>No caso acima, o n1 de dentro da função também não é o mesmo n1 do programa principal.</p>

<p>As funções também podem retornar valores, usando a palavra <code>return</code>, vamos voltar à função somar, como estava:</p>

<pre>
<code>
def somar(a = 0, b = 0, c = 0):
    s = a + b + c
    print(f"A soma vale {s}.")

somar(3, 2, 5)
somar(1, 7)
somar(4)
</code>
</pre>

<p>Alterada com retorno, ficaria assim:</p>

<pre>
<code>
def somar(a = 0, b = 0, c = 0):
    s = a + b + c
    return s

print(somar(3, 2, 5))
</code>
</pre>

<p>Aí, a função receberá um valor de retorno, e pode ser usada como uma variável, sendo atribuída a uma variável comum ou colocada no print.</p>

<p>PS: Qualquer tipo de valor pode ser retornado, como string (str), inteiro (int), real (float), booleano (bool), listas, dicionários, objetos, etc. Um procedimento que não retorna nada é considerado <q>None</q>.</p>

<p>Podemos também indicar o tipo de retorno também assim:</p>

<pre>
<code>
def somar(a = 0, b = 0, c = 0) -> int:
    s = a + b + c
    return s

print(somar(3, 2, 5))
</code>
</pre>

<p>Outro exemplo:</p>

<pre>
<code>
def somar(a = 0, b = 0, c = 0):
    s = a + b + c
    return s

r1 = somar(3, 2, 5)
r2 = somar(1, 7)
r3 = somar(4)

print(f"Meus cálculos deram {r1}, {r2} e {r3}.")
</code>
</pre>

<p>Vamos fazer um programa pra calcular fatoriais:</p>

<pre>
<code>
def fatorial(num = 1):
    f = 1 # Local

    for c in range(num, 0, -1):
        f *= c

    return f

n = int(input("Digite um número: "))

print(f"O fatorial de {n} é igual à {fatorial(n)}.")
</code>
</pre>

<p>Podemos fazer assim com a função acima:</p>

<pre>
<code>
f1 = fatorial(5)
f2 = fatorial(4)
f3 = fatorial()

print(f"Os resultados são {f1}, {f2} e {f3}.")
</code>
</pre>

<p>Outro exemplo, com valores booleanos:</p>

<pre>
<code>
def par(n = 0):
    if n % 2 == 0:
        return True
    else:
        return False

num = int(input("Digite um número: "))
print(par(num))
</code>
</pre>

<p>Usando a mesma função acima, podemos exibir assim:</p>

<pre>
<code>
if par(num): # O mesmo que par(num) == True
    print("É Par!")
else:
    print("É Ímpar!")
</code>
</pre>

<p>Temos também as expressões Lambda em Python, que são pequenas funções sem nome, usadas com uma variável, dessa forma:</p>

<pre>
<code>
mensagem = lambda: print("Expressão Lambda Exibida com Sucesso!")

mensagem() # Exibição de lambda
</code>
</pre>

<p>Quando precisar usar uma expressão Lambda com retorno, nem precisa indicar return, e quando tiver parâmetros basta escrever eles após a palavra lambda, separados por vírgulas, assim:</p>

<pre>
<code>
produto = lambda n1, n2: n1 * n2

print(f"O resultado da multiplicação é {produto(5, 2)}.") # Exibição de lambda com retorno
</code>
</pre>

<h3>Módulos e Pacotes</h3>

<p>Imagina que temos um programa grande, como o de um cadastro, se colocássemos todas as funções num arquivo só seria complicado pra entender e mantê-lo, pra isso surgiu os módulos, que nos permite dividir um programa grande.</p>

<p>Vamos supor a seguinte função:</p>

<pre>
<code>
num = int(input("Digite um número: "))

fat = fatorial(num)

print(f"O fatorial de {num} é {fat}.")
</code>
</pre>

<p>A função fatorial não existe no Python, teremos que criá-la, e faríamos assim:</p>

<pre>
<code>
def fatorial(n):
    f = 1
    
    for c in range(1, n + 1):
        f *= c

    return f
</code>
</pre>

<p>Até agora, colocamos tudo isso num arquivo só.</p>

<p>Mas vamos supor que no mesmo programa temos mais funções, por exemplo:</p>

<pre>
<code>
def fatorial(n):
    f = 1

    for c in range(1, n + 1):
        f *= c

    return f

def dobro(n):
    return n * 2

def triplo(n):
    return n * 3

num = int(input("Digite um número: "))

fat = fatorial(num)

print(f"O fatorial de {num} é {fat}.")
print(f"O dobro de {num} é {dobro(num)}.")
</code>
</pre>

<p>Dessa forma, podemos criar os módulos, fazemos isso criando um arquivo no projeto (por exemplo, uteis.py), e colocando as funções dentro dele:</p>

<pre>
<code>
def fatorial(n):
    f = 1

    for c in range(1, n + 1):
        f *= c

    return f

def dobro(n):
    return n * 2

def triplo(n):
    return n * 3
</code>
</pre>

<p>E para importar, faça da mesma forma que outros módulos, colocando o nome do arquivo seguido da função, assim:</p>

<pre>
<code>
import uteis

num = int(input("Digite um número: "))

fat = uteis.fatorial(num)

print(f"O fatorial de {num} é {fat}.")
print(f"O dobro de {num} é {uteis.dobro(num)}.")
</code>
</pre>

<p>Podemos também importar funções específicas assim:</p>

<pre>
<code>
from uteis import fatorial, dobro

num = int(input("Digite um número: "))

fat = fatorial(num)

print(f"O fatorial de {num} é {fat}.")
print(f"O dobro de {num} é {dobro(num)}.")
</code>
</pre>

<p>PS: Apesar de possível, não é recomendado importar duas ou mais funções de um módulo separando por vírgulas.</p>

<p>Podemos observar que usamos isso de forma parecida com o uso de módulos nativos do Python, como o math e o datetime.</p>

<p>As vantagens da modularização são várias, como organização do código, facilidade na manutenção, ocultação de código detalhado, reutilização em outros projetos, etc.</p>

<p>Temos também os pacotes no Python, que são como as bibliotecas de outras linguagens.</p>

<p>Caso os módulos também fiquem muito grandes, podemos separar em vários arquivos, que podem ser juntados em pacotes (por exemplo, o uteis pode ser um pacote com vários módulos separados, como o de números, strings, datas e cores, etc.)</p>

<p>Dentro do Python, assim como todo arquivo Python é um módulo, toda pasta é um pacote, e dentro do pacote podemos ter outros pacotes (por exemplo, o uteis pode ter pastas para arquivos de números, strings, etc). Cada pacote tem dentro dele um arquivo chamado __init__.py, que é onde temos nossos módulos.</p>

<p>Dentro do Pycharm, exclua o arquivo uteis.py e crie um pacote Python com o nome de uteis. Dentro de uteis, crie outros pacotes com o nomes especificados acima.</p>

<p>Vamos no pacote numeros e coloque as funções dentro dele, e no arquivo principal altere dessa forma:</p>

<pre>
<code>
from uteis import numeros

num = int(input("Digite um número: "))

fat = numeros.fatorial(num)

print(f"O fatorial de {num} é {fat}.")
print(f"O dobro de {num} é {numeros.dobro(num)}.")
</code>
</pre>


<ul>
    <li><a href="tudo-sobre-python-6.html">Parte Anterior da Matéria!</a></li>
    <li><a href="tudo-sobre-python-8.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>