<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda C#</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda C#</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-csharp-1.html">Tudo sobre C# Parte 1!</a></li>
                    <li><a href="tudo-sobre-csharp-2.html">Tudo sobre C# Parte 2!</a></li>
                    <li><a href="tudo-sobre-csharp-3.html">Tudo sobre C# Parte 3!</a></li>
                    <li><a href="tudo-sobre-csharp-4.html">Tudo sobre C# Parte 4!</a></li>
                    <li><a href="tudo-sobre-csharp-5.html">Tudo sobre C# Parte 5!</a></li>
                    <li><a href="tudo-sobre-csharp-6.html" onclick="alert('Você já Está na Matéria desse Link!'); return false">Tudo sobre C# Parte 6!</a></li>
                    <li><a href="tudo-sobre-csharp-7.html">Tudo sobre C# Parte 7!</a></li>
                    <li><a href="tudo-sobre-csharp-8.html">Tudo sobre C# Parte 8!</a></li>
                    <li><a href="tudo-sobre-csharp-9.html">Tudo sobre C# Parte 9!</a></li>
                    <li><a href="tudo-sobre-csharp-10.html">Tudo sobre C# Parte 10!</a></li>
                </menu>
            </header>
            
<h2>Tudo sobre C# Parte 6</h2>

<h3>Interfaces Gráficas - Apresentação das Tecnologias</h3>

<p>O C# é conhecido por criar facilmente interfaces gráficas para programas Windows. Duas das tecnologias usadas para isso são a Windows Forms e a WPF.</p>

<p>Primeiramente, vamos abrir um novo projeto do C#, da mesma forma que fizemos com a aplicação de console, mas ao invés dele, escolha a opção referente ao tipo de formulário usado. A Windows Forms é mais antiga, usada desde o .NET, a WPF é a mais recente e a recomendada para utilizar pela Microsoft, por permitir outros recursos de estilização, áudio e vídeo com mais facilidade, só que exige mais da sua máquina ao rodar.</p>

<p>Abra um Windows Forms, e coloque alguns elementos, indo em caixa de ferramentas, só para vermos a visualização deles, são vários, como button, label, painel, picturebox (para colocar imagens), etc.</p>

<p>Faça o mesmo com o WPF, note que este utiliza um XML (de forma parecida com Java FX).</p>

<h3>Interfaces Gráficas - Classe Form</h3>

<p>Primeiro, abra um projeto Windows Form, note que aparecerá uma janela, onde trabalharemos nela, ela na verdade é uma instância da classe Form do C#.</p>

<p>Observe que ao clicar no frame, podemos ver as propriedades dele, e alterar algumas, como o ícone padrão, maximação das janelas e etc.</p>

<p>Algumas delas são essas:</p>

<ul>
    <li><b>Windows State</b> - Define o estado visual inicial do formulário.</li>
    <li><b>Text</b> - Define o título do nosso aplicativo ou função da janela.</li>
    <li><b>StartPosition</b> - Define a posição inicial do formulário.</li>
    <li><b>Size</b> - Define o tamanho da janela em altura e largura.</li>
    <li><b>Opacity</b> - Define a opacidade do frame, em porcentagem.</li>
    <li><b>MaximizeBox</b> - Define se o frame pode ser redimensionado ou não (lembrando que devemos colacar também a opção FormBorderStyle como FixedSingle caso o MaximizeBox seja false, para não redimensionar).</li>
    <li><b>Icon</b> - Define um ícone pro programa (para alterar o ícone do programa é nas propriedades do programa, nas do frame só altera o do frame especificado).</li>
    <li><b>BackColor</b> - Cor de fundo da nossa tema.</li>
    <li><b>BackgroundImage</b> - Define a imagem de fundo pro programa.</li>
    <li><b>(Name)</b> - Nome do Formulário do método da classe do Código.</li>
</ul>

<p>Veja que no raio, em propriedades, tem os eventos disparados, como o Load, que é disparado ao executar ao programa (onde também podemos acessar o código do mesmo).</p>

<p>Um aplicativo pode ter várias janelas, verifique elas no gerenciador de soluções. Clique no primeiro nome para ver a janela, e no name do formulário para ver o código.</p>

<p>Aproveitando, crie uma nova janela Form no nosso projeto, em gerenciador de soluções. Podemos renomear os forms também, e clique em sim para refatorar, caso apareça a notificação.</p>

<p>Ao executar, só aparecerá a primeira janela, para a segunda janela aparecer, devemos usar um evento.</p>

<p>Vá na primeira janela, e vá em Load para ver o código dela, no código manipulador de evento (abaixo do construtor), colocaremos o código que fará aparecer a outra janela.</p>

<p>Para testarmos o evento Load, coloque esse código na primeira janela:</p>

<pre>
<code>
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace ClasseForm {
    public partial class ClasseForm : Form {
        public ClasseForm() {
            InitializeComponent();
        }

        private void Form1_Load(object sender, EventArgs e) {
            MessageBox.Show("Evento Load Disparado!");
        }
    }
}
</code>
</pre>

<p>Para aparecer a outra janela, vá ainda na primeira, em eventos e no click, onde criaremos uma instância da classe da segunda janela (objeto), dessa forma:</p>

<pre>
<code>
public ClasseForm() {
    InitializeComponent();
}

private void Form1_Load(object sender, EventArgs e) {
    MessageBox.Show("Evento Load Disparado!");
}

private void ClasseForm_Click(object sender, EventArgs e) {
    Janela2 tela = new Janela2();

    tela.Show();
}
</code>
</pre>

<p>Na segunda janela, vamos colocar um calendário (MonthCalendar), e execute o programa de novo.</p>

<p>PS: Se quiser colocar um ícone de imagem para o programa, vá em gerenciador de soluções e na pasta principal do projeto, vá em propriedades, aplicativo e em ícone e manifesto. Isso pode ser usado em aplicações de console também.</p>

<h3>Interface Gráfica - Button</h3>

<p>Vamos criar um Window Form, e nele colocaremos um button.</p>

<p>Nas propriedades do botão, altere o name do método do botão, e o texto do botão, que será Clique Aqui. Podemos mudar outras propriedades, como as cores e etc.</p>

<p>No evento clique (que pode ser acessado também clicando duas vezes no botão do formulário), coloque esse código:</p>

<pre>
<code>
private void botaoClicar_Click(object sender, EventArgs e) {
    MessageBox.Show("Botão Clicado!");
}
</code>
</pre>

<p>Agora crie um segundo botão, altere o nome e o texto dele, mas coloque o enabled false. Verifique que o botão aparece desabilitado, e altere o evento do primeiro botão dessa forma:</p>

<pre>
<code>
private void botaoClicar_Click(object sender, EventArgs e) {
    MessageBox.Show("Habilitando o botão 2!");
    botaoSeg.Enabled = true;
}
</code>
</pre>

<p>E também podemos criar um evento no segundo botão, que seria esse:</p>

<pre>
<code>
private void botaoSeg_Click(object sender, EventArgs e) {
    MessageBox.Show("O botão foi habilitado!");
}
</code>
</pre>

<h3>Métodos - Parâmetros Opcionais</h3>

<p>Um parâmetro é especificado como opcional quanto ele temos um valor padrão atribuído a ele. Caso passamos argumentos, ele usa os valores normalmente, se não passarmos ele usará os valores atribuídos aos mesmos.</p>

<p>PS: Os parâmetros obrigatórios deverão vir antes dos opcionais, sempre. O C# usa a opsição de cada argumento passado ao método para determinar a quais parâmetros elels se referem (em ordem).</p>

<p>Veja um exemplo abaixo:</p>

<pre>
<code>
using System;

namespace MetodosParametrosOpcionais {
    class Program {
        static void Main(string[] args) {
            int param1;
            string param2;

            Console.WriteLine("Sem passar o parâmetro opcional!");
            Console.Write("Digite o parâmetro obrigatório (número): ");
            param1 = int.Parse(Console.ReadLine());
            parametros(param1);

            Console.WriteLine("");

            Console.WriteLine("Passando o parâmetro opcional!");
            Console.Write("Digite o parâmetro obrigatório (número): ");
            param1 = int.Parse(Console.ReadLine());
            Console.Write("Digite o parâmetro opcional (texto): ");
            param2 = Console.ReadLine();
            parametros(param1, param2);

            Console.Read();
        }

        static void parametros(int par1, string par2 = "Texto Padrão do Método") {
            string resultado = "\nParâmetro obrigatório: " + par1.ToString() + "\nParâmetro opcional: " + par2 + ".";
            Console.WriteLine(resultado);
        }
    }
}
</code>
</pre>

<p>Veja que acima, apenas o primeiro parâmetro é obrigatório, o segundo é atribuído automaticamente e substituído no caso de passarmos ele.</p>

<h3>Métodos - Argumentos Nomeados</h3>

<p>É possível passar os argumentos para um método em qualquer ordem usando os argumentos nomeados.</p>

<p>Veja como fazemos abaixo, no mesmo programa anterior:</p>

<pre>
<code>
Console.WriteLine("Passando o parâmetro opcional!");
Console.Write("Digite o parâmetro obrigatório (número): ");
param1 = int.Parse(Console.ReadLine());
Console.Write("Digite o parâmetro opcional (texto): ");
param2 = Console.ReadLine();
parametros(par2: param2, par1: param1);
</code>
</pre>

<p>Pode ver no código acima, que colocamos a passagem de parêmetros invertidos, mas colocamos os nomes do argumento na função seguido da nossa variável.</p>

<h3>Métodos - Modificadores de Acesso</h3>

<p>Um modificador de acesso permite determinar o nível de acessibilidade dos membros e tipos em um método, controlando assim como eles podem ou não, serem acessados por outros métodos ou a partir de outros assemblies. Os modificadores de acesso em C# são public, private, protected, internal e protected internal.</p>

<p>O tipo ou membro public pode ser acessado sem restriçõesp or qualquer outro código no mesmo assembly ou em outros assemblies que façam referência a ele. Portanto, são visível pelos métodos de qualquer classe. O tipo ou membro private só pode ser acessado por códigos que estejam na mesma classe ou struct. O protected só pode ser acessados por códigos da classe ou struct da qual pertencem, ou em uma classe que seja derivada dessa classe que contém o modificador. O internal pode ser acessado por código que esteja presente no mesmo assembly, mas não por códigos presentes em outros assemblies (montagens). O protected internal pode ser acessado por qualquer cóigo no mesmo assembly, ou de uma classe derivada em outro assembly.</p>

<p>PS: Isso já é um conceito aplicado em orientação a objetos.</p>

<p>Abra um projeto novo, e já crie nele uma classe com o nome Animal, dentro dessa classe coloque esse código:</p>

<pre>
<code>
using System;

namespace MetodosModificadoresDeAcesso {
    class Animal {
        private int idade = 10; // Não pode ser acessado por outra classe
        double peso; // Também não pode ser acessado

        public int obterIdade() {
            return idade; // Retornará porque o método é público, mesmo com o atributo privado, pois foi encapsulado.
        }

        public double obterPeso { // Isso é variável, não método
            get {return peso;}
        }
    }
}
</code>
</pre>

<p>PS: No C#, caso não indique a acessibilidade, ele será automaticamente considerado privado.</p>

<p>Na classe principal, podemos fazer assim, para criarmos nosso objeto.</p>

<pre>
<code>
using System;

namespace MetodosModificadoresDeAcesso {
    class Program {
        static void Main(string[] args) {
            int idade;
            double peso;

            Animal bicho = new Animal();

            idade = bicho.obterIdade();
            peso = bicho.obterPeso;

            Console.WriteLine("A idade é {0}\nO peso é {1:F}", idade, peso);

            Console.Read();
        }
    }
}
</code>
</pre>

<p>PS: Como não inicializamos o valor peso, ele retorna como zero, podemos colocar uma atribuição na classe Animal assim:</p>

<pre>
<code>
double peso =  50.4;
</code>
</pre>

<p>E ele será acessado pela variável obterPeso no programa principal, já que a peso é privada, a não ser que ela seja especificada como pública.</p>

<h3>Métodos - Modificador Static</h3>

<p>Podemos usar a palavra-chave static para criarmos um método estático, de modo que não seja necessário instanciar a classe para usá-lo. O modificador static indica que o membro em questão pertence à classe em si, e não às instâncias da classe. Apenas uma cópia do membro estático existe na aplicação, mesmo que várias instâncias da classe sejam criadas.</p>

<p>Veja um exemplo de método, podemos colocar ele na classe Animal, criada no programa anterior:</p>

<pre>
<code>
public static void mensagem() {
    Console.WriteLine("Método Estático!");
}
</code>
</pre>

<p>Na classe principal, note que não é possível chamar esse método diretamente, nem pelos métodos dos objetos criados, apenas com o nome da classe diretamente, por exemplo:</p>

<pre>
<code>
mensagem(); // Não funciona
bicho.mensagem(); // Não funciona

Animal.mensagem(); // Só assim funciona, chamando o nome da classe.
</code>
</pre>

<p>Dessa forma, um programa pode ter apenas esse método com o programa da classe, sem precisar criar quaisquer objeto.</p>

<p>PS: Muitos dos métodos internos do C# e de outras linguagens são estáticos, incluindo o main, funcionando de maneira bem similar. Veja um exemplo abaixo:</p>

<pre>
<code>
double pi;

pi = Math.PI;

Console.WriteLine(pi.ToString());
</code>
</pre>

<ul>
    <li><a href="tudo-sobre-csharp-5.html">Parte Anterior da Matéria!</a></li>
    <li><a href="tudo-sobre-csharp-7.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>