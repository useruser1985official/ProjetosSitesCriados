<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda C#</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda C#</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-csharp-1.html">Tudo sobre C# Parte 1!</a></li>
                    <li><a href="tudo-sobre-csharp-2.html">Tudo sobre C# Parte 2!</a></li>
                    <li><a href="tudo-sobre-csharp-3.html">Tudo sobre C# Parte 3!</a></li>
                    <li><a href="tudo-sobre-csharp-4.html">Tudo sobre C# Parte 4!</a></li>
                    <li><a href="tudo-sobre-csharp-5.html" onclick="alert('Você já Está na Matéria desse Link!'); return false">Tudo sobre C# Parte 5!</a></li>
                    <li><a href="tudo-sobre-csharp-6.html">Tudo sobre C# Parte 6!</a></li>
                    <li><a href="tudo-sobre-csharp-7.html">Tudo sobre C# Parte 7!</a></li>
                    <li><a href="tudo-sobre-csharp-8.html">Tudo sobre C# Parte 8!</a></li>
                    <li><a href="tudo-sobre-csharp-9.html">Tudo sobre C# Parte 9!</a></li>
                    <li><a href="tudo-sobre-csharp-10.html">Tudo sobre C# Parte 10!</a></li>
                </menu>
            </header>
            
<h2>Tudo sobre C# Parte 5</h2>

<h3>Arrays - Copiando e Clonando</h3>

<p>Para copiarmos os dados de um array, vamos proceder da seguinte forma: Criamos uma nova instância de array do mesmo tipo e mesmo tamanho do array original. Depois, copiamos os elementos um por um do original para o novo array.</p>

<p>Veja abaixo um exemplo:</p>

<pre>
<code>
using System;

namespace ArraysCopiandoEClonando {
    class Program {
        static void Main(string[] args) {
            int[] numeros = {4, 8, 12, 16, 20};
            int[] copia = new int[numeros.Length];

            for(int i = 0; i < numeros.Length; i++) {
                copia[i] = numeros[i];
            }

            for(int i = 0; i < numeros.Length; i++) {
                Console.WriteLine(copia[i]);
            }

            Console.Read();
        }
    }
}
</code>
</pre>

<p>Como copiar elementos do array é algo comum em programação, o C# possuí um método próprio para isso, o CopyTo(), usado dessa forma:</p>

<pre>
<code>
using System;

namespace ArraysCopiandoEClonando {
    class Program {
        static void Main(string[] args) {
            int[] numeros = {4, 8, 12, 16, 20};
            int[] copia = new int[numeros.Length];

            numeros.CopyTo(copia, 0);

            for(int i = 0; i < copia.Length; i++) {
                Console.WriteLine(copia[i]);
            }

            Console.Read();
        }
    }
}
</code>
</pre>

<p>PS: O CopyTo também pode copiar trechos de array, para colocar em outro array menor.</p>

<p>Também podemos usar o método Copy da classe Array, assim:</p>

<pre>
<code>
int[] numeros = {4, 8, 12, 16, 20};
int[] copia = new int[numeros.Length];

Array.Copy(numeros, copia, copia.Length);

for(int i = 0; i < copia.Length; i++) {
    Console.WriteLine(copia[i]);
}
</code>
</pre>

<p>E podemos clonar ele também, diretamente, usando o método Clone(), dessa forma:</p>

<pre>
<code>
int[] numeros = {4, 8, 12, 16, 20};
int[] copia = (int[])numeros.Clone(); // Não esquecer do typecast

for(int i = 0; i < copia.Length; i++) {
    Console.WriteLine(copia[i]);
}
</code>
</pre>

<h3>Listas em C#</h3>

<p>Os arrays em C# tem um problema, sempre terão posições fixas, caso necessitemos de uma variável composta com valores variáveis, utilizamos a lista, que é declarada assim:</p>

<pre>
<code>
List&lt;int&gt; numeros = new List&lt;int&gt;(); // inclua System.Collections.Generic
</code>
</pre>

<p>PS: A declaração pode ser com a interface IList (mas esta não permitirá trabalhar com alguns métodos), a inicialização é List mesmo.</p>

<p>Dentro das tags sempre irão o tipo primitivo ou classe invólucro dos elementos a serem colocados na lista. Para exibir os índices usamos as posições igual num array comum (como <code>numeros[0]</code>).</p>

<p>Para adicionar elementos à lista, usamos o método <code>Add()</code>, veja um exemplo no qual preenchemos a lista através de um laço while:</p>

<pre>
<code>
List&lt;int&gt; numeros = new List&lt;int&gt;();
int num = 1;

while(num <= 10) {
    numeros.Add(num);
    num++;
}

for(int i = 0; i < numeros.Count; i++) {
    Console.WriteLine(numeros[i]);
}
</code>
</pre>

<p>Exemplo mais comum de inicialização:</p>

<pre>
<code>
List&lt;int&gt; numeros = new List&lt;int&gt;();

numeros.Add(5);
numeros.Add(10);
</code>
</pre>
			
<p>Forma simplificada:</p>

<pre>
<code>
List&lt;int&gt; numeros = new List&lt;int&gt; {
    5,
    10
};
</code>
</pre>

<p>Para remover elementos da lista, usamos o <code>Remove()</code> (para remover pelo conteúdo), ou o <code>RemoveAt()</code> (que remove pelo índice). O <code>Clear()</code> limpa toda a lista e o <code>Any()</code> verifica se ela tem itens:</p>

<pre>
<code>
numeros.Remove(10); // Remove pelo conteúdo

numeros.RemoveAt(0); // Remove pelo índice

numeros.Clear(); // Remove tudo

numeros.Any(); // Verifica se tem itens e retorna um booleano
</code>
</pre>

<p>Para vermos se existe um elemento dentro da lista, usamos o <code>Contains()</code>, assim:</p>

<pre>
<code>
Console.WriteLine(numeros.Contains(15));
</code>
</pre>

<p>Para vermos a quantidade de elementos de uma lista, usamos o <code>Count</code>, assim:</p>

<pre>
<code>
Console.WriteLine(numeros.Count);
</code>
</pre>

<p>Para ordenar os elementos da lista, usamos o <code>Sort()</code> assim:</p>

<pre>
<code>
numeros.Sort(); // Não use com IList, e sim com List na inicialização.
</code>
</pre>

<p>E para exibir invertido, podemos usar ele em conjunto com o <code>Reverse()</code>, assim:</p>

<pre>
<code>
numeros.Sort(); // Não use com IList, e sim com List na inicialização.

numeros.Reverse(); // Idem.
</code>
</pre>

<p>Para exibir os elementos da lista, podemos usar o foreach, dessa forma:</p>

<pre>
<code>
foreach(int n in numeros) {
    Console.WriteLine(n);
}
</code>
</pre>

<p>Podemos usar uma Lambda para iterar a list, assim:</p>

<pre>
<code>
numeros.ForEach((n) => { // Não use IList com lambdas.
    Console.WriteLine(n);
});
</code>
</pre>

<p>Se for tudo na mesma linha, podemos simplificar mais, tirando as chaves:</p>

<pre>
<code>
numeros.ForEach(n => Console.WriteLine(n));
</code>
</pre>

<h3>Métodos - Declarando e Invocando</h3>

<p>Um método é uma sequência de declarações (comandos) que possui um nome de identificação. É similar a uma função ou procedimento. Um método possui um nome e um corpo onde ficam os comandos que serão executados quanto o método for chamado. Os métodos também podem receber dados para processamento (parâmetros) e retornar informações.</p>

<p>Os métodos em C#, assim como em outras linguagens fortemente tipadas, você coloca o tipo de retorno nele, por exemplo, int ou string. Caso você esteja escrevendo um método que não retornará um valor, use a palavra void no lugar do tipo de retorno.</p>

<p>O próprio método Main, é o método principal onde nosso programa é executado, todo programa em C# tem que ter esse método dentro da classe principal. Os métodos que criarmos são criados fora do Main (normalmente, nenhum método se cria dentro de outro), e invocados dentro dele. Deverá ter também a indicação <code>static</code> antes, que mostrará um método estático.</p>

<p>Veja um exemplo de criação de métodos, onde passamos parâmetros para ele, e ele retorna valores:</p>

<pre>
<code>
using System;

namespace MetodosDeclarandoEInvocando {
    class Program {
        static void Main(string[] args) {
            int adicao;
            int valor1, valor2;

            Console.Write("Digite um número: ");
            valor1 = int.Parse(Console.ReadLine());
            Console.Write("Digite um número: ");
            valor2 = int.Parse(Console.ReadLine());

            adicao = soma(valor1, valor2);

            Console.WriteLine("A soma é {0}.", adicao.ToString());

            Console.Read();
        }

        static int soma(int n1, int n2) {
            int resul = n1 + n2;

            return resul;
        }
    }
}
</code>
</pre>

<p>PS: Os parâmetros não são obrigatórios ter em todas as funções, mas caso tenham, tem que ser passados todos eles nas invocações, no entanto, podemos inicializar esses mesmos parâmetros com valores padrão, mas não é recomendado usar porque é melhor usar a sobrecarga, que veremos mais pra frente. E tem casos que a declaração static não é obrigatória num método. Nos casos acima, é devido ao método main ser estático, e por isso só pode trabalhar com métodos estáticos.</p>

<h3>Métodos - Parâmetros de Valor</h3>

<p>Em C# temos quatro tipos de parâmetros de métodos, valor, ref, out e params.</p>

<p>O parâmetro de valor é o tipo padrão. Os parâmetros de valor passam uma cópia local de si mesmos ao método. Ou seja, o método usa o parâmetro, porém a cópia original do chamador não é modificada. O Argument opassado deve ser do mesmo tipo do parâmetro, ou ao menos conversível implicitamente.</p>

<p>Veja um exemplo simples de parâmetros de valor:</p>

<pre>
<code>
using System;

namespace MetodosParametrosDeValor {
    class Program {
        static void Main(string[] args) {
            int numero;

            Console.Write("Digite um número: ");
            numero = int.Parse(Console.ReadLine());

            quadrado(numero);

            Console.WriteLine("O número digitado foi {0}.", numero.ToString());

            Console.Readline();
        }

        static void quadrado(int num) {
            int quad = num * num;

            Console.WriteLine("O quadrado de {0} é {1}.", num, quad.ToString());
        }
    }
}
</code>
</pre>

<p>PS: Nos parâmetros também podemos passar arrays, passando a variável com colchetes, algo tipo <code>funcao(int[] vetorpassado)</code>.</p>

<h3>Métodos - Parâmetros ref</h3>

<p>Prefixando um parâmetro com a palavra ref, o compilador do C# gera código que passa uma referência ao argumento real em vez de uma cópia do argumento.Tanto o argumento quanto o parâmetro referenciam os mesmos dados.</p>

<p>Veja um exemplo logo abaixo, onde usamos ref antes do tipo do parâmetro:</p>

<pre>
<code>
using System;

namespace MetodosParametrosRef {
    class Program {
        static void Main(string[] args) {
            int numero;

            Console.Write("Digite um número: ");
            numero = int.Parse(Console.ReadLine());

            incrementa(ref numero); // Passa a referência na invocação

            Console.WriteLine("O valor incrementado é {0}.", numero);

            Console.Read();
        }

        static void incrementa(ref int valor) { // Indica a referência aqui também.
            valor++;
        }
    }
}
</code>
</pre>

<p>No caso, o ref não copia o valor da variável, e sim pega o endereço da posição do argumento (referência do local onde o argumento está).</p>

<p>Da forma acima, a variável número também é incrementa, junto com a valor.</p>

<h3>Métodos - Sobrecarga</h3>

<p>Métodos sobrecarregados são métodos que possuem o mesmo nome e são declarados no mesmo escopo. A sobrecarga é útil quanto precisamos efetuar a operação em tipos diferentes de dados ou conjuntos de informações que variam. Métodos sobrecarregados podem possuir números de parâmetros diferentes ou ainda tipos de parâmetros diferentes. O tipo de dados de retorno, contudo, é sempre o mesmo para todos os métodos sobrecarregados. Um exemplo clássico é o método Writeline() da classe Console.</p>

<p>Veja abaixo um exemplo, onde temos duas funções com mesmo nome, diferenciadas pelos parâmetros passados nas mesmas:</p>

<pre>
<code>
using System;

namespace MetodosSobrecarga {
    class Program {
        static void Main(string[] args) {
            double resultado;
            int num1, num2;

            Console.Write("Digite um Nº para calcular seu quadrado: ");
            num1 = int.Parse(Console.ReadLine());

            resultado = potencia(num1);

            Console.WriteLine("O quadrado de {0} é {1}.", num1, resultado);

            Console.WriteLine();

            Console.Write("Digite dois Nº para calcular x ^ y: ");
            num1 = int.Parse(Console.ReadLine());
            num2 = int.Parse(Console.ReadLine());

            resultado = potencia(num1, num2);

            Console.WriteLine("{0} elevado a {1} é {2}.", num1, num2, resultado);

            Console.Read();
        }

        static double potencia(int valor1) {
            return valor1 * valor1;
        }

        static double potencia(int valor1, int valor2) {
            return Math.Pow(valor1, valor2);
        }
    }
}
</code>
</pre>

<p>No caso acima, o programa identificará qual é o método invocado pelo parâmetros. O próprio Console.WriteLine() trabalha com sobrecarga, pois quando usamos ele de forma formatada, ele recebe alguns parâmetros, além da string.</p>

<h3>Expressões Lambdas</h3>

<p>As expressões lambda se comportam como um tipo de delegate. Entendemos que a expressão lambda é uma espécie de função, porém sem nome, elas realizam cálculos, filtros, e retornam um valor (ou uma coleção de valores).</p>

<p>Para criar uma expressão lambda simples, basta declarar ela assim:</p>

<pre>
<code>
Action expr = () => {
    Console.WriteLine("Exibição de Lambda!");
};

expr(); // Invocando a expressão lambda.
</code>
</pre>

<p>Podendo inclusive, se for na mesma linha, omitir as chaves, assim:</p>

<pre>
<code>
Action expr = () => Console.WriteLine("Exibição de Lambda!");

expr();
</code>
</pre>

<p>Caso necessite criar uma função que retorne um valor e/ou precise de parâmetros, crie uma função abstrata indicando delegate, por exemplo:</p>

<pre>
<code>
delegate int Resul(int n1, int n2); // Método abstrato que retornará um valor
    
static void Main(string[] args) {  
    Resul soma = (n1, n2) => n1 + n2; // Note que indicar retorno e tipos é desnecessário

    Console.WriteLine(soma(10, 5));
}
</code>
</pre>

<p>Também podemos usar Lambdas para correr elementos de um contâiner, por exemplo:</p>

<pre>
<code>
List&lt;string&gt; bebidas = new List&lt;string&gt;(); // Não use IList
            
bebidas.Add("Água");
bebidas.Add("Suco");
bebidas.Add("Refrigerante");

// Ambos abaixo substituem o foreach tradicional:

// Sem Lambda:
bebidas.ForEach(delegate(string b) {
    Console.WriteLine(b);
});

// Com Lambda:       
bebidas.ForEach(b => Console.WriteLine(b));
</code>
</pre>

<ul>
    <li><a href="tudo-sobre-csharp-4.html">Parte Anterior da Matéria!</a></li>
    <li><a href="tudo-sobre-csharp-6.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>