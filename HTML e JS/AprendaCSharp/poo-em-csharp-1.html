<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda C#</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda C#</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-csharp-1.html">Tudo sobre C# Parte 1!</a></li>
                    <li><a href="tudo-sobre-csharp-2.html">Tudo sobre C# Parte 2!</a></li>
                    <li><a href="tudo-sobre-csharp-3.html">Tudo sobre C# Parte 3!</a></li>
                    <li><a href="tudo-sobre-csharp-4.html">Tudo sobre C# Parte 4!</a></li>
                    <li><a href="tudo-sobre-csharp-5.html">Tudo sobre C# Parte 5!</a></li>
                    <li><a href="tudo-sobre-csharp-6.html">Tudo sobre C# Parte 6!</a></li>
                    <li><a href="tudo-sobre-csharp-7.html">Tudo sobre C# Parte 7!</a></li>
                    <li><a href="tudo-sobre-csharp-8.html">Tudo sobre C# Parte 8!</a></li>
                    <li><a href="tudo-sobre-csharp-9.html">Tudo sobre C# Parte 9!</a></li>
                    <li><a href="tudo-sobre-csharp-10.html">Tudo sobre C# Parte 10!</a></li>
                </menu>
            </header>
                           
<h2>Orientação a Objetos em C# - Parte 1</h2>

<h3>Classes - Criando e Instanciando</h3>

<p>Classes são "pacotes" de código que definem classsificações de dados (igual os tipos), os quais possuem proiedades e operações (métodos) em linguagens orientadas a objetos (OOP). As propriedades (atributos) armazenam valores e características dos dados, já os métoos são funções internas às classes, que permitem agir sobre elas para executar ações.</p>

<p>Objetos são instancias de uma classe que possuem características e comportamentos. Podemos criar múltiplas instâncias de uma mesma classe. As propriedades, métodos e eventos de uma classe são alocadas em memória através da instância de um objeto.</p>

<p>As vantagens da POO, incluem reutilização de códigos, modularidade, uso mais simples (realístico) e código mais limpo e claro.</p>

<p>Para definir classes, usamos a palavra-chave class, por exemplo:</p>

<pre>
<code>
class Caixa {
    double lado;

    double volume() {
        return lado * lado * lado;
    }
}
</code>
</pre>

<p>Abra um novo projeto console do C#, note que mesmo no programa principal, já temos uma classe (Program), mas para trabalharmos com classes em C#, é recomendado criar arquivos separados de classes, e os arquivos terão os mesmos nomes das classes, em algumas linguagens POO não é possível criar várias classes no mesmo arquivo.</p>

<p>No gerenciador de soluções, escolha a opção classe e coloque o nome Caixa, esse será o código dela:</p>

<pre>
<code>
using System;

namespace ClassesCriandoEInstanciando {
    class Caixa {
        double lado;

        double volume() {
            return lado * lado * lado;
        }
    }
}
</code>
</pre>

<p>E para criar a instância da classe (o objeto), vá no programa principal da classe principal e coloque o código assim.</p>

<pre>
<code>
using System;

namespace ClassesCriandoEInstanciando {
    class Program {
        static void Main(string[] args) {
            Caixa cx;
            cx = new Caixa(); 
        }
    }
}
</code>
</pre>

<p>Mas o mais comum é chamar o objeto assim:</p>

<pre>
<code>
Caixa cx = new Caixa();
</code>
</pre>

<p>Quando criamos uma classe, temos mais trabalho para fazê-la, mas depois que ela está pronta, podemos criar quantos objetos precisarmos vindos dessa mesma classe, e o programa principal fica mais simples, menor e mais natural. Os objetos criados dessa mesma classe são independentes entre si e o status de um não interfere no outro. Essa é uma das vantagens da orientação a objetos.</p>

<p>PS: Caso queira retornar o nome do objeto em C#, use o método <code>this.GetType().Name</code> no objeto.</p>

<p>Os atributos podem ser de qualquer tipo, incluindo classes invólucro, o mesmo vale para parâmetros de construtores. É possível também chamar um atributo ou método de objeto agregado, por exemplo <code>objeto1.metodo2().metodo1()</code>.</p>

<h3>Classes - Modificando a Acessibilidade</h3>

<p>Quando temos que acessar algum atributo ou método da classe, ele não aparece por padrão no programa principal, devido ao fator de atributos e métodos por padrão, no C#, serem privados.</p>

<p>Para resolver isso, colocamos a indicação public, para colocar esses métodos públicos, dessa forma:</p>

<pre>
<code>
class Caixa {
    private double lado;

    public double volume() {
        return lado * lado * lado;
    }
}
</code>
</pre>

<p>Como vimos, além do método public (acesso total), temos o private (acesso apenas dentro da classe) e o protected (acesso dentro da classe e das descendentes, é como um meio termo entre o public e private).</p>

<p>Dessa forma, podemos mexer nesse atributo e usar os métodos na classe principal apenas se forem públicos, assim:</p>

<pre>
<code>
Caixa cx = new Caixa();

cx.lado = 5; // Só podemos mexer nele se for público
Console.WriteLine(cx.volume().ToString());

Console.Read();
</code>
</pre>

<h3>Getter, Setter e Encapsulamento</h3>

<p>Colocando os atributos privados, eles estarão encapsulados, mas para utilizar eles utilizamos dois tipos de métodos, os getters (que retornam o conteúdo) e os setters (que mudam o valor do conteúdo).</p>

<p>Veja como encapsular os dados usando o getter e o setter:</p>

<pre>
<code>
class Caixa {
    private double lado;

    public double volume() {
        return lado * lado * lado;
    }

    public double getLado() {
        return this.lado;
    }

    public void setLado(double lado) {
        this.lado = lado;
    }
}
</code>
</pre>

<p>PS: O this vai ser substituído pelo objeto.</p>

<p>Dessa forma, protegemos o acesso à variável, mas podemos pegar o valor dela com o getter e mudar ela pelo setter, assim:</p>

<pre>
<code>
Caixa cx = new Caixa();

cx.setLado(5);
Console.WriteLine(cx.getLado().ToString());

Console.Read();
</code>
</pre>

<p>No entanto, o mais comum é usarmos o getter e setter dessa forma no C#:</p>

<pre>
<code>
class Caixa {
    private double lado;

    public double volume() {
        return lado * lado * lado;
    }

    public double Lado {
        get {return this.lado;}
        set {this.lado = value;}
    }
}
</code>
</pre>

<p>Assim também:</p>

<pre>
<code>
class Caixa {
    private double lado;

    public double volume() {
        return lado * lado * lado;
    }

    public double Lado {
        get => lado;
        set => lado = value;
    }
}
</code>
</pre>

<p>Ou mais simplificado:</p>

<pre>
<code>
class Caixa {
    private double lado;

    public double volume() {
        return lado * lado * lado;
    }

    public double Lado {
        get;
        set;
    }
}
</code>
</pre>

<p>PS: O último método acima pode dar erro em objetos agregados, nesse caso use um dos dois modos anteriores.</p>

<p>Inclusive, podemos colocar um private no set ou no get caso queiramos que um deles seja restrito à classe.</p>

<p>E pra exibir:</p>

<pre>
<code>
Caixa cx = new Caixa();

cx.Lado = 5; // Setter
Console.WriteLine(cx.Lado); // Getter

Console.Read();
</code>
</pre>

<p>PS: Assim como no Java e no PHP, o C# permite trabalhar com interfaces, que faz o encapsulamento a nível de classe, nesse caso, podemos fazer a interface assim:</p>

<pre>
<code>
interface Estoque {
    void defineLado(int l);
    double volume();
}
</code>
</pre>

<p>E na classe que implementará os elementos, basta usar como uma herança, assim:</p>

<pre>
<code>
class Caixa : Estoque {
    private double lado;

    public void defineLado(int l) {
        this.lado = l;
    }

    public double volume() {
        return lado * lado * lado;
    }

    public double Lado {
        get;
        set;
    }
}
</code>
</pre>

<p>Em outras palavras, as interfaces estabelecem contratos entre as classes que as implementam, garantindo que elas tenham um certo comportamento, por isso, podemos declarar um objeto do tipo da interface e iniciar com a classe que a implementa, por exemplo:</p>

<pre>
<code>
Estoque cx = new Caixa();

cx.defineLado(5);

Console.WriteLine(cx.volume());

Console.Read();
</code>
</pre>

<p>As interfaces também garantem o encapsulamento, já que podemos usar somente os métodos descritos na interface nos objetos, e não permitir a visualização de atributos da classe implementadora.</p>

<p>Lembrando que podemos implementar mais de uma interface no programa, separando por vírgulas, algo tipo <code>class NomeDaClasse : NomeDaInterface1, NomeDaInterface2</code>. Lembrando também que muitos programadores colocam as interfaces com um "I" no começo para facilitar a identificação das mesmas (como no caso ficaria IEstoque), mas não é obrigatório.</p>

<p>PS: Podemos verificar se uma classe implementa uma interface usando um if e else, isso também vale pra classes:</p>

<pre>
<code>
Estoque cx = new Caixa();

if(typeof(Estoque).IsInstanceOfType(cx))) {
    cx.defineLado(5);

    Console.WriteLine(cx.volume());
}
else {
    Console.WriteLine("O objeto não implementa a interface Estoque!");
}
</code>
</pre>

<h3>Classes - Método Construtor</h3>

<p>Para que possamos usar essa classe criada ainda é necessário que os campos privados sejam inicializados, pois é inacessível pro exterior. Faremos isso usando um construtor.</p>

<p>Quando usamos a palavra new para criar um objeto, o runtime constrói o objeto usando a definição da classe. O runtime toma um pedaço da memória RAM, a preenche com os campos definidos pela classe e então invoca um construtor que realizará as inicializações requeridas.</p>

<p>Um construtor é um método especial que roda automaticamente quando uma classe é instanciada. Possui o mesmo nome da classe, e pode receber parâmetros, mas não retorna valores, nem mesmo void. Toda classe deve ter um construtor, se um não for escrito, o compilador gerará um automaticamente (que não faz absolutamente nada).</p>

<p>Veja abaixo o exemplo simples de construtor:</p>

<pre>
<code>
public Caixa() {
    lado = 10;
}
</code>
</pre>

<p>Na classe Caixa, ele ficaria assim (deixe o atributo lado privado):</p>

<pre>
<code>
class Caixa : Estoque {
    private double lado;

    public Caixa() {
        lado = 10;
    }

    public void defineLado(int l) {
        this.lado = l;
    }
    
    public double volume() {
        return lado * lado * lado;
    }
}
</code>
</pre>

<p>E no programa principal, faça isso:</p>

<pre>
<code>
Estoque cx = new Caixa();

double vol;
vol = cx.volume();

Console.WriteLine(vol.ToString());
</code>
</pre>

<p>Da mesma forma, podemos criar destrutores, mas eles são dispensáveis em C#, que faz a coleta de lixo automaticamente, mas para usar, fazemos assim na classe:</p>

<pre>
<code>
~Caixa {
    Console.WriteLine("Objeto Destruído");
}
</code>
</pre>

<p>PS: Não existe delete em C#.</p>

<h3>Classes - Sobrecarga de Construtor</h3>

<p>Podemos ter sobrecarga de métodos construtores no C# também. Basicamente, como em qualquer outra função, é criar um segundo construtor (que obviamente, também terá o mesmo nome da classe), mas com parâmetros diferentes.</p>

<p>No nosso exemplo, a classe Caixa terá o construtor padrão sem parâmetros (que adiciona 10 ao atributo lado automaticamente) e o segundo construtor que receberá um parâmetro para definiir esse mesmo atributo, dessa forma:</p>

<pre>
<code>
public Caixa() {
    lado = 10;
}

public Caixa(double l) {
    lado = l;
}
</code>
</pre>

<p>E no programa principal, fazemos assim (veja a diferença dos objetos):</p>

<pre>
<code>
Estoque cx1 = new Caixa();

double volume1;
volume1 = cx1.volume();

Console.WriteLine(volume1.ToString());

Estoque cx2 = new Caixa(8);

double volume2;
volume2 = cx2.volume();

Console.WriteLine(volume2.ToString());
</code>
</pre>

<p>PS: Podemos ter mais de dois construtores sobrecarregados, desde que não sejam do mesmo tipo de parâmetros. Caso num construtor precise inicializa um atributo como nulo, use <code>null</code>.</p>

<h3>Classes - Atributos e Métodos Estáticos</h3>

<p>Nem todo método pertence naturalmente a uma instância de classe, e podemos utilizar alguns métodos sem ter que instânciar as classes (sem criar objetos), isso é possível graças ao static. Ou seja, o método static acessa campos marcados como estáticos.</p>

<p>Crie esse método na classe Caixa:</p>

<pre>
<code>
public static int caixaLado2() {
    int lat = 2;
    int vol = lat * lat * lat;

    return vol;
}
</code>
</pre>

<p>E no programa principal, podemos chamar o método estático sem ter que instanciar a classe onde ela está:</p>

<pre>
<code>
Console.WriteLine(Caixa.caixaLado2());
</code>
</pre>

<p>Veja um exemplo de uso de métodos e atributos estáticos numa classe denominada Lampada:</p>

<pre>
<code>
class Lampada {
    private static float preco = 9.50f;
    private static bool acesa = false;

    public static void custo() {
        Console.WriteLine("A lâmpada custa R$ {0:0.00}.", preco);

        // Note que não usamos this para exibir atributos estáticos.
    }

    public static void acender() {
        Console.WriteLine("A lâmpada está acesa!");
        acesa = true;
    }

    public static void apagar() {
        Console.WriteLine("A lâmpada está apagada!");
        acesa = false;
    }
}
</code>
</pre>

<p>E no código principal:</p>

<pre>
<code>
static void Main(string[] args) {
    Lampada.custo(); // Método estático.

    Lampada.acender();
    Lampada.apagar();
}
</code>
</pre>

<p>PS: Não é recomendado chamar atributos e métodos estáticos através de objetos (tanto que algumas linguagens nem permitem isso), pois são atributos e métodos da classe, por isso devem ser chamados diretamente através dela.</p>

<p>Também podemos fazer novas atribuições em atributos estáticos no código principal, desde que sejam públicos, e toda instância feita por ele também é alterada, por exemplo:</p>

<pre>
<code>
Lampada.preco = 7.25f; // Atributo estático, deixe ele público
</code>
</pre>

<p>O static, teoricamente, significa que só uma alocação de memória é criada para esse atributo ou método, não tendo duas cópias na memória em simultâneo.</p>

<p>Em outras palavras, o static manipula os atributos e métodos na classe toda, não apenas em uma instância, e todo objeto criado com ela também terá essa alteração. São atributos e métodos globais.</p>

<p>PS: Métodos estáticos só podem trabalhar outros métodos e atributos quando estes também forem estáticos, e não podem ser sobrepostos. E atributos estáticos é recomendável eles serem inicializados.</p>

<h3>Classes - Campos Compartilhados</h3>

<p>Como visto, podemos criar métodos estáticos, que são compartilhadas com todos objetos instânciados pela mesma classe. Também podemos criar atributos estáticos.</p>

<p>Crie uma nova classe com o nome Acumula, e esse código aqui:</p>

<pre>
<code>
class Acumula {
    public static int soma;

    public Acumula() {
        soma = 0;
    }

    public void incrementa() {
        soma++;
    }

    public void incrementa(int valor) {
        soma += valor;
    }
}
</code>
</pre>

<p>Note que ele tem um atributo estático (que também pode ser chamado pela classe, sem criar um objeto). Também tem um polimorfismo de sobrecarga com incremento, onde escolhemos o incremento do número.</p>

<p>No programa principal, coloque isso:</p>

<pre>
<code>
Acumula[] obj = new Acumula[2];

obj[0] = new Acumula();
obj[1] = new Acumula();

obj[0].incrementa();
Console.WriteLine("O valor é {0}.",  Acumula.soma.ToString());

obj[1].incrementa(8);
Console.WriteLine("O valor é {0}.",  Acumula.soma.ToString());
</code>
</pre>

<p>Como o campo é compartilhado, ele altera o valor do atributo na classe, e todas as instâncias serão alteradas dessa mesma forma.</p>

<p>PS: Métodos getters e setters de atributos estáticos também devem ser estáticos, e não se utiliza o this dentro deles. Lembre-se também que qualquer método estático só pode trabalhar com atributos e métodos que também sejam estáticos. E atributos estáticos é recomendável os iniciar dentro da classe. Métodos estáticos não podem ser sobrepostos.</p>

<p>Também é melhor usarmos listas ao invés de arrays, quando estamos trabalhando com objetos, dessa forma:</p>

<pre>
<code>
IList&lt;Acumula&gt; obj = new List&lt;Acumula&gt;();

obj.Add(new Acumula());
obj.Add(new Acumula());
</code>
</pre>
			
<p>Ou assim, mais simplificado:</p>

<pre>
<code>
IList&lt;Acumula&gt; obj = new List&lt;Acumula&gt; {
    new Acumula(),
    new Acumula()
};
</code>
</pre>

<ul>
    <li><a href="poo-em-csharp-2.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>