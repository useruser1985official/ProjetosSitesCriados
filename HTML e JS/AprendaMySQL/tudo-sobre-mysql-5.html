<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="_imagens/favicon.ico"/>
        <title>Aprenda MySQL</title>
        <link rel="stylesheet" href="_css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda MySQL</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-mysql-1.html">Tudo sobre MySQL Parte 1!</a></li>
                    <li><a href="tudo-sobre-mysql-2.html">Tudo sobre MySQL Parte 2!</a></li>
                    <li><a href="tudo-sobre-mysql-3.html">Tudo sobre MySQL Parte 3!</a></li>
                    <li><a href="tudo-sobre-mysql-4.html">Tudo sobre MySQL Parte 4!</a></li>
                    <li><a href="tudo-sobre-mysql-5.html" onclick="alert('Você já Está na Matéria desse Link!'); return false">Tudo sobre MySQL Parte 5!</a></li>
                    <li><a href="tudo-sobre-mysql-6.html">Tudo sobre MySQL Parte 6!</a></li>
                    <li><a href="tudo-sobre-mysql-7.html">Tudo sobre MySQL Parte 7!</a></li>
                </menu>
            </header>
            
<h2>Tudo sobre MySQL Parte 5</h2>

<h3>Funções Aritméticas e Operadores Aritméticos</h3>

<p>É possível realizar operações matemáticas simples nos valores de uma coluna e retornar resultados em uma coluna calculada. Para isso usamos os operadores comuns matemáticos (+, -, *, / e %). Os módulos podem ser calculados também com <code>mod</code> e a divisão inteira é feita com o operador <code>div</code>.</p>

<p>Veja um exemplo:</p>

<pre>
<code>
select nome, carga * 2 as 'Carga Dobrada' from cursos;
</code>
</pre>

<p>PS: Essa coluna Carga Dobrada não existe, ela aparecerá apenas pra esse select. O operador as (alias) que permite criar ela, é como um "apelido" pra coluna.</p>

<p>Podemos mostrar as mensagens diretamente no MySQL sem vincular à nenhum banco ou tabela:</p>

<pre>
<code>
select 'Olá Mundo';
</code>
</pre>

<p>Ou assim:</p>

<pre>
<code>
select 'Olá Mundo' as 'Mensagem';
</code>
</pre>

<p>Dessa forma, podemos fazer operações diretas no MySQL, por exemplo:</p>

<pre>
<code>
select 2 * 9 / 3;
</code>
</pre>

<p>Ou assim:</p>

<pre>
<code>
select 2 * 9 / 3 as 'Resultado';
</code>
</pre>

<p>Outro exemplo:</p>

<pre>
<code>
select nome, totaulas / 3 as 'Total de 1/3 das Aulas' from cursos;
</code>
</pre>

<p>Outro cálculo direto, onde retornamos uma divisão inteira e seu resto:</p>

<pre>
<code>
select 10 div 3 as 'Divisão de 10 por 3', 10 mod 3 as 'Resto de 10 por 3';
</code>
</pre>

<p>Também temos funções matemáticas no MySQL, por exemplo:</p>

<table>
    <tr>
        <th>Método</th>
        <th>Significado</th>
    </tr>
    <tr>
        <td>ceiling(x)</td>
        <td>Arredonda x para o inteiro acima</td>
    </tr>
    <tr>
        <td>floor(x)</td>
        <td>Arredonda x para o inteiro abaixo</td>
    </tr>
    <tr>
        <td>round(x)</td>
        <td>Arredonda x para o inteiro mais próximo</td>
    </tr>
    <tr>
        <td>pi()</td>
        <td>Retorna o valor de PI</td>
    </tr>
    <tr>
        <td>pow(x, y)</td>
        <td>Retorna x elevado a y</td>
    </tr>
    <tr>
        <td>sqrt(x)</td>
        <td>Retorna a traiz quadrada de x</td>
    </tr>
    <tr>
        <td>sin(x)</td>
        <td>Seno de um ângulo específico x, em radianos</td>
    </tr>
    <tr>
        <td>bin(x)</td>
        <td>Retorna a representação binária de x</td>
    </tr>
    
    <tr>
        <td>oct(x)</td>
        <td>Retorna a representação octal de x</td>
    </tr>
    
    <tr>
        <td>hex(x)</td>
        <td>Retorna a representação hexadecimal de x</td>
    </tr>
    <tr>
        <td>md5(x)</td>
        <td>Retorna o hash MD5 de x</td>
    </tr>
    <tr>
        <td>sha1(x)</td>
        <td>Retorna o hash SHA1 de x</td>
    </tr>
</table>

<p>Essas funções também podem ser usadas nos valores de uma coluna. Por exemplo:</p>

<pre>
<code>
select nome, ceiling(totaulas / 3) as 'Total de 1/3 das Aulas' from cursos;
</code>
</pre>

<h3>Funções em MySQL</h3>

<p>Funções e Procedimentos são dos tipos de rotinas armazenadas, parte da especificação SQL. São um pouco similares, mas com aplicações diferentes. São invocadas de formas diferentes também.</p>

<p>Uma função é usada para gerar um valor que pode ser usado em uma expressão. O valor é geralmente baseado em um ou mais parâmetros fornecidos à função. É executada como parte de uma expressão.</p>

<p>Para criar uma função, fazemos assim:</p>

<pre>
<code>
create function multi(a decimal(10, 2), b int)
returns int return a * b;
</code>
</pre>

<p>PS: Note que as variáveis a e b são locais.</p>

<p>E para executar ela:</p>

<pre>
<code>
select multi(2.5, 4) as 'Resultado';
</code>
</pre>

<p>E da mesma forma, podemos usar essa função em dados armazenados, assim:</p>

<pre>
<code>
select nome, multi(carga, 3) as 'Carga Triplicada' from cursos where idcurso = 2;
</code>
</pre>

<p>Para excluir uma função, basta usar o comando drop, assim:</p>

<pre>
<code>
drop function multi;
</code>
</pre>

<p>Basicamente, as funções retornam valores, diferente dos procedimentos, que não retornam nada.</p>

<h3>Procedimentos Armazenados Básico</h3>

<p>Um procedimento armazenado é uma sub-rotina disponível para aplicações que acessam sistemas de bancos de dados relacionais. Podem ser usadas para validação e dados, controle de acesso, execução de declarações SQL complexas e outras situações.</p>

<p>Para isso, criamos uma variável local chamada varId, que pegará como parâmetro a id do curso, assim:</p>

<pre>
<code>
create procedure ver_carga(varid smallint)
select nome, concat('A Carga é ', carga) as 'Carga Total' from cursos where idcurso = varid;
</code>
</pre>

<p>PS: O concat fará a concatenação da frase escrita com o dado do banco.</p>

<p>Para invocar o procedimento, fazemos assim:</p>

<pre>
<code>
call ver_carga(3);
</code>
</pre>

<p>E para excluir, fazemos assim:</p>

<pre>
<code>
drop procedure ver_carga;
</code>
</pre>

<h3>Blocos Begin End</h3>

<p>Os blocos begin e end são contêineres usados para delimitar blocos de comandos a serem executados pela função ou store procedure. Cada declaração aninhada possuí um delimitador (;), Um bloco begin pode ser aninhado dentro de outros blocos.</p>

<p>Porém, o delimitador de ponto e vírgula pode ser problemático pois, ao ser encontrado em um procedimento ou função, ela finaliza imediatamente. É uma espécie de alias para o comando go. Devemos então mudar esse "atalho" e, para isso, usamos o comando delimiter para criar rotinas com declarações compostas.</p>

<p>Veja um exemplo abaixo:</p>

<pre>
<code>
delimiter $$
create function aumenta_carga(car decimal(10, 2), porc decimal(10, 2))
returns decimal(10, 2)
begin
    return (car + car) * porc / 100;
end$$
delimiter ;
</code>
</pre>

<p>No código acima, o delimiter define que ele deve substituir o ponto e vírgula pelos dois cifrões (ou qualquer outro caracter definido por nós). As declarações da função ou procedimento vão entre o begin e o end (este definido pelos ois cifrões). No final o delimitador volta a ser o ; pela nova execução do delimiter.</p>

<p>E para invocar normalmente, fazemos assim:</p>

<pre>
<code>
select aumenta_carga(40, 10) as 'Resultado';
</code>
</pre>

<p>O mesmo vale para procedimentos:</p>

<pre>
<code>
delimiter //
create procedure ver_carga(varid smallint)
begin
    select nome, concat('A Carga é ', carga) as 'Carga Total' from cursos where idcurso = varid;
end//
delimiter ;
</code>
</pre>

<p>E para executar, use o mesmo modo:</p>

<pre>
<code>
call ver_carga(4);
</code>
</pre>

<p>PS: Exclua todas as funções e procedimentos não utilizadas, assim:</p>

<pre>
<code>
drop function aumenta_carga;
drop procedure ver_carga;
</code>
</pre>

<h3>Variáveis Locais e Escopo</h3>

<p>O escopo de uma variável diz respeito aos locais onde a variável "existe", ou seja, onde ela pode ser acessada.</p>

<p>Os níveis de escopo são esses:</p>

<ul>
    <li><b>Global: </b>Acessíveis de qualquer local.</li>
    <li><b>Sessão: </b>Variáveis @ e de sistema).</li>
    <li><b>Parâmetros: </b>Nível de rotinas, criadas quando a rotina é chamada, e destruídas quando a rotina termina.</li>
    <li><b>Local: </b>Limitadas ao bloco begin onde foram declaradas.</li>
</ul>

<p>Podemos criar variáveis locais em um procedimento ou função usando uma declaração declare dentro de um bloco begin. A variável pode ser criada e inicializada com um valor, se desejado. Ficam disponíveis apenas dentro do bloo onde foram criadas, e em bloos que existem dentro do bloco onde a variável foi criada. Após o bloco ter sido executado e encerrado, a variável é desalocada da memória.</p>

<p>Veja um exemplo abaixo:</p>

<pre>
<code>
delimiter //
create function aumenta_aulas(ident decimal(10, 2), porc decimal(10, 2))
returns decimal(10, 2)
begin
    declare total decimal(10, 2);
    select totaulas from cursos where idcurso = ident into total;
    return (total + total) * porc / 100;
end//
delimiter ;
</code>
</pre>

<p>No caso acima, o into faz a atribuição a variável local.</p>

<p>E para executar, normalmente:</p>

<pre>
<code>
select * from cursos where idcurso = 4;
select aumenta_aulas(4, 10) as 'Aumento da Carga';
</code>
</pre>

<p>Depois pode excluir essa função também.</p>

<h3>Blocos Condicionais IF, THEN, ELSE E CASE.</h3>

<p>Há dois tipos básicos de blocos condicionais, com if, elseif, else e endif, e con case, when, then, else e end case.</p>

<p>Veja um exemplo básico de uso:</p>

<pre>
<code>
delimiter //
create function calcula_aul(carg decimal(8, 2))
returns decimal(8, 2)
begin
    declare aultot decimal(8, 2);
    if carg < 20 then
        set aultot = 30;
    elseif carg < 50 then
        set aultot = 60;
    elseif carg < 80 then
        set aultot = 100;
    else
        set aultot = 150;
    end if;
    return aultot;
end//
delimiter ;
</code>
</pre>

<p>PS: O Else não é obrigatório.</p>

<p>E para executar normalmente, fazemos assim:</p>

<pre>
<code>
select calcula_aul(50) as 'Total de Aulas';
</code>
</pre>

<p>Podemos fazer com case também, dessa forma:</p>

<pre>
<code>
-- Primeiro exclua a função anterior:

drop function calcula_aul;

-- E crie novamente com o case, assim:

delimiter //
create function calcula_aul(carg decimal(8, 2))
returns decimal(8, 2)
begin
    declare aultot decimal(8, 2);
    case
    when carg < 20 then
        set aultot = 30;
    when carg < 50 then
        set aultot = 60;
    when carg < 80 then
        set aultot = 100;
    else
        set aultot = 150;
    end case;
    return aultot;
end//
delimiter ;
</code>
</pre>

<p>O Case geralmente é utilizado quando existem muitas condições.</p>

<p>Exclua a função caso não a utilize mais.</p>

<h3>Estruturas de Repetição - Loop</h3>

<p>Um bloco iterativo é um bloco de código que é executado repetidamente por um comando especial até que uma condilão de parada o interrompa. Um bloco iterativo pode ser aninhado com outros.</p>

<p>O MySQL possui três tipos básicos de blocos iterativos, loop, repeat e while</p>

<p>Veja um exemplo básico de uso de loop:</p>

<pre>
<code>
delimiter //
create procedure acumula(limite int)
begin
    declare contador int default 0;
    declare soma int default 0;
    laco_teste: loop
        set contador = contador + 1;
        set soma = soma + contador;
        if contador >= limite then
            leave laco_teste;
        end if;
    end loop laco_teste;
    select soma as 'Soma Total do Loop';
end//
delimiter ;
</code>
</pre>

<p>PS: O leave interrompe o laço, é como o break.</p>

<p>E para executar:</p>

<pre>
<code>
call acumula(10);
</code>
</pre>

<p></p>

<p>Depois exclua o procedimento criado.</p>

<h3>Estrutura de Repetição - Repeat</h3>

<p>Também podemos usar o repeat para criar laços, dessa forma:</p>

<pre>
<code>
delimiter //
create procedure acumula_repita(limite tinyint unsigned)
begin
    declare contador tinyint unsigned default 0;
    declare soma int default 0;
    repeat
        set contador = contador + 1;
        set soma = soma + contador;
    until contador >= limite
    end repeat;
    select soma as 'Soma Total do Repeat';
end//
delimiter ;
</code>
</pre>

<p>E para executar:</p>

<pre>
<code>
call acumula_repita(10);
</code>
</pre>

<p>PS: Como o contador é incrementado antes do teste condicional, um valor como 0, ao ser passado, resulta em valor errado. Na verdade, ele garante pelo menos a execução uma vez, independente da condição.</p>

<p>Podemos usar um rótulo no bloco begin, para podermos "tratar" esse erro num if, e usar o leave com o nome desse rótulo para sair do bloco, assim:</p>

<pre>
<code>
-- Primeiro exclua o procedimento anterior:

drop procedure acumula_repita;

-- E crie novamente, assim:

delimiter //
create procedure acumula_repita(limite tinyint unsigned)
main: begin
    declare contador tinyint unsigned default 0;
    declare soma int default 0;
    if limite < 1 then
        select 'O valor deve ser maior que zero!' as 'Erro';
        leave main;
    end if;
    repeat
        set contador = contador + 1;
        set soma = soma + contador;
    until contador >= limite
    end repeat;
    select soma as 'Soma Total do Repeat';
end//
delimiter ;
</code>
</pre>

<p>Exclua o procedimento se não usar mais.</p>

<ul>
    <li><a href="tudo-sobre-mysql-4.html">Parte Anterior da Matéria!</a></li>
    <li><a href="tudo-sobre-mysql-6.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>