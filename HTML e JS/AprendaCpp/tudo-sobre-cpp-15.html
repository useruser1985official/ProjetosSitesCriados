<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda C++</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda C++</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-cpp-1.html">Tudo sobre C++ Parte 1!</a></li>
                    <li><a href="tudo-sobre-cpp-2.html">Tudo sobre C++ Parte 2!</a></li>
                    <li><a href="tudo-sobre-cpp-3.html">Tudo sobre C++ Parte 3!</a></li>
                    <li><a href="tudo-sobre-cpp-4.html">Tudo sobre C++ Parte 4!</a></li>
                    <li><a href="tudo-sobre-cpp-5.html">Tudo sobre C++ Parte 5!</a></li>
                    <li><a href="tudo-sobre-cpp-6.html">Tudo sobre C++ Parte 6!</a></li>
                    <li><a href="tudo-sobre-cpp-7.html">Tudo sobre C++ Parte 7!</a></li>
                    <li><a href="tudo-sobre-cpp-8.html">Tudo sobre C++ Parte 8!</a></li>
                    <li><a href="tudo-sobre-cpp-9.html">Tudo sobre C++ Parte 9!</a></li>
                    <li><a href="tudo-sobre-cpp-10.html">Tudo sobre C++ Parte 10!</a></li>
                    <li><a href="tudo-sobre-cpp-11.html">Tudo sobre C++ Parte 11!</a></li>
                    <li><a href="tudo-sobre-cpp-12.html">Tudo sobre C++ Parte 12!</a></li>
                    <li><a href="tudo-sobre-cpp-13.html">Tudo sobre C++ Parte 13!</a></li>
                    <li><a href="tudo-sobre-cpp-14.html">Tudo sobre C++ Parte 14!</a></li>
                    <li><a href="tudo-sobre-cpp-15.html" onclick="alert('Você já Está na Matéria desse Link!'); return false">Tudo sobre C++ Parte 15!</a></li>
                    <li><a href="tudo-sobre-cpp-16.html">Tudo sobre C++ Parte 16!</a></li>
                </menu>
            </header>
            
<h2>Tudo sobre C++ Parte 15</h2>

<h3>Funções Lambda em C++11</h3>

<p>As funções Lambda são funções anônimas, que não tem nome e pode ser anexada à uma variável ou outra função, e podem ser declaradas em qualquer parte do código e a partir desse ponto, pode ser usada quantas vezes for necessárias, e podemos passar uma lista de variáveis externas que queremos trabalhar dentro da nossa função. E elas também não precisam ser prototipadas (declaradas) inicialmente no código, antes do main.</p>

<p>As funções Lambda tem essa estrutura: <code>[capturaDeVariaveis](parâmetros)->tipoDeRetorno {corpoDaFuncao};</code>.</p>

<p>Basicamente, criamos uma declaração Lambda assim:</p>

<pre>
<code>
int main() {
    [](){}; // Isso já é uma função Lambda, definida pelos colchetes.

    return 0;
}
</code>
</pre>

<p>Para exibir algo, atribuímos a Lambda à uma variável assim, e usamos como um método, assim:</p>

<pre>
<code>
int main() {
    auto mensagem = [](){cout << "Introdução às Lambdas em C++!" << endl;};

    mensagem();

    return 0;
}
</code>
</pre>

<p>Veja um exemplo de uso de função com parâmetros e retorno:</p>

<pre>
<code>
int main() {
    auto maior = [](int n1, int n2)->int{return (n1 > n2) ? n1 : n2;};

    cout << maior(2, 6) << endl;

    return 0;
}
</code>
</pre>

<p>A função Lambda não tem nome, mas como está associada à uma variável, ela pode ser invocada como uma função.</p>

<p>Podemos usar um vector para podemos passar quantidades diferentes de parâmetros, por exemplo:</p>

<pre>
<code>
int main() {
    auto maior = [](vector&lt;int&gt; n)->int { // Importe vector
        auto m = 0;

        for(int x: n) {
            m = (m > x) ? m : x;
        }

        return m;
    };

    cout << maior({9, 8, 2, 10, 45, 20, 5, 34, 12}) << endl;

    return 0;
}
</code>
</pre>

<p>No caso acima, com o uso de vector, podemos inserir a quantidade de números que quisermos de forma dinâmica.</p>

<p>A captura de variáveis pode ser feita de tal forma:</p>

<pre>
<code>
int main() {
    int x1, x2, x3, x4;
    x1 = 10;
    x2 = 5;
    x3 = 2;
    x4 = 12;

    auto soma = [x1, x2, x3, x4]()->int{return x1 + x2 + x3 + x4;};

    cout << soma() << endl;

    return 0;
}
</code>
</pre>

<p>Ou colocando o símbolo de <code>=</code> na captura de variáveis, que somará todas as variáveis do escopo, assim:</p>

<pre>
<code>
int main() {
    int x1, x2, x3, x4;
    x1 = 10;
    x2 = 5;
    x3 = 2;
    x4 = 12;

    auto soma = [=]()->int{return x1 + x2 + x3 + x4;};

    cout << soma() << endl;

    return 0;
}
</code>
</pre>

<p>Pode ser utilizado o igual no Lambda com argumentos também, dessa forma:</p>

<pre>
<code>
int main() {
    int x1, x2, x3, x4;
    x1 = 10;
    x2 = 5;
    x3 = 2;
    x4 = 12;

    auto maior = [=](vector&lt;int&gt; n)->int { // Importe vector
        auto m = 0;

        for(int x: n) {
            m = (m > x) ? m : x;
        }

        return m;
    };

    cout << maior({1, 2, 3, 4, 5, 6, 7, 8, 9}) << endl;

    return 0;
}
</code>
</pre>

<p>Podemos fazer a soma assim:</p>

<pre>
<code>
int main() {
    auto soma = [](vector&lt;int&gt; n)->int { // Importe vector
        auto s = 0;

        for(int x: n) {
            s += x;
        }

        return s;
    };

    cout << soma({1, 2, 3, 4, 5, 6, 7, 8, 9}) << endl;

    return 0;
}
</code>
</pre>

<h3>Constantes em C++11</h3>

<p>Seguindo a mesma lógica do C, só poderíamos definir constantes definindo uma macro no cabeçalho, por exemplo:</p>

<pre>
<code>
#include &lt;iostream&gt;
#define PI 3.141592

using namespace std;

int main() {
    cout << PI << endl;

    return 0;
}
</code>
</pre>

<p>Mas no C++ podemos ter constantes, usando a palavra <code>const</code> antes do atributo e inicializando ela:</p>

<pre>
<code>
#include &lt;iostream&gt;

using namespace std;

int main() {
    const double PI = 3.141592;

    cout << PI << endl;

    return 0;
}
</code>
</pre>

<p>PS: O const pode ser usado também em funções e métodos, desde que estes não façam alterações em variáveis ou atributos.</p>

<h3>Pair - Dados em Pares</h3>

<p>O pair se diferencia dos outros tipos de contâineres, por permitir sempre armazenar um par de dados, tipo um int e um string, ou um bool e um int, uma classe e um char, e etc.</p>

<p>Inicialmente, inclua a biblioteca utility, e coloque esse código:</p>

<pre>
<code>
pair&lt;int, string&gt; par(10, "Teste"); // Inclua utility

cout << par.first << " - " << par.second << endl;
</code>
</pre>

<p>Como vimos acima, o objeto pair foi definido como o primeiro sendo int e o segundo string, dessa forma, podemos exibir os elementos usando os atributos first e second, respectivamente.</p>

<p>Podemos também fazer sem inicializar o pair, assim:</p>

<pre>
<code>
pair&lt;int, string&gt; par;
    
par.first = 100;
par.second = "Cursos";

cout << par.first << " - " << par.second << endl;
</code>
</pre>

<p>Para declarar vetores de pair, fazemos assim:</p>

<pre>
<code>
const int TAM = 3;

pair&lt;int, string&gt; pares[TAM];

pares[0].first = 100;
pares[0].second = "Cursos";

pares[1].first = 200;
pares[1].second = "C++";

pares[2].first = 300;
pares[2].second = "Pair";
</code>
</pre>

<p>Podemos usar também o make_pair para facilitar a criação de pares:</p>

<pre>
<code>
const int TAM = 3;

pair&lt;int, string&gt; pares[TAM];

pares[0] = make_pair(100, "Cursos");

pares[1] = make_pair(200, "C++");

pares[2] = make_pair(300, "Pair");

for(int i = 0; i < 3; i++) {
    cout << pares[i].first << " - " << pares[i].second << endl;
}
</code>
</pre>

<p>PS: Podemos passar um pair dentro de outro pair, por exemplo:</p>

<pre>
<code>
pair&lt;int, pair&lt;string, double&gt;&gt; produtos[3];

produtos[0] = make_pair(10, make_pair("Mouse", 10.55));
produtos[1] = make_pair(20, make_pair("Teclado", 50.49));
produtos[2] = make_pair(30, make_pair("Monitor", 399.98));

for(int i = 0; i < 3; i++) {
    cout << produtos[i].first << " - " << produtos[i].second.first << " - " << produtos[i].second.second << endl;
}
</code>
</pre>

<p>Pode ver que da forma acima, o pair externo tem seu first e seu second, e nesse second tem outro pair, quando chamamos atributos deles, usamos o second.first e o second.second, se o pair interno for o primeiro, é first.first e first.second. Esteja atento quanto à isso.</p>

<p>Claro que em C++ é mais interessante usar o vector, dessa forma:</p>

<pre>
<code>
vector&lt;pair&lt;int, string&gt;&gt; prod; // Importe vector

prod.push_back(make_pair(10, "Mouse"));
prod.push_back(make_pair(20, "Teclado"));
prod.push_back(make_pair(30, "Monitor"));

for(int i = 0; i < prod.size(); i++) {
    cout << prod[i].first << " - " << prod[i].second << endl;
}
</code>
</pre>

<p>PS: Podemos usar o for it também:</p>

<pre>
<code>
for(auto i: prod) {
    cout << i.first << " - " << i.second << endl;
}
</code>
</pre>

<h3>Map - Container de Associação Chave x Valor</h3>

<p>O Map é um containers de associação de chave e valor, ele parece um pouco com o pair, mas ele associa o segundo elemento (valor) ao primeiro (chave).</p>

<p>Primeiro, inclua a biblioteca map, e coloque esse código:</p>

<pre>
<code>
map&lt;int, string&gt; prod; // Inclua map
</code>
</pre>

<p>No código acima, a chave é do tipo int, e o valor é string, o valor é associado à chave, mas eles podem ser de tipos diferentes, pode também receber structs, classes e etc., e podem ser usado com vector, como acontece com os pairs.</p>

<p>Para adicionar elementos, faça como se faz com um vetor:</p>

<pre>
<code>
map&lt;int, string&gt; prod; // Inclua map
    
prod[0] = "Mouse";
prod[1] = "Teclado";
prod[2] = "Monitor";
prod[3] = "Caixa";

for(int i = 0; i < 4; i++) {
    cout << prod[i] << endl;
}
</code>
</pre>

<p>O que está dentro dos colchetes é a chave (no caso, int, poderia ser outro tipo, definido no map), e o valor associado a ela é o que está após o símbolo de atribuição.</p>

<p>Podemos exibir também dessa forma:</p>

<pre>
<code>
map&lt;int, string&gt; prod; // Inclua map

prod[0] = "Mouse";
prod[1] = "Teclado";
prod[2] = "Monitor";
prod[3] = "Caixa";

for(auto it = prod.begin(); it != prod.end(); it++) {
    cout << it->first << " - " << it->second << endl;
}
</code>
</pre>

<p>Da forma acima, usando o first, imprime a chave, e o second imprime o valor, independente do tipo de ambos.</p>

<p>Pra simplificar, podemos usar o for it assim:</p>

<pre>
<code>
for(auto it: prod) {
    cout << it.first << " - " << it.second << endl;
}
</code>
</pre>

<p>Mas o certo é usar o insert, onde inserimos os pares decladados no map (na mesma ordem dos tipos pré-definidos, utilizando o pair:</p>

<pre>
<code>
map&lt;int, string&gt; prod; // Inclua map

prod.insert(pair&lt;int, string&gt;(0, "Mouse")); // Inclua utility
prod.insert(pair&lt;int, string&gt;(1, "Teclado"));
prod.insert(pair&lt;int, string&gt;(2, "Monitor"));
prod.insert(pair&lt;int, string&gt;(3, "Caixa"));

for(auto it: prod) {
    cout << it.first << " - " << it.second << endl;
}
</code>
</pre>

<p>Para apagar um índice, utilize o erase com o conteúdo da chave a ser apagada:</p>

<pre>
<code>
prod.erase(2);
</code>
</pre>

<p>PS: Lembrando que isso não é a posição do elemento, ele vai procurar o elemento com a chave 2, se eles forem enumerados com 10, 20, 30 e 40, ou for outro tipo na chave, como o char, ele não apagará a "posição 2" do map.</p>

<p>Para apagar todos os elementos do map, use o clear, assim:</p>

<pre>
<code>
prod.clear();
</code>
</pre>

<p>Temos também o find, que procura uma chave do map, e retorna o valor correspondente à esta:</p>

<pre>
<code>
map&lt;int, string&gt; prod; // Inclua map
map&lt;int, string&gt;::iterator itmap;

prod.insert(pair&lt;int, string&gt;(10, "Mouse")); // Inclua utility
prod.insert(pair&lt;int, string&gt;(20, "Teclado"));
prod.insert(pair&lt;int, string&gt;(30, "Monitor"));
prod.insert(pair&lt;int, string&gt;(40, "Caixa"));
prod.insert(pair&lt;int, string&gt;(50, "Microfone"));
prod.insert(pair&lt;int, string&gt;(60, "Gabinete"));
prod.insert(pair&lt;int, string&gt;(70, "Câmera"));

itmap = prod.find(30);

if(itmap == prod.end()) {
    cout << "Produto não Encontrado!" << endl;
}
else {
    cout << "Produto em Estoque: " << endl;
    cout << "Código: " << itmap->first << endl;
    cout << "Produto: " << itmap->second << endl;
    cout << "----------------------------------" << endl;
}
</code>
</pre>

<p>Agora tente passar uma chave que não existe nesse mesmo find.</p>

<p>Podemos também excluir uma quantidade específica de produtos, usando o erase, dessa forma:</p>

<pre>
<code>
prod.erase(prod.begin(), prod.find(30));
</code>
</pre>

<p>PS: Ele não excluí o conteúdo da chave passada, e sim até antes dele.</p>

<p>Da forma acima, ele excluí da primeira posição até antes da especificada, mas podemos escolher uma faixa específica assim:</p>

<pre>
<code>
prod.erase(prod.find(30), prod.find(60));
</code>
</pre>

<ul>
    <li><a href="tudo-sobre-cpp-14.html">Parte Anterior da Matéria!</a></li>
    <li><a href="tudo-sobre-cpp-16.html">Continuação da Matéria!</a></li>
</ul>
        </div>
    </body>
</html>