<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda C++</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda C++</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-cpp-1.html">Tudo sobre C++ Parte 1!</a></li>
                    <li><a href="tudo-sobre-cpp-2.html">Tudo sobre C++ Parte 2!</a></li>
                    <li><a href="tudo-sobre-cpp-3.html">Tudo sobre C++ Parte 3!</a></li>
                    <li><a href="tudo-sobre-cpp-4.html">Tudo sobre C++ Parte 4!</a></li>
                    <li><a href="tudo-sobre-cpp-5.html">Tudo sobre C++ Parte 5!</a></li>
                    <li><a href="tudo-sobre-cpp-6.html">Tudo sobre C++ Parte 6!</a></li>
                    <li><a href="tudo-sobre-cpp-7.html">Tudo sobre C++ Parte 7!</a></li>
                    <li><a href="tudo-sobre-cpp-8.html">Tudo sobre C++ Parte 8!</a></li>
                    <li><a href="tudo-sobre-cpp-9.html">Tudo sobre C++ Parte 9!</a></li>
                    <li><a href="tudo-sobre-cpp-10.html">Tudo sobre C++ Parte 10!</a></li>
                    <li><a href="tudo-sobre-cpp-11.html">Tudo sobre C++ Parte 11!</a></li>
                    <li><a href="tudo-sobre-cpp-12.html">Tudo sobre C++ Parte 12!</a></li>
                    <li><a href="tudo-sobre-cpp-13.html">Tudo sobre C++ Parte 13!</a></li>
                    <li><a href="tudo-sobre-cpp-14.html" onclick="alert('Você já Está na Matéria desse Link!'); return false">Tudo sobre C++ Parte 14!</a></li>
                    <li><a href="tudo-sobre-cpp-15.html">Tudo sobre C++ Parte 15!</a></li>
                    <li><a href="tudo-sobre-cpp-16.html">Tudo sobre C++ Parte 16!</a></li>
                </menu>
            </header>
            
<h2>Tudo sobre C++ Parte 14</h2>

<h3>Inicialização Uniforme em C++11</h3>

<p>Primeiro, vamos no compilador do Codeblocks (em Settings e Compiler) e escolha a opção de especicação 11 (o padrão é 98). A versão 11 tem tudo das anteriores, então dá para compilar normalmente versões antigas. Caso não apareça a opção, clique na opção Do C++ ISO 1998 e vá em "Modify Flag", e altere "-std=c++98" para "-std=c++11"</p>

<p>A inicialização uniforme é uma técnica que consiste em facilitar em padronizar as inicializações dentro do C++, seja de uma variável, struct, classe, etc.</p>

<p>Veja o método antigo abaixo:</p>

<pre>
<code>
int main() {
    int num = 10;

    return 0;
}
</code>
</pre>

<p>E no método moderno, faremos assim:</p>

<pre>
<code>
int main() {
    int num{10};

    return 0;
}
</code>
</pre>

<p>Isso também é possível também em outros elementos, dessa forma:</p>

<pre>
<code>
int main() {
    int num{10};
    string nome{"Texto"};
    vector&lt;int&gt; valores{1, 2, 3, 4, 5}; // Incluir vector
    map&lt;string, string&gt; capitais{{"MG", "Belo Horizonte"}}; // Incluir map

    return 0;
}
</code>
</pre>

<p>PS: O map recebe dois elementos, no caso acima, duas strings</p>

<p>E também podemos inicializar structs assim, sempre na mesma ordem dos atributos:</p>

<pre>
<code>
struct pessoa {
    string nome;
    int idade;
};

int main() {
    pessoa p1{"Bruno", 38}; // Sempre na ordem dos elementos do struct
    pessoa p2{"Nome", 100};

    return 0;
}
</code>
</pre>

<p>E com classes, nem precisamos criar construtores, podemos fazer da mesma forma do struct, nesse caso, e sem precisar indicar ponteiros, dessa forma:</p>

<pre>
<code>
class Veiculo {
    public:
        int tipo;
        string nome;
};

int main() {
    Veiculo v1{1, "Fusca"}; // Sempre na ordem dos atributos da classe
    Veiculo v2{2, "Uno"};

    return 0;
}
</code>
</pre>

<p>Para exibir, fazemos assim:</p>

<pre>
<code>
int main() {
    int num{10};
    string nome{"Texto"};
    vector&lt;int&gt; valores{1, 2, 3, 4, 5}; // Incluir vector
    map&lt;string, string&gt; capitais{{"MG", "Belo Horizonte"}}; // Incluir map
    pessoa p1{"Bruno", 38}; // Sempre na ordem dos elementos do struct
    pessoa p2{"Nome", 100};
    Veiculo v1{1, "Fusca"}; // Sempre na ordem dos atributos da classe
    Veiculo v2{2, "Uno"};

    cout << nome << endl;

    cout << endl;

    for(vector&lt;int&gt;::iterator it = valores.begin(); it != valores.end(); it++) { // Iterator
        cout << *it << endl;
    }

    cout << endl;

    for(map&lt;string, string&gt;::iterator it = capitais.begin(); it != capitais.end(); it++) { // Iterator
        cout << it->first << " - " << it->second << endl;
    }

    cout << endl;

    cout << p1.nome << " - " << p1.idade << endl;
    
    cout << endl;

    cout << v1.tipo << " - " << v1.nome << endl; // Classes em C++ modero usam ponto
    
    cout << endl;

    return 0;
}
</code>
</pre>

<p>Os vetores também podem ser inicializados de forma parecida com essa:</p>

<pre>
<code>
int vetor[]{1, 2, 3, 4, 5, 6, 7, 8, 9};
</code>
</pre>

<h3>Classes de Armazenamento em C++11 - auto, register, static</h3>

<p>O auto, basicamente, é usado para declarar uma variável de qualquer tipo, mas isso não quer dizer que a variável se torna dinâmica, e sim que o tipo dela vai ser definido automaticamente na inicialização da mesma, por exemplo:</p>

<pre>
<code>
auto num = 10; // Essa variável sempre será int.
auto texto = "Palavra"; // Essa variável sempre será const char*.
</code>
</pre>

<p>Por esse motivo acima, toda variável auto tem que ser inicializada, e não pode ser atribuída depois.</p>

<p>Como também podemos colocar variáveis para receber valores retornados de funções, dessa forma:</p>

<pre>
<code>
int soma(int n1, int n2) {
    return n1 + n2;
}

string canal() {
    return "Nome do Canal";
}

int main() {
    auto res = soma(10, 5);
    auto nome = canal();

    cout << res << endl;
    cout << nome << endl;

    return 0;
}
</code>
</pre>

<p>Também podemos colocar uma função do tipo auto, mas tem que indicar o tipo de retorno, dessa forma:</p>

<pre>
<code>
auto soma(double n1, double n2)->int {
    return n1 + n2;
}
</code>
</pre>

<p>PS: O próprio método main pode ser escrito dessa forma em C++ moderno.</p>

<p>Nesse caso acima, caso exista uma variável que receba esse retorno, ela deverá estar como auto também.</p>

<p>Como sabemos, um vector faríamos a declaração e exibição assim:</p>

<pre>
<code>
int main() {
    vector&lt;int&gt; v{10, 20, 30, 40, 50, 60, 70}; // Incluir vector

    for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
        cout << *it << endl;
    }

    return 0;
}
</code>
</pre>

<p>Mas o mesmo laço for pode ser feito dessa forma:</p>

<pre>
<code>
for(auto it = v.begin(); it != v.end(); it++) {
    cout << *it << endl;
}
</code>
</pre>

<p>Isso acima pode ser feito com map, list e outros elementos.</p>

<p>Quando declaramos uma variável com a palavra register, estamos pedindo para que o programa armazene a variável em um registrador no processador, e não na memória RAM (é um pedido ao sistema, se não for possível armazenar no registrador ele armazena na RAM mesmo, na maioria das vezes). Isso é usado em variáveis que precisamos acessar muito rapidamente, como um iterator ou qualquer elemento contador de um laço de repetição, por exemplo:</p>

<pre>
<code>
for(register int cont = 0; cont <= 10; cont++) { 
    cout << cont << endl;
}
</code>
</pre>

<p>O static é um modificador de acesso.</p>

<p>Veja um exemplo de uso de função normal:</p>

<pre>
<code>
void somador() {
    int i = 0;
    i++;
    cout << i << endl;
}

int main() {
    somador();
    somador();
    somador();
    somador();
    somador();
    somador();
    somador();

    return 0;
}
</code>
</pre>

<p>No modo acima, em toda chamada de função ele criará uma nova declaração da variável local da mesma, que sempre voltará ao 0 e incrementará para 1.</p>

<p>Agora veja a atribuição da variável com static</p>

<pre>
<code>
void somador() {
    static int i = 0;
    i++;
    cout << i << endl;
}

int main() {
    somador();
    somador();
    somador();
    somador();
    somador();
    somador();
    somador();

    return 0;
}
</code>
</pre>

<p>Quando a variável é utilizada com static, ela sempre estará no mesmo endereço de memória, e como já estará criada, a mesma continuará a ser incrementada cada vez que a função for chamada, indo por 1, 2, 3, 4 e assim por diante. Não criará outra inicialização. O static também pode ser usado em funções, de forma que ele só pode ser usado no mesmo arquivo de código-fonte.</p>

<h3>Classes de Armazenamento Extern em C++11</h3>

<p>Primeiramente, crie um novo arquivo cpp com o nome auxiliar, no projeto.</p>

<p>No main, declare uma variável assim:</p>

<pre>
<code>
int num{10};

int main() {

    return 0;
}
</code>
</pre>

<p>No auxiliar, coloque isso (não esqueça de incluir o iostream e colocar o namespace std):</p>

<pre>
<code>
int num;

void impNum() {
    cout << num << endl;
}
</code>
</pre>

<p>E no main, faça as alterações assim:</p>

<pre>
<code>
void impNum();

int num{10};

int main() {
    impNum();

    return 0;
}
</code>
</pre>

<p>O código acima não compilará, por ter mais de uma declaração pra mesma variável, por isso no auxiliar devemos indicar que essa variável é externa, dessa forma:</p>

<pre>
<code>
extern int num;

void impNum() {
    cout << num << endl;
}
</code>
</pre>

<p>No caso acima, o num do extern não é uma declaração, e sim o acesso, a declaração é no main.</p>

<p>PS: Evite inicializar variáveis com extern, inicialize ela no local onde ela está definida, no caso acima, no main.</p>

<p>Dessa forma, não precisamos colocar um arquivo no cabeçalho do outro.</p>

<p>Tente colocar uma variável assim no auxiliar:</p>

<pre>
<code>
extern int num;

int valor{50};

void impNum() {
    cout << num << endl;
}
</code>
</pre>

<p>E no main, coloque assim:</p>

<pre>
<code>
void impNum();

int num{10};
extern int valor;

int main() {
    impNum();
    cout << valor << endl;

    return 0;
}
</code>
</pre>

<p>Ou seja, a variável pode ser declarada em qualquer arquivo e o extern pode ser usado em qualquer arquivo.</p>

<p>Agora sim criaremos um arquivo de cabeçalho h (que deverá ser incluído) com o nome variaveis e coloque uma variável int com qualquer número, e no main, coloque esse código:</p>

<pre>
<code>
int main() {
    impNum();
    cout << valor << endl;
    cout << numero << endl; // Isso vem da inclusão do arquivo h

    return 0;
}
</code>
</pre>

<p>PS: Podemos também fazer isso com os métodos, no caso, onde utilizarmos o extern, colocamos o método e os parâmetros como uma declaração.</p>

<h3>For com Base em Intervalo e For-range declaration em C++11</h3>

<p>Podemos simplificar o for nos casos de aplicações que podem ser iterados.</p>

<p>Normalmente, usaríamos um laço for para ler um vetor assim:</p>

<pre>
<code>
int main() {
    int x[10]{10, 20, 30, 40, 50, 60, 70, 80, 90, 100};

    for(int i = 0; i < 10; i++) {
        cout << x[i] << endl;
    }

    return 0;
}
</code>
</pre>

<p>Ou mesmo assim:</p>

<pre>
<code>
int main() {
    int x[10]{10, 20, 30, 40, 50, 60, 70, 80, 90, 100};

    for(int i = 0; i < sizeof(x) / sizeof(int); i++) {
        cout << x[i] << endl;
    }

    return 0;
}
</code>
</pre>

<p>Mas elementos que podem ser iterados (coleções, como vetores e vector e list), podem ser declarados assim:</p>

<pre>
<code>
int main() {
    int x[10]{10, 20, 30, 40, 50, 60, 70, 80, 90, 100};

    for(int i: x) {
        cout << i << endl; // Só coloca a variável do for
    }

    return 0;
}
</code>
</pre>

<p>PS: No caso acima, que é chamado de for range declaration ou for it, ele deverá ter a variável do mesmo tipo da coleção a ser exibida.</p>

<p>Ou utilize auto também, dessa forma:</p>

<pre>
<code>
int main() {
    vector&lt;int&gt; n{10, 20, 30, 40, 50, 60, 70, 80, 90, 100}; // Importe vector

    for(auto i: n) {
        cout << i << endl;
    }

    return 0;
}
</code>
</pre>

<ul>
    <li><a href="tudo-sobre-cpp-13.html">Parte Anterior da Matéria!</a></li>
    <li><a href="tudo-sobre-cpp-15.html">Continuação da Matéria!</a></li>
</ul>
        </div>
    </body>
</html>