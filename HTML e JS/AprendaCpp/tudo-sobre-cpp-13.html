<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda C++</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda C++</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-cpp-1.html">Tudo sobre C++ Parte 1!</a></li>
                    <li><a href="tudo-sobre-cpp-2.html">Tudo sobre C++ Parte 2!</a></li>
                    <li><a href="tudo-sobre-cpp-3.html">Tudo sobre C++ Parte 3!</a></li>
                    <li><a href="tudo-sobre-cpp-4.html">Tudo sobre C++ Parte 4!</a></li>
                    <li><a href="tudo-sobre-cpp-5.html">Tudo sobre C++ Parte 5!</a></li>
                    <li><a href="tudo-sobre-cpp-6.html">Tudo sobre C++ Parte 6!</a></li>
                    <li><a href="tudo-sobre-cpp-7.html">Tudo sobre C++ Parte 7!</a></li>
                    <li><a href="tudo-sobre-cpp-8.html">Tudo sobre C++ Parte 8!</a></li>
                    <li><a href="tudo-sobre-cpp-9.html">Tudo sobre C++ Parte 9!</a></li>
                    <li><a href="tudo-sobre-cpp-10.html">Tudo sobre C++ Parte 10!</a></li>
                    <li><a href="tudo-sobre-cpp-11.html">Tudo sobre C++ Parte 11!</a></li>
                    <li><a href="tudo-sobre-cpp-12.html">Tudo sobre C++ Parte 12!</a></li>
                    <li><a href="tudo-sobre-cpp-13.html" onclick="alert('Você já Está na Matéria desse Link!'); return false">Tudo sobre C++ Parte 13!</a></li>
                    <li><a href="tudo-sobre-cpp-14.html">Tudo sobre C++ Parte 14!</a></li>
                    <li><a href="tudo-sobre-cpp-15.html">Tudo sobre C++ Parte 15!</a></li>
                    <li><a href="tudo-sobre-cpp-16.html">Tudo sobre C++ Parte 16!</a></li>
                </menu>
            </header>
            
<h2>Tudo sobre C++ Parte 13</h2>

<h3>Aritmética de Ponteiros</h3>

<p>Há duas operações aritméticas que podemos efetuar com ponteiros: adição de ponteiros e subtração de ponteiros. Além disso, também é possível comparar dois ponteiros entre si.</p>

<p>O tamanho de uma variável é um aspecto muito importante para o programador. Precisamos saber quanto espaço na memória uma variável ocupa quando é utilizada, para que seja possível escrever programas enxutos e que executem com boa performance. Isso é particularmente importante quando desenvolvemos programas para dispositivos embarcados, os quais, no geral, contam com quantidade restrita de memória disponível.</p>

<p>Dependendo da plataforma, uma variável pode ter tamanhos que variam de 8 a 64 bits. Por exemplo, em uma plataforma de 32 bits, uma variável do tipo int ocupará o espaço de 4 bytes (32 / 8 = 4).</p>

<p>O código a seguir nos permite verificar o tamanho na memória utilizado por ponteiros de diferentes tipos, usando o operador sizeof:</p>

<pre>
<code>
int main() {
    int inteiro;
    char caractere;
    double duplo;

    int *iPtr;
    char *cPtr;
    double *dPtr;

    iPtr = &inteiro;
    cPtr = &caractere;
    dPtr = &duplo;

    cout << "Tamanho de um ponteiro de inteiro = " << sizeof(iPtr) << ", valor = " << iPtr << endl;
    cout << "Tamanho de um ponteiro de char = " << sizeof(cPtr) << ", valor = " << cPtr << endl;
    cout << "Tamanho de um ponteiro de double = " << sizeof(dPtr) << ", valor = " << dPtr << endl;
    
}
</code>
</pre>

<p>Não podemos efetuar outras operações com ponteiros além da adição e subtração, com multiplicação e divisão, e nem podemos usar operadores de deslocamento bit a bit.</p>

<p>Vejamos um código de exemplo que mostra as operações de adição e subtração de ponteiros:</p>

<pre>
<code>
int main() {
    int a;
    a = 30;
    int *pont1;

    pont1 = &a;
    cout << "Endereço de a: " << pont1 << endl;

    pont1++;
    cout << "Endereço do ponteiro incrementado: " << pont1 << endl;

    pont1 = pont1 + 10;
    cout << "Somando 40 ao ponteiro pont1: " << pont1 << endl;

    pont1--;
    cout << "Decrementando o ponteiro: " << pont1 << endl;
}
</code>
</pre>

<p>Podemos efetuar a comparação de ponteiros usando os operadores de comparação padrão – apesar de esta técnica não ter tanta utilidade na prática. O código a seguir mostra a comparação entre ponteiros:</p>

<pre>
<code>
int main() {
    int vetor[3] = {10, 30, 20};
    int *p0 = vetor;
    int *p1 = vetor + 1;
    int *p2 = vetor + 2;
    int *p3 = p2;

    cout << "p2 > p0: " << (p2 > p0) << endl;
    cout << "p0 > p1: " << (p0 > p1) << endl;
    cout << "p2 < p0: " << (p2 < p0) << endl;
    cout << "p3 == p2: " << (p3 == p2) << endl;
}
</code>
</pre>

<p>Outro exemplo, mais complexo:</p>

<pre>
<code>
int pares[5] = {0, 2, 4, 6, 8};
int *ponteiro;

ponteiro = pares; // O mesmo que &pares[0]

cout << "Endereço do vetor: " << pares << endl;

for(int i = 0; i < sizeof(pares) / sizeof(int); i++) {
    cout << "Conteúdo do " << (i + 1) << "º índice do vetor: " << pares[i] << endl;
}

for(int i = 0; i < sizeof(pares) / sizeof(int); i++) {
    cout << "Endereço do " << (i + 1) << "º índice do vetor: " << &pares[i] << endl;
}

for(int i = 0; i < sizeof(pares) / sizeof(int); i++) {
    cout << "Endereço apontado pelo " << (i + 1) << "º incremento do ponteiro: " << ponteiro++ << endl;
}

for(int i = 0; i < sizeof(pares) / sizeof(int); i++) {
    ponteiro = &pares[i];

    cout << "Conteúdo apontado pelo " << (i + 1) << "º incremento do ponteiro: " << *ponteiro << endl;
}
</code>
</pre>

<h3>Uso de Funções com Ponteiros</h3>

<p>Uma função pode retornar um número inteiro, um real e um caractere, assim como também pode retornar um vetor. Para isso, devemos utilizar ponteiros (ou apontador). A única forma de retornar um vetor é por meio de um ponteiro, pois não é possível criar funções como por exemplo, <code>int[10] calcular()</code>, onde int[10] quer dizer que a função retorna um vetor com 10 posições.</p>

<p>A seguir veja um exemplo de uso desse recurso através de uma função, que cria um vetor de dez posições e os preenche com valores aleatórios, imprime os valores, e posteriormente passa esse vetor para <q>quem</q> chamar a função:</p>

<pre>
<code>
int *gerarRandomico();

int main() {
    int *p;
    int i;

    p = gerarRandomico();

    for(i = 0; i < 10; i++) {
        cout << "p[" << i << "] = " << p[i] << "." << endl;
    }

    return 0;
}

int *gerarRandomico() {
    static int r[10];
    int a;

    for(a = 0; a < 10; a++) {
        r[a] = rand() % 100;

        cout << "r[" << a << "] = " << r[a] << "." << endl;
    }

    return r;
}
</code>
</pre>

<p>PS: Ao passar um ponteiro por um parâmetro, siga essas regras:</p>

<pre>
<code>
void procedimento(int *param);
void procedimento(int param);

int main() {
    int n = 10;
    int *p;
    p = &amp;n;
    
    procedimento(p); // Caso a função/procedimento tenha * e a variável de entrada seja ponteiro
    procedimento(*p); // Caso a função/procedimento não tenha * e a variável de entrada seja ponteiro
    procedimento(&amp;n); // Caso a função/procedimento tenha * e a variável de entrada não seja ponteiro
    procedimento(n); // Casos mais comuns, onde nem a função/procedimento e nem a variável são ponteiros
    
    return 0;
}

void procedimento(int *param) {
    cout << "Endereço de 1: " << param << endl;
    cout << "Conteúdo de 1: " << *param << endl;
}

void procedimento(int param) {
    cout << "Endereço de 2: " << &amp;param << endl;
    cout << "Conteúdo de 2: " << param << endl;
}
</code>
</pre>

<h3>Números Randomicos em C++</h3>

<p>Basicamente, no C, faríamos assim para gerar números randomicos no nosso programa:</p>

<pre>
<code>
srand(time(NULL)); // Importe stdlib.h pro rand/srand e time.h pro time
printf("%d\n", 12 + (rand() % (14 - 12) + 1));
</code>
</pre>

<p>Mas como no C++ temos a orientação a objetos, podemos criar uma classe para trabalharmos mais facilmente com isso.</p>

<p>Crie a classe random assim (inclua cstdlib e ctime):</p>

<pre>
<code>
class Random {
    public:
        int nextInt(int mini, int maxi);

        Random();
    private:
        int rd;
};

int Random::nextInt(int mini, int maxi) {
    this->rd = mini + (rand() % (maxi - (mini - 1)));

    return this->rd;
}

Random::Random() {
    srand(time(NULL));
}
</code>
</pre>

<p>E no programa principal podemos fazer assim (inclua o arquivo Random.h):</p>

<pre>
<code>
Random ale;

cout << ale.nextInt(15, 20) << endl; // Gera de 15 a 20
cout << ale.nextInt(1, 5) << endl; // Gera de 1 a 5
</code>
</pre>

<h3>Criar Arquivos de Cabeçalho em C++</h3>

<p>Quando trabalhamos com projetos grandes, costumamos criar muitas funções para fazer inúmeras tarefas, para isso podemos criar nosso próprios arquivos de cabeçalho.</p>

<p>No projeto em C++, vá em File e selecione o arquivo header (H) e salve na pasta do projeto atual. O header no exemplo terá o nome calculos.h. E coloque esse código:</p>

<pre>
<code>
#ifndef CALCULOS_H_INCLUDED
#define CALCULOS_H_INCLUDED

#define _PI 3.14159
int quadrado(int x);
int cubo(int x);

#endif // CALCULOS_H_INCLUDED
</code>
</pre>

<p>Agora criaremos um novo File da mesma forma, mas um C++ source com o nome calculos.cpp, nele será escrito esses códigos:</p>

<pre>
<code>
#include "calculos.h"

int quadrado(int x) {
    return x * x;
}

int cubo(int x) {
    return x * x * x;
}
</code>
</pre>

<p>E no main.cpp, colocamos o calculos.h incluído entre aspas, por estar na mesma pasta, dessa forma, veja o código completo abaixo:</p>

<pre>
<code>
#include &lt;iostream&gt;
#include "calculos.h"

using namespace std;

int main() {
    cout << "Usando headers: " << endl;
    int y = 5;
    int quadr = quadrado(y);
    int cub = cubo(y);

    cout << "Quadrado de " << y << ": " << quadr << endl;
    cout << "Cubo de " << y << ": " << cub << endl;
    cout << "Valor da constante PI : " << _PI << endl;

    return 0;
}
</code>
</pre>

<p>PS: Em todos os arquivos, adicione o Debug e o Release.</p>

<p>Ao incluir o include com aspas (tipo <code>#include "funcoes.h"</code>), como feito com os arquivos de cabeçalho, o compilador apenas procurará na mesma pasta onde está o código-fonte a ser compilado. Quando são usadas tags (como <code>#include &lt;iostream&gt;</code>) ele procurará na pasta padrão do compilador (no caso do Linux, poderia ser em <code>/usr/include/c++</code>, por exemplo).</p>

<h3>Criar Makefile em Linux</h3>

<p>Basicamente, podemos pegar os códigos-fontes anteriores e colocá-los numa mesma pasta. Nessa pasta crie também um arquivo com o nome makefile, sem extensão, e coloque esse código:</p>

<pre>
<code>
contas: main.o calculos.o
    g++ main.o calculos.o -o contas -no-pie

main.o: main.cpp calculos.h
    g++ -c main.cpp -o main.o

calculos.o: calculos.cpp calculos.h
    g++ -c calculos.cpp -o calculos.o

clean:
    rm -f *.o
</code>
</pre>

<p>No caso ele executará de baixo pra cima, e não esqueça da tabulação. Para compilar basta digitar no terminal <code>make</code> e executar o arquivo digitando <code>./contas</code>.</p>

<h3>Usando Funções em Strings</h3>

<p>Basicamente, usamos isso para substituir um caractere no C++:</p>

<pre>
<code>
string entrada = "Apenas uma frase!";

replace(entrada.begin(), entrada.end(), ' ',  '_'); // Inclua algorithm

cout << entrada << endl;
</code>
</pre>

<p>PS: Podemos fazer uma função para mudar mais de um caractere.</p>

<p>A substituição de palavras inteirass pode ser feita assim:</p>

<pre>
<code>
string entrada = "Apenas uma frase!";

entrada.replace(entrada.find("frase"), 5, "string"); // Na ordem palavra a ser substituída, quantidade de caracteres da mesma e palavra substituta
    
cout << entrada << endl;
</code>
</pre>

<p>No entanto ele só substitui uma vez. Para substituir todas as ocorrências, podemos criar uma função para isso, por exemplo:</p>

<pre>
<code>
string substituir(string texto, string antigo, string novo);

int main() {
    string entrada = "Apenas uma frase! A frase foi repetida!";

    entrada = substituir(entrada, "frase", "string"); // Na ordem palavra a ser substituída, palavra a substituir e palavra substituta
    
    cout << entrada << endl;

    return 0;
}

string substituir(string texto, string antigo, string novo) {
    size_t pos;
        
    while((pos = texto.find(antigo)) != string::npos) {
        texto.replace(texto.find(antigo), antigo.length(), novo); // Na ordem palavra a ser substituída, quantidade de caracteres da mesma e palavra substituta
    }
    
    return texto;
}
</code>
</pre>

<p>O método find também pode ser usado para encontrar uma palavra numa string:</p>

<pre>
<code>
string entrada = "Apenas uma frase!";

size_t posicao = entrada.find("frase");

if(posicao != string::npos) {
    cout << "Palavra encontrada." << endl;
}
else {
    cout << "Palavra não encontrada." << endl;
}
</code>
</pre>

<p>Para transformar tudo em maiúscula, podemos fazer assim:</p>

<pre>
<code>
string entrada = "Apenas uma frase!";

transform(entrada.begin(), entrada.end(), entrada.begin(), ::toupper); // Inclua algorithm e cctype

cout << entrada << endl;
</code>
</pre>

<p>Da mesma forma, usamos o <code>tolower</code> para transformar tudo em minúscula.</p>

<p>Para reverter uma frase:</p>

<pre>
<code>
string entrada = "Apenas uma frase!";
    
reverse(entrada.begin(), entrada.end()); // Inclua algorithm
    
cout << entrada << endl;
</code>
</pre>

<p>Para concatenar uma string:</p>

<pre>
<code>
string entrada = "Apenas uma frase!";
    
entrada.append(" E ela foi concatenada!");
    
cout << entrada << endl;
</code>
</pre>

<p>Para dividir uma string:</p>

<pre>
<code>
string entrada = "Exemplo de Frase";
regex reg(" "); // Inclua regex, aqui vai o caractere para dividir

vector&lt;string&gt; saida(sregex_token_iterator(entrada.begin(), entrada.end(), reg, -1), sregex_token_iterator()); // Inclua cstring e vector

for(string s: saida) {
    cout << s << endl;
}
</code>
</pre>

<p>Para jogar uma string num array de char:</p>

<pre>
<code>
string entrada = "Apenas uma frase!";
const char* novo = entrada.c_str();
    
cout << novo << endl;
</code>
</pre>

<p>PS: Para fazer o contrário, que é converter um const char* para string, basta fazer um typecast com string.</p>

<p>Você pode converter int em string usando o método <code>to_string()</code> (inclua cstring), assim:</p>

<pre>
<code>
int num = 50;

string tex = to_string(num); // Inclua cstring

cout << tex << endl;
</code>
</pre>

<p>Pra converter string pra int, usamos o <code>stoi()</code>, da mesma forma:</p>

<pre>
<code>
string tex = "50";

int num = stoi(tex); // Inclua cstdlib

cout << num << endl;
</code>
</pre>

<ul>
    <li><a href="tudo-sobre-cpp-12.html">Parte Anterior da Matéria!</a></li>
    <li><a href="tudo-sobre-cpp-14.html">Continuação da Matéria!</a></li>
</ul>
        </div>
    </body>
</html>