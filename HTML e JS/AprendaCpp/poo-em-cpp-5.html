<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="_imagens/favicon.ico"/>
        <title>Aprenda C++</title>
        <link rel="stylesheet" href="_css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda C++</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-cpp-1.html">Tudo sobre C++ Parte 1!</a></li>
                    <li><a href="tudo-sobre-cpp-2.html">Tudo sobre C++ Parte 2!</a></li>
                    <li><a href="tudo-sobre-cpp-3.html">Tudo sobre C++ Parte 3!</a></li>
                    <li><a href="tudo-sobre-cpp-4.html">Tudo sobre C++ Parte 4!</a></li>
                    <li><a href="tudo-sobre-cpp-5.html">Tudo sobre C++ Parte 5!</a></li>
                    <li><a href="tudo-sobre-cpp-6.html">Tudo sobre C++ Parte 6!</a></li>
                    <li><a href="tudo-sobre-cpp-7.html">Tudo sobre C++ Parte 7!</a></li>
                    <li><a href="tudo-sobre-cpp-8.html">Tudo sobre C++ Parte 8!</a></li>
                    <li><a href="tudo-sobre-cpp-9.html">Tudo sobre C++ Parte 9!</a></li>
                    <li><a href="tudo-sobre-cpp-10.html">Tudo sobre C++ Parte 10!</a></li>
                    <li><a href="tudo-sobre-cpp-11.html">Tudo sobre C++ Parte 11!</a></li>
                    <li><a href="tudo-sobre-cpp-12.html">Tudo sobre C++ Parte 12!</a></li>
                    <li><a href="tudo-sobre-cpp-13.html">Tudo sobre C++ Parte 13!</a></li>
                    <li><a href="tudo-sobre-cpp-14.html">Tudo sobre C++ Parte 14!</a></li>
                    <li><a href="tudo-sobre-cpp-15.html">Tudo sobre C++ Parte 15!</a></li>
                    <li><a href="tudo-sobre-cpp-16.html">Tudo sobre C++ Parte 16!</a></li>
                </menu>
            </header>

<h2>Orientação a Objetos em C++ - Parte 5</h2> 

<h3>Herança, Virtual, Override</h3>

<p>Como sabemos, a herança é quando uma classe herda todas as características de outra classe. As classes herdeiras podem, além de herdar as características da classe pai, pode ter atributos e métodos próprios, além de sobreposição de alguns métodos.</p>

<p>Crie a classe Veiculo novamente com esse código:</p>

<pre>
<code>
class Veiculo {
    public:
        int velMax;
        int rodas;

        void imp();
        
        const char* getNome();
        void setNome(const char* nome);
        const char* getCor();
        void setCor(const char* cor);
    private:
        const char* nome;
        const char* cor;
};
</code>
</pre>

<p>Implementação dos métodos, incluindo os getters e setters:</p>

<pre>
<code>
void Veiculo::imp() {
    std::cout << "Nome...: " << this->nome << std::endl;
    std::cout << "Cor....: " << this->cor << std::endl;
    std::cout << "Rodas..: " << this->rodas << std::endl;
    std::cout << "Vel Máx: " << this->velMax << std::endl << std::endl;
}

const char* Veiculo::getNome() {
    return this->nome;
}

void Veiculo::setNome(const char* nome) {
    this->nome = nome;
}

const char* Veiculo::getCor() {
    return this->cor;
}

void Veiculo::setCor(const char* cor) {
    this->cor = cor;
}
</code>
</pre>

<p>Como visto acima, nada de novo, o método imprimir está dentro da classe e pode acessar atributos privados.</p>

<p>Agora crie a classe Carro, herdando de Veiculo:</p>

<pre>
<code>
class Carro : public Veiculo {
    public:
        Carro();
};
</code>
</pre>

<p>Implementação do construtor:</p>

<pre>
<code>
Carro::Carro() {
    this->velMax = 160;
    this->rodas = 4;
    this->setNome("Carro");
    this->setCor("Branco");
}
</code>
</pre>

<p>Note que as propriedades chamadas não são da classe Carro, e sim da classe que ela herdou, a Veiculo.</p>

<p>Da mesma forma, podemos fazer igual em outras classes, como a Moto, que também herda de veículo:</p>

<pre>
<code>
class Moto : public Veiculo {
    public:
        Moto();
};
</code>
</pre>

<p>Implementação do construtor:</p>

<pre>
<code>
Moto::Moto() {
    this->velMax = 200;
    this->rodas = 2;
    this->setNome("Moto");
    this->setCor("Preta");
}
</code>
</pre>

<p>E da mesma forma, a classe Militar, que ganhará algumas propriedades novas:</p>

<pre>
<code>
class Militar : public Veiculo {
    public:
        int municao;
        bool armamento;
        Militar(bool arma, int municao);
};
</code>
</pre>

<p>Implementação do construtor:</p>

<pre>
<code>
Militar::Militar(bool arma, int municao) {
    this->velMax = 150;
    this->rodas = 6;

    this->armamento = arma;
    this->setNome("Tanque");
    this->setCor("Verde");

    if(arma) {
        this->municao = municao;
    }
    else {
        this->municao = 0;
    }
}
</code>
</pre>

<p>Só que o método imp() não exibirá a munição e o armamento do Militar, para isso, voltamos em veículo e colocaremos o imp() na declaração como virtual, que permitirá sobreescrever o método em outras classes:</p>

<pre>
<code>
class Veiculo {
    public:
        int velMax;
        int rodas;

        virtual void imp(); // Todo método que pode ser sobreposto deve ter o virtual na frente.
        
        const char* getNome();
        void setNome(const char* nome);
        const char* getCor;
        void setCor(const char* cor);
    private:
        const char* nome;
        const char* cor;
};
</code>
</pre>

<p>E na classe Militar, colocamos a palavra override no método imp (existente no C++11), que indica que ele está sobrepondo:</p>

<pre>
<code>
class Militar : public Veiculo {
    public:
        int municao;
        bool armamento;
        Militar(bool arma, int municao);

        void imp() override;
};
</code>
</pre>

<p>Dessa forma, a implementação do método imp sobreposto em Militar fica assim:</p>

<pre>
<code>
void Militar::imp() {
    std::cout << "Nome.......: " << this->getNome() << std::endl; // Use o getter devido ao encapsulamento
    std::cout << "Cor........: " << this->getCor() << std::endl;
    std::cout << "Rodas......: " << this->rodas << std::endl;
    std::cout << "Vel Máx....: " << this->velMax << std::endl;
    std::cout << "Armamento..: " << this->armamento << std::endl;
    std::cout << "Municao....: " << this->municao << std::endl << std::endl;
}
</code>
</pre>

<p>PS: Pode ser assim também, chamando o método da classe pai junto com o método sobreposto:</p>

<pre>
<code>
void Militar::imp() {
    Veiculo::imp(); // Chamada do método da classe pai

    std::cout << "Armamento..: " << this->armamento << std::endl;
    std::cout << "Municao....: " << this->municao << std::endl << std::endl;
}
</code>
</pre>

<p>Em outras palavras, o virtual num método de uma classe pai indica que esse método será sobreposto em alguma classe herdeira. E a classe que sobreescrever o método deverá indicar com override.</p>

<p>Um método sem o virtual não pode ser sobreposto, de forma que não precisa colocar final num método que não queiramos que seja substituído, apenas deixe ele sem nada (mas pode ser colocado na indicação algo como <code>void nomeDoMetodo() final</code>), para tornar a classe também final, use algo tipo <code>class NomeDaClasse final</code>, o final só pode ser usado em C++11. Todo método que poderá sobreposto deverá ter virtual indicando isso. Em atributos, coloque <code>const</code> na indicação da variável e inicialize dentro da classe mesmo.</p>

<p>No código principal faça isso:</p>

<pre>
<code>
Carro *c = new Carro();

c->imp();

Moto *m = new Moto();

m->imp();

Militar *t = new Militar(true, 500);

t->imp();

delete c;
delete m;
delete t;
</code>
</pre>

<p>Lembrando que podemos colocar a tipagem como uma classe (geralmente abstrata), mas a declaração do objeto com new deve ser de uma classe não-abstrata que implemente ou herde os métodos dela, por exemplo:</p>

<pre>
<code>
Veiculo *c = new Carro();

c->imp();

Veiculo *m = new Moto();

m->imp();

Veiculo *t = new Militar(true, 500);

t->imp();

delete c;
delete m;
delete t;
</code>
</pre>

<p>Isso é útil para ganharmos em polimorfismo, onde podemos usar vários tipos de objetos em, por exemplo, parâmetros, desde que eles tenham a mesma classe pai em comum. Isso é o polimorfismo de inclusão.</p>

<h3>Classe Abstrata Simulando Interface</h3>

<p>Caso deseje simular uma interface, crie uma classe apenas com os nomes dos métodos, colocando eles virtuais, sem colocar as implementações deles, apenas atribuindo com 0 (classe abstrata):</p>

<pre>
<code>
class Estoque {
    public:
        virtual void defineLado(int l) = 0;
        virtual double volume() = 0;
        virtual ~Estoque() = 0; // Toda classe abstrata deve ter um método destrutor virtual puro, mesmo que os outros métodos não os sejam
};

Estoque::~Estoque() { // Implementação Vazia, sempre necessária, no caso.

}
</code>
</pre>

<p>Um método virtual atribuído a 0 é como se ele fosse abstrato, ou seja, não terá implementação na interface, isso é uma função virtual pura, e toda classe que herdará, deverá implementar, sobreescrevendo ele.</p>

<p>Uma classe pode ter vários métodos implementados e ter uma ou mais funções virtuais puras. O método destrutor (sempre obrigatório ser um método virtual puro em classes abstratas) deverá ter uma implementação vazia, os outros métodos virtuais puros não tem implementação nenhuma.</p>

<p>PS: Uma classe com métodos abstratos não pode ser instanciada, mesmo se tiver apenas um método virtual puro. Na verdade, para criar uma classe abstrata, basta declarar um ou mais métodos virtual puros (atribuídos com 0). Quando a classe tem exclusivamente métodos virtuais puros, age de forma igual à uma interface (que existe em linguagens POO como Java, C# e PHP, mas não em C++).</p>

<p>Para criar uma classe com todos os métodos prontos como abstrata (para ser usada em heranças), basta criar o método destrutor dela como virtual puro (<code>virtual ~NomeDaClasse() = 0</code> e uma implementação do mesmo (mesmo sem código algum entre as chaves) na mesma classe, pode ser feita na Veiculo, por exemplo, nesse código acima seria o recomendado, pra encapsular também a classe), e as classes que a herdarem, não precisam de nenhuma alteração. Caso esse método virtual não possua implementação, aí sim as classes filhas dessa terão que implementar.</p>

<p>E na classe que a implementará, coloque como se fosse uma herança, e o sobreponha os métodos com <code>override</code>:</p>

<pre>
<code>
include "Estoque.h"

class Caixa : public Estoque {
    public:
        void defineLado(int l) override;
        double volume() override;

        const double getLado();
        void setLado(double lado);
    private:
        double lado;
};

void Caixa::defineLado(int l) {
    this->lado = l;
}

double Caixa::volume() {
    return lado * lado * lado;
}

const double Caixa::getLado() {
    return lado;
}

void Caixa::setLado(double lado) {
    this->lado = lado;
}
</code>
</pre>

<p>E a implementação no main:</p>

<pre>
<code>
Estoque *cx = new Caixa();

cx->defineLado(5);

cout << cx->volume() << endl;

delete cx;
</code>
</pre>

<p>E no método main podemos verificar se a classe implementa a classe abstrata usando um if e else:</p>

<pre>
<code>
Estoque *cx = new Caixa();

if(typeid(cx) == typeid(Estoque*)) { // inclua typeinfo
    cx->defineLado(5);

    cout << cx->volume() << endl;
}
else {
    cerr << "Classe AbstVeiculo Não Implementada!" << endl;
}

delete cx;
</code>
</pre>

<p>Usando uma classe base no "tipo" do objeto, e ele sendo implementado com uma classe herdeira, permite maior polimorfismo, pois qualquer classe que herde o "tipo" da classe anterior, pode ser implementada.</p>

<p>Alternativamente, podemos fazer assim, de uma forma mais "gambiarrenta":</p>

<pre>
<code>
// Funções estruturadas:
void defLado(Estoque &caix, int l) {
    caix.defineLado(l);
}

double verVol(Estoque &caix) {
    return caix.volume();
}

int main() {
    Caixa cx;

    defLado(cx, 5);

    cout << verVol(cx) << endl;

    return 0;
}
</code>
</pre>

<ul>
    <li><a href="poo-em-cpp-4.html">Parte Anterior da Matéria!</a></li>
    <li><a href="poo-em-cpp-6.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>