<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda Python Pentest</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda Python Pentest</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-python-pentest-1.html">Tudo sobre Python Pentest Parte 1!</a></li>
                    <li><a href="tudo-sobre-python-pentest-2.html">Tudo sobre Python Pentest Parte 2!</a></li>
                    <li><a href="tudo-sobre-python-pentest-3.html">Tudo sobre Python Pentest Parte 3!</a></li>
                    <li><a href="tudo-sobre-python-pentest-4.html">Tudo sobre Python Pentest Parte 4!</a></li>
                    <li><a href="tudo-sobre-python-pentest-5.html">Tudo sobre Python Pentest Parte 5!</a></li>
                    <li><a href="tudo-sobre-python-pentest-6.html" onclick="alert('Você já Está na Matéria desse Link!'); return false">Tudo sobre Python Pentest Parte 6!</a></li>
                    <li><a href="tudo-sobre-python-pentest-7.html">Tudo sobre Python Pentest Parte 7!</a></li>
                    <li><a href="tudo-sobre-python-pentest-8.html">Tudo sobre Python Pentest Parte 8!</a></li>
                    <li><a href="tudo-sobre-python-pentest-9.html">Tudo sobre Python Pentest Parte 9!</a></li>
                    <li><a href="tudo-sobre-python-pentest-10.html">Tudo sobre Python Pentest Parte 10!</a></li>
                </menu>
            </header>
           
<h2>Tudo sobre Python Pentest Parte 6</h2>

<h3>Identificando Index Of</h3>

<p>Agora nós vamos fazer o nosso script identificar pastas com Index Of, que tem listagem de arquivos e diretórios. Isso economiza tempo de execução, já que, com o Index Of, podemos identificar os arquivos sem fazer bruteforce.</p>

<p>No caso, nós filtraremos vendo o que tem na tag <q>title</q> do HTML.</p>

<p>Altere o if url da função check assim:</p>

<pre>
<code>
if url + "/" == local:
    print(f"Pasta: {url}/ - CODE: {code}")
    re = requests.get(url + "/")

    if re.status_code == 200:
        html = re.text

        if "&lt;title&gt;Index of" in html:
            print("\u2514 -&gt; Index of")
    else:
        pastas.append(url)
</code>
</pre>

<p>Daí, pra pegar os arquivos dentro da pasta de Index of, podemos verificar os arquivos baseados na tag <q>a</q> do HTML. Deixe o if de url assim:</p>

<pre>
<code>
if url + "/" == local:
    print(f"Pasta: {url}/ - CODE: {code}")
    re = requests.get(url + "/")

    if re.status_code == 200:
        html = re.text

        if "&lt;title&gt;Index of" in html:
            try:
                for h in html.split("Parent Directory")[1].split("&lt;a href=\""):
                    arq = h.split("&lt;/a&gt;")[0].split("\"")[0]

                    if len(arq) &gt; 2:
                        print(f"{'\u2514'} {arq}")
            except:
                pass
        else:
            pastas.append(url)
    else:
        pastas.append(url)
</code>
</pre>

<h3>Implementando Threads</h3>

<p>Como explicado anteriormente, um thread permite que duas ou mais funções sejam executadas praticamente ao mesmo tempo.</p>

<p>Para implementarmos um thread no nosso Dirb, podemos fazer a importação com <code>import threading</code> e do time acima do nosso código. E na função looping, faça assim:</p>

<pre>
<code>
def looping(wordl, dom):
    for w in wordl:
        item = w.replace("\n", "")
        url = f"{dom}{item}"
        th = threading.Thread(target = check, args = (url,))
        th.start()
</code>
</pre>

<p>O problema é que uma wordlist com 11 linhas, gerará 11 threads, mas pode dar problemas com wordlists maiores (como uma com 4000 linhas, tipo a do verdadeiro Dirb localizada em <q>/usr/share/dirb/wordlists/common.txt</q>).</p>

<p>Diferente de um script de scan de portas, o HTTP trabalha em uma camada mais alta em redes, e isso acaba fazendo que tanto o servidor quanto o cliente tenha maior processamento para tratar as requisições. Então, criar muitas threads pode causar sobrecarga em ambos, fazendo que o teste fique mais lento do que com as funções normais.</p>

<p>Para limtar as Threads, podemos usar um semáforo, assim, colocando na função looping:</p>

<pre>
<code>
def looping(wordl, dom):
    global semaforo
    semaforo = threading.Semaphore(3)  # Definindo o semáforo

    for w in wordl:
        item = w.replace("\n", "")
        url = f"{dom}{item}"
        th = threading.Thread(target = check, args = (url,))
        th.start()
</code>
</pre>

<p>E na função check, apenas temos que identar tudo dentro no with com o semáforo, veja como fica no início da função:</p>

<pre>
<code>
def check(url):
    with semaforo:
        re = requests.head(url, allow_redirects = False)
        code = re.status_code
</code>
</pre>

<p>Mas ele dará alguns bugs, então altere a função check assim, dentro do if url:</p>

<pre>
<code>
if url + "/" == local:
    dirP = f"Pasta: {url}/ - CODE: {code}"
    re = requests.get(url + "/")

    if re.status_code == 200:
        html = re.text

        if "&lt;title&gt;Index of" in html:
            print(f"{dirP}\n{'\u2514'} -> Index of")
        else:
            print(dirP)
            pastas.append(url)
    else:
        print(dirP)
        pastas.append(url)
</code>
</pre>

<p>Ele mostrará três condições, mas imprimirá apenas uma por execução da função (do thread, no caso).</p>

<p>Só que o código ainda dará um erro que não exibirá os arquivos das pastas. Para isso, corrigiremos a função looping, que adicionará os threads numa lista e fará outra repetição:</p>

<pre>
<code>
def looping(wordl, dom):
    global semaforo
    semaforo = threading.Semaphore(3)  # Definindo o semáforo

    thrd = list()
    for w in wordl:
        item = w.replace("\n", "")
        url = f"{dom}{item}"
        th = threading.Thread(target = check, args = (url,))
        thrd.append(th)
        th.start()
        
    for t in thrd:
        t.join()
</code>
</pre>

<p>PS: Pra melhorar a exibição, podemos fazer assim, na função check, dentro do with semaforo:</p>

<pre>
<code>
with semaforo:
    msg = f"Testando {url}"
    print(f"{msg}", end = "")
    print(" " * 100, end = "\r") # O \r sobreescreve a mensagem anterior
    re = requests.head(url, allow_redirects = False)
    code = re.status_code
</code>
</pre>

<ul>
    <li><a href="tudo-sobre-python-pentest-5.html">Parte Anterior da Matéria!</a></li>
    <li><a href="tudo-sobre-python-pentest-7.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>