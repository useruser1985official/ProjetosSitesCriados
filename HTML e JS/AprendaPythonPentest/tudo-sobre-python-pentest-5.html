<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda Python Pentest</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda Python Pentest</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-python-pentest-1.html">Tudo sobre Python Pentest Parte 1!</a></li>
                    <li><a href="tudo-sobre-python-pentest-2.html">Tudo sobre Python Pentest Parte 2!</a></li>
                    <li><a href="tudo-sobre-python-pentest-3.html">Tudo sobre Python Pentest Parte 3!</a></li>
                    <li><a href="tudo-sobre-python-pentest-4.html">Tudo sobre Python Pentest Parte 4!</a></li>
                    <li><a href="tudo-sobre-python-pentest-5.html" onclick="alert('Você já Está na Matéria desse Link!'); return false">Tudo sobre Python Pentest Parte 5!</a></li>
                    <li><a href="tudo-sobre-python-pentest-6.html">Tudo sobre Python Pentest Parte 6!</a></li>
                    <li><a href="tudo-sobre-python-pentest-7.html">Tudo sobre Python Pentest Parte 7!</a></li>
                    <li><a href="tudo-sobre-python-pentest-8.html">Tudo sobre Python Pentest Parte 8!</a></li>
                    <li><a href="tudo-sobre-python-pentest-9.html">Tudo sobre Python Pentest Parte 9!</a></li>
                    <li><a href="tudo-sobre-python-pentest-10.html">Tudo sobre Python Pentest Parte 10!</a></li>
                </menu>
            </header>
           
<h2>Tudo sobre Python Pentest Parte 5</h2>

<h3>Criando um PortScan</h3>

<p>Podemos também desenvolver nosso próprio PortScan, semelhante ao Nmap. Veja um exemplo simples:</p>

<pre>
<code>
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

print(sock.connect_ex(("globo.com", 80))) # O connect_ex retorna um código
</code>
</pre>

<p>Se a porta estiver aberta, ele retornará 0, se estiver fechada ele dará um erro, que será tratado posteriormente, podemos fazer assim, definindo um timeout pra ele desconectar:</p>

<pre>
<code>
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

sock.settimeout(0.1)

print(sock.connect_ex(("globo.com", 80))) # O connect_ex retorna um código
</code>
</pre>

<p>E usando um if:</p>

<pre>
<code>
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

sock.settimeout(0.1)

porta = 80

if sock.connect_ex(("globo.com", porta)) == 0:
    print(f"{porta}/tcp aberta!")
</code>
</pre>

<p>Pra ele ficar funcional, deixe ele assim:</p>

<pre>
<code>
import socket

def checkPort(host, porta):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    sock.settimeout(0.1)

    verif = sock.connect_ex((host, porta))

    if verif == 0:
        print(f"{porta}/tcp de {host} aberta!")

    sock.close()

host = str(input("Insira o domínio ou IP: "))

for p in range(65536):
    checkPort(host, p)
</code>
</pre>

<p>Mas o programa assim ficará muito lento, podemos colocar menos portas no range, como 1025 (pra ele contar do 0 ao 1024).</p>

<p>Para resolver isso, define essa função e comente o for por enquanto:</p>

<pre>
<code>
def getIP(host):
    sock = socket.getaddrinfo(host, None, socket.AF_INET)
    print(sock[0][4][0])

host = str(input("Insira o domínio ou IP: "))

getIP(host)
</code>
</pre>

<p>Daí, apenas troque o print da função pelo return, e deixe a chamada assim:</p>

<pre>
<code>
def getIP(host):
    sock = socket.getaddrinfo(host, None, socket.AF_INET)
    return sock[0][4][0]

host = str(input("Insira o domínio ou IP: "))
addr = getIP(host)

for p in range(65536):
    checkPort(addr, p)
</code>
</pre>

<h3>Escaneando as 1000 Primeiras Portas</h3>

<p>Entendendo o arquivo nmap-service, do programa Nmap (encontrado em <q>C:\Program Files (x86)\Nmap</q> no Windows ou <q>/usr/share/nmap</q> no Linux), nós vemos as portas mais comuns e a frequência com as quais elas são encontradas. Veja um trecho de algumas linhas:</p>

<pre>
<code>
http    80/sctp 0.000000    # www-http | www | World Wide Web HTTP
http    80/tcp  0.484143    # World Wide Web HTTP
http    80/udp  0.035767    # World Wide Web HTTP
</code>
</pre>

<p>O número decimal ao lado da porta representa a frequência relativa com que determinado serviço foi observado naquela porta e protocolo, de 0 a 1. Por exemplo, o número 0.484143 indica que, em 48,4143% dos casos observados, o serviço HTTP foi encontrado na porta 80 usando o protocolo TCP.</p>

<p>No Linux, para filtrar apenas as portas mais usadas (que são as com os números decimais maiores, fazemos assim:</p>

<pre>
<code>
cat /usr/share/nmap/nmap-services | grep -v "^#" | grep "tcp" | sort -k3 -r | head -n 1000
</code>
</pre>

<p>Mas pra facilitar, principalmente se não estiver no Linux, podemos baixar esse arquivo pra teste <a href="files/1000-portas-nmap.txt" target="_blank">clicando aqui</a>!</p>

<p>Num arquivo de teste, coloque esse código pra ler o arquivo TXT criado:</p>

<pre>
<code>
with open("1000-portas-nmap.txt") as arqPort:
    for p in arqPort.readlines():
        linha = p.replace("\n", "")
        print(linha.encode())
</code>
</pre>

<p>Com a filtragem splitada:</p>

<pre>
<code>
with open("1000-portas-nmap.txt") as arqPort:
    for p in arqPort.readlines():
        linha = p.replace("\n", "")
        porta = linha.split("\t")[1].split("/")[0]
        servico = linha.split("\t")[0]
        print(f"{porta}/{servico}")
</code>
</pre>

<p>E pra ficar tipo um dicionário ou JSON, faça assim:</p>

<pre>
<code>
print(f"{porta}: \"{servico}\", ", end = "") # Não esqueça das aspas e da vírgula
</code>
</pre>

<p>Daí, execute o código e faça um dicionário com elas no PortScan, assim:</p>

<pre>
<code>
host = str(input("Insira o domínio ou IP: "))
addr = getIP(host)

dicPortas = {80: "http", 23: "telnet", 443: "https", 21: "ftp", 22: "ssh", 25: "smtp"} # Esse é só um exemplo, ele teria mil índices.

for p in dicPortas:
    checkPort(addr, p)
</code>
</pre>

<p>Agora, coloque antes de todas as funções, o mesmo dicionário com as portas e o indicador global, assim:</p>

<pre>
<code>
global dicPortas
dicPortas = {80: "http", 23: "telnet", 443: "https", 21: "ftp", 22: "ssh", 25: "smtp"}
</code>
</pre>

<p>E daí, altere apenas o print dentro do if de checkPort, assim:</p>

<pre>
<code>
if verif == 0:
    op = f"{porta}/tcp"
    print(f"{op:&lt;15} {dicPortas[porta]:&lt;15} {host:&lt;18} ABERTA")
</code>
</pre>

<p>E acima do for que invoca a função, colocamos apenas isso:</p>

<pre>
<code>
print(f"{'PORTA':&lt;15} {'SERVIÇO':&lt;15} {'IP':&lt;18} {'SITUAÇÃO'}")
</code>
</pre>

<p>Assim ele formatará de uma forma mais agradável.</p>

<h3>Criando PortScan mais Rápido que Nmap</h3>

<p>Para fazer o portscan mais rápido, precisaremos usar threads. Um thread permite que duas ou mais funções sejam executadas praticamente ao mesmo tempo. Num arquivo de teste, podemos fazer um exemplo.</p>

<p>Exemplo sem thread:</p>

<pre>
<code>
def imprimir(texto):
    for i in range(5):
        print(f"{texto} - {i}")

imprimir("f1")
imprimir("f2")
</code>
</pre>

<p>Exemplo com thread:</p>

<pre>
<code>
import threading
import time

def imprimir(texto):
    for i in range(5):
        time.sleep(1) # Só pra retardar o script para vermos a execução, normalmente não usamos time
        print(f"{texto} - {i}")

t1 = threading.Thread(target = imprimir, args = ("f1",)) # Não pode esquecer da vírgula depois dos argumentos
t2 = threading.Thread(target = imprimir, args = ("f2",))

t1.start()
t2.start()
</code>
</pre>

<p>No arquivo PortScan.py, coloque a importação de threading acima, e dentro do for, faça assim:</p>

<pre>
<code>
for p in dicPortas:
    t = threading.Thread(target = checkPort, args = (addr, p,))
    t.start()
</code>
</pre>

<p>Dessa forma, ele, antes de finalizar a análise de uma porta, ele vai executar a seguinte análise, e deixar o código mais rápido.</p>

<!--
  -- Esse código deu erro por incompatibilidade de versões.
  -- Revisar futuramente.
  -- Testar futuramente em ambiente Linux. O Windows restringem uso de pacotes no Nível 3.

Criando Syn Scan

O Syn Scan, ou scan invisível, é um tipo de varredura rápida de meia-conexão (já que não faz handshake pra finalizar a mesma), por isso é mais furtiva e mais difícil de detectar. Podemos fazer ele no Nmap rodando ele como root ou passando a opção -sS nele.

Podemos rodar nosso port scan, que não tem a opção de syn scan. E ouvir ele com o Netcat (com o comando nc -lvp 8080).

Depois, nós rodaremos o Nmap como usuário comum, mas com a opção -sS (algo como nmap -sS -p 8080 localhost) ele não será detectado pelo Netcat, sem essa opção ele será identificado. Podemos também abrir o Wireshark e escanear a interface de rede padrão e ver como o Nmap e o Netcat agem. Claro que a detecção desse tipo de script não é impossível, mas é mais difícil.

Para trabalhar com um nível mais baixo em redes com o Python, podemos usar a biblioteca scapy.

Veja um exemplo simples de uso dele:

from scapy.all import IP, TCP, sr, L3RawSocket, conf, RandShort

host = "127.0.0.1" # IP de Destino. O scapy tem que trabalhar com endereços IP literais
porta = 8080

conf.L3socket = L3RawSocket() # Forçando Raw Socket

pacoteIP = IP(dst = host) # Montando IP
pacoteTCP = TCP(dport = porta, sport = RandShort(), flags = "S", seq = 1000, options = [("MSS", 1460), ("NOP", None), ("WScale", 7)]) # Montando TCP, S é Syn

pkg, unpkg = sr(pacoteIP, pacoteTCP, timeout = 0.1) # Função que retorna a lista de pacotes que foram enviados

if pkg:
    for s, r in pkg: # s é o que enviou, r é o que respondeu
        if r.haslayer(TCP):
            if r[TCP].flags == 0x012: # Verifica se a porta está aberta!
                print("Porta aberta!")

-->

<h3>Criando um Dirb</h3>

<p>Para fazer um programa tipo Dirb, instale a biblioteca <code>requests</code>. Baixe também uma wordlist, podemos baixar um exemplo <a href="files/wordlist-diretorios-e-arquivos.txt" target="_blank">clicando aqui</a>.</p>

<p>Primeiramente, faça esse código aqui:</p>

<pre>
<code>
dominio = str(input("Insira o domínio: "))
wordlist = "wordlist-diretorios-e-arquivos.txt"

if dominio[-1] != "/":
    dominio += "/"

print(dominio)

with open(wordlist) as arqWord:
    for w in arqWord.readlines():
        item = w.replace("\n", "")
        url = f"{dominio}{item}"
        print(url)
</code>
</pre>

<p>Em um servidor, quando a gente digita o diretório de um site sem a barra no final (<q>/</q>), ele retorna no request a informação 301 (Moved Permanented, que indica redirecionamento), com isso podemos saber o que é pasta e o que é arquivo (já que na wordlist tem os dois misturados), e o location no request retorna o link correto. Isso é usando o GET, mas este consome muitos recursos do servidor, por isso é recomendado usar o Header.</p>

<p>Esse é um exemplo de um trecho de um header:</p>

<pre>
<code>
HTTP/1.1 301 Moved Permanently
Date: Thu, 16 Oct 2025 11:47:56 GMT
Content-Type: text/html; charset=iso-8859-1
Transfer-Encoding: chunked
Connection: keep-alive
Server: cloudflare
Location: http://www.bancocn.com/images/
</code>
</pre>

<p>Pra iniciar, deixe o script assim:</p>

<pre>
<code>
import requests

dominio = str(input("Insira o domínio: "))
wordlist = "wordlist-diretorios-e-arquivos.txt"

if dominio[-1] != "/":
    dominio += "/"

with open(wordlist) as arqWord:
    for w in arqWord.readlines():
        item = w.replace("\n", "")
        url = f"{dominio}{item}"

        re = requests.head(url, allow_redirects = False)

        print(f"{url} - {re.status_code}")    
</code>
</pre>

<p>Daí, pros não encontrados ele retornará 404, pros diretórios encontrados retornará 301 ou 302.</p>

<p>Pra continuar, retire o último print e coloque isso no lugar dele:</p>

<pre>
<code>
code = re.status_code

if code in (301, 302):
    local = re.headers.get("Location")

    if url + "/" == local:
        print(f"Pasta: {url}/ - CODE: {code}")
elif code in (200, 403):
    print(f"Arquivo: {url} - CODE: {code}")
</code>
</pre>

<p>E depois, reescreva o programa com funções, assim:</p>

<pre>
<code>
import requests

def check(url):
    re = requests.head(url, allow_redirects = False)
    code = re.status_code

    if code in (301, 302):
        local = re.headers.get("Location")
        
        if url + "/" == local:
            print(f"Pasta: {url}/ - CODE: {code}")
    elif code in (200, 403):
        print(f"Arquivo: {url} - CODE: {code}")

def looping(wordl, dom):
    for w in wordl:
        item = w.replace("\n", "")
        url = f"{dom}{item}"
        check(url)

dominio = str(input("Insira o domínio: "))
wordlist = "wordlist-diretorios-e-arquivos.txt"

if dominio[-1] != "/":
    dominio += "/"

with open(wordlist) as arqWord:
    word = arqWord.readlines()

looping(word, dominio)
</code>
</pre>

<p>No começo do código, antes de quaisquer funções, coloque isso:</p>

<pre>
<code>
global pastas
pastas = list()
</code>
</pre>

<p>E dentro do segundo if da função check, apenas coloque o append, assim:</p>

<pre>
<code>
if url + "/" == local:
    print(f"Pasta: {url}/ - CODE: {code}")
    pastas.append(url)
</code>
</pre>

<p>No final de todo o código, abaixo da invocação da função looping, podemos rodar o print com as pastas pra ver se elas estão sendo capturadas pelo script:</p>

<pre>
<code>
print(pastas)
</code>
</pre>

<p>E no lugar do print acima, coloque isso:</p>

<pre>
<code>
if len(pastas) >= 1: # Verifica se existe pelo menos um arquivo na pasta
    for p in pastas:
        print(p)
</code>
</pre>

<p>E pra ele poder analisar recursivamente as pastas, faça assim:</p>

<pre>
<code>
if len(pastas) >= 1: # Verifica se existe pelo menos um arquivo na pasta
    for p in pastas:
        dominio = p + "/"
        looping(word, dominio)
</code>
</pre>

<p>Só para entendimento, esses são os códigos usados nesse script:</p>

<table>
    <tr>
        <th>Código</th>
        <th>Significado Curto</th>
    </tr>
    <tr>
        <td>200</td>
        <td>Ok</td>
    </tr>
    <tr>
        <td>301</td>
        <td>Movido Permanentemente</td>
    </tr>
    <tr>
        <td>302</td>
        <td>Movido Temporariamente</td>
    </tr>
    <tr>
        <td>403</td>
        <td>Proibido</td>
    </tr>
    <tr>
        <td>404</td>
        <td>Não Encontrado</td>
    </tr>
</table>

<p>PS: O <q>proibido</q> dá a entender que o arquivo existe no servidor, mas foi bloqueado pelo firewall ou outra ferramenta de segurança do mesmo.</p>

<ul>
    <li><a href="tudo-sobre-python-pentest-4.html">Parte Anterior da Matéria!</a></li>
    <li><a href="tudo-sobre-python-pentest-6.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>