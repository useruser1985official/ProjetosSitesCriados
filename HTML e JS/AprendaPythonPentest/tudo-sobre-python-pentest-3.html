<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda Python Pentest</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda Python Pentest</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-python-pentest-1.html">Tudo sobre Python Pentest Parte 1!</a></li>
                    <li><a href="tudo-sobre-python-pentest-2.html">Tudo sobre Python Pentest Parte 2!</a></li>
                    <li><a href="tudo-sobre-python-pentest-3.html" onclick="alert('Você já Está na Matéria desse Link!'); return false">Tudo sobre Python Pentest Parte 3!</a></li>
                    <li><a href="tudo-sobre-python-pentest-4.html">Tudo sobre Python Pentest Parte 4!</a></li>
                    <li><a href="tudo-sobre-python-pentest-5.html">Tudo sobre Python Pentest Parte 5!</a></li>
                    <li><a href="tudo-sobre-python-pentest-6.html">Tudo sobre Python Pentest Parte 6!</a></li>
                </menu>
            </header>
           
<h2>Tudo sobre Python Pentest Parte 3</h2>

<h3>Melhorando Script</h3>

<p>O nosso bruteforce de subdomínios irá fazer parte de uma ferramenta mais aprimorada mais pra frente, por isso podemos e devemos fazer melhorias.</p>

<p>Vamos começar adicionando abaixo da entrada de domínio, dois dicionários, assim:</p>

<pre>
<code>
cons = list()
dom4 = dict()
dom6 = dict()
relDom = dict()
</code>
</pre>

<p>E altere as funções dnsIPv4 e dnsIPv6 para que elas retornem o endereço. Veja como ficará o dnsIPv4 e faça o mesmo com o dnsIPv6:</p>

<pre>
<code>
def dnsIPv4(subdom):
    try:
        dados = socket.getaddrinfo(subdom, None, socket.AF_INET)
        addr = dados[0][4][0]
        print(f"{subdom} - {addr}")
        
        return addr
    except socket.gaierror:
        return 0
</code>
</pre>

<p>E altere a estrutura with open assim:</p>

<pre>
<code>
with open("wordlist-dominios.txt") as wordlist:
    for w in wordlist.readlines():
        w = w.replace("\n", "")
        subdom = f"{w}.{dominio}"

        if subdom not in cons:
            addr4 = dnsIPv4(subdom)
            addr6 = dnsIPv6(subdom)
            cons.append(subdom)
</code>
</pre>

<p>Para ele salvar os dicionários, deixe a estrutura assim:</p>

<pre>
<code>
with open("wordlist-dominios.txt") as wordlist:
    for w in wordlist.readlines():
        w = w.replace("\n", "")
        subdom = f"{w}.{dominio}"

        if subdom not in cons:
            addr4 = dnsIPv4(subdom)
            addr6 = dnsIPv6(subdom)

            if addr4 != 0:
                dom4[subdom] = addr4

            if addr6 != 0:
                dom6[subdom] = addr6
                
            cons.append(subdom)    
</code>
</pre>

<p>E debaixo de tudo isso, fora de todas as identações, coloque isso pra ele colocar os dicionários em IPv4 e IPv6 dentro de um outro dicionário:</p>

<pre>
<code>
relDom["ipv4"] = dom4
relDom["ipv6"] = dom6

print(relDom)
</code>
</pre>

<p>Agora apague o print acima e coloque isso no lugar pra ele salvar como JSON:</p>

<pre>
<code>
domJson = json.dumps(relDom) # Coloque "import json" acima do código

with open(f"{dominio}-subdomains.json", "w") as arqJson:
    arqJson.write(domJson)
</code>
</pre>

<p>No caso, salvaremos tudo num arquivo JSON só, que terá esse formato:</p>

<pre>
<code>
{"ipv4": {
    "www.facebook.com": "157.240.222.35",
    "mobile.facebook.com": "157.240.222.16",
    "m.facebook.com": "157.240.222.35"},
"ipv6": {
    "www.facebook.com": "2a03:2880:f148:82:face:b00c:0:25de",
    "mobile.facebook.com": "2a03:2880:f048:11:face:b00c:0:2",
    "m.facebook.com": "2a03:2880:f148:82:face:b00c:0:25de"}
}
</code>
</pre>

<p>Para ver um arquivo JSON, podemos usar um site como esse: <a href="https://jsonviewer.stack.hu/" target="_blank">https://jsonviewer.stack.hu/</a></p>

<p>Mas futuramente faremos isso com o próprio Python.</p>

<h3>Subdomain Takeover</h3>

<p>Podemos também fazer ele retornar o CNAME, CNAME é um tipo de registro DNS que funciona como um alias: Ele aponta um nome de domínio para outro. Por exemplo, o domínio <q>help.4d3358.com</q> pode ter um CNAME apontando para um outro site de nome mais amigável. Isso significa que, ao resolver <q>help.4d3358.com</q>, o DNS retorna o endereço desse outro site mais amigável. Porém, isso não garante redirecionamento no navegador, apenas o apontamento de nome.</p>

<p>Instale a biblioteca dnspython e vamos fazer esse programa:</p>

<pre>
<code>
import dns.resolver

dominio = str(input("Digite o domínio: "))

resp = dns.resolver.resolve(dominio, "CNAME")

print(resp)
</code>
</pre>

<p>Ele dará um erro caso o domínio não tenha nenhuma resposta. Para filtrar, fazemos assim:</p>

<pre>
<code>
import dns.resolver

dominio = str(input("Digite o domínio: "))

try:
    resp = dns.resolver.resolve(dominio, "CNAME")
    print(resp[0].target)
except dns.resolver.NoAnswer:
    print("Não encontrado o CNAME!")
</code>
</pre>

<p>Caso passemos um outro subdomínio no mesmo domínio, ele dará erro. Também podemos filtrar ele:</p>

<pre>
<code>
import dns.resolver

dominio = str(input("Digite o domínio: "))

try:
    resp = dns.resolver.resolve(dominio, "CNAME")
    print(resp[0].target)
except dns.resolver.NoAnswer:
    print("Não encontrado o CNAME!")
except dns.resolver.NXDOMAIN:
    print("Não encontrado o subdomínio!")
</code>
</pre>

<p>Podemos também usar o bruteforce de subdomínios para isso, deixando dessa forma, nesse caso passe só o domínio:</p>

<pre>
<code>
import dns.resolver

dominio = str(input("Digite o domínio: "))

with open("wordlist-dominios.txt") as wordlist:
    for w in wordlist.readlines():
        w = w.replace("\n", "")
        subdom = f"{w}.{dominio}"

        try:
            resp = dns.resolver.resolve(subdom, "CNAME")
            cname = resp[0].target
            print(f"{subdom} tem um alias {cname}")
        except dns.resolver.NoAnswer:
            pass
        except dns.resolver.NXDOMAIN:
            pass
</code>
</pre>

<p>PS: Não é porque tem um alias que o domínio exatamente tenha uma vulnerabilidade.</p>

<p>Ao fazer essas análises, pode ser que o próprio servidor bloqueie ele, então nesse caso, podemos fazer um filtro nele também:</p>

<pre>
<code>
with open("wordlist-dominios.txt") as wordlist:
    for w in wordlist.readlines():
        w = w.replace("\n", "")
        subdom = f"{w}.{dominio}"

        while True:
            try:
                resp = dns.resolver.resolve(subdom, "CNAME")
                cname = resp[0].target
                print(f"{subdom} tem um alias {cname}")
                
                break
            except dns.resolver.NoAnswer:
                break
            except dns.resolver.NXDOMAIN:
                break
            except dns.resolver.LifetimeTimeout:
                print("Caiu no Timeout CNAME...")
                time.sleep(2) # Adicione "import time" logo acima, aumente ou diminua conforme a necessidade
</code>
</pre>

<h3>Aprimorando nosso Script DNS</h3>

<p>Vamos usar o JSON para salvar os resultados das nossas análises. No começo do script, chame o JSON e crie um dicionário, assim:</p>

<pre>
<code>
import dns.resolver
import time
import json

dominio = str(input("Digite o domínio: "))
cnameDic = dict()
</code>
</pre>

<p>E no try, faça assim:</p>

<pre>
<code>
resp = dns.resolver.resolve(subdom, "CNAME")
cname = resp[0].target
cnameDic[subdom] = str(cname)
print(f"{subdom} tem um alias {cname}")

break
</code>
</pre>

<p>E no final do código, fora de qualquer identação, coloque isso:</p>

<pre>
<code>
cnameJson = json.dumps(cnameDic)

with open(f"{dominio}-cname.json", "w") as arqJson:
    arqJson.write(cnameJson)
    
print(f"Arquivo JSON {dominio}-cname.json criado!")
</code>
</pre>

<p>Agora, vamos organizar tudo num arquivo só que unirá os dois programas, volte no arquivo de subdomínios e vamos unir os dois. Primeiramente, crie uma classe assim:</p>

<pre>
<code>
import socket
import json

class DnsScan:
    def subdominios(self, dominio, listaPl):
        cons = list()
        dom4 = dict()
        dom6 = dict()
        relDom = dict()

        with open(listaPl) as wordlist:
            for w in wordlist.readlines():
                w = w.replace("\n", "")
                subdom = f"{w}.{dominio}"

                if subdom not in cons:
                    addr4 = self.dnsIPv4(subdom)
                    addr6 = self.dnsIPv6(subdom)

                    if addr4 != 0:
                        dom4[subdom] = addr4

                    if addr6 != 0:
                        dom6[subdom] = addr6

                    cons.append(subdom)

        relDom["ipv4"] = dom4
        relDom["ipv6"] = dom6

        domJson = json.dumps(relDom)

        with open(f"{dominio}-subdomains.json", "w") as arqJson:
            arqJson.write(domJson)

        print(f"Arquivo JSON {dominio}-subdomains.json criado!")

    def dnsIPv4(self, subdom):
        try:
            dados = socket.getaddrinfo(subdom, None, socket.AF_INET)
            addr = dados[0][4][0]
            print(f"{subdom} - {addr}")

            return addr
        except socket.gaierror:
            return 0

    def dnsIPv6(self, subdom):
        try:
            dados = socket.getaddrinfo(subdom, None, socket.AF_INET6)
            addr = dados[0][4][0]
            print(f"{subdom} - {addr}")

            return addr
        except socket.gaierror:
            return 0
</code>
</pre>

<p>No arquivo principal (como dnsfoda.py), fazemos assim:</p>

<pre>
<code>
from DnsScan import DnsScan
import sys

dominio = sys.argv[1]
wordlist = sys.argv[2]

dns = DnsScan()

dns.subdominios(dominio, wordlist)
</code>
</pre>

<p>E rode pelo terminal digitando <code>python3 dnsfoda.py nomedosite.com wordlist.txt</code>.</p>

<p>Para unir as funcionalidades dos dois programas, coloque esse método na classe DnsScan:</p>

<pre>
<code>
# Não esqueça de importar "dns.resolver" e "time"
def verifCName(self, dominio, listaPl):
    cNameDic = dict()

    with open(listaPl) as wordlist:
        for w in wordlist.readlines():
            w = w.replace("\n", "")
            subdom = f"{w}.{dominio}"

            while True:
                try:
                    resp = dns.resolver.resolve(subdom, "CNAME")
                    cName = resp[0].target
                    cNameDic[subdom] = str(cName)
                    print(f"{subdom} tem um alias {cName}")

                    break
                except dns.resolver.NoAnswer:
                    break
                except dns.resolver.NXDOMAIN:
                    break
                except dns.resolver.LifetimeTimeout:
                    print("Caiu no Timeout CNAME...")
                    time.sleep(3)

    cNameJson = json.dumps(cNameDic)

    with open(f"{dominio}-cname.json", "w") as arqJson:
        arqJson.write(cNameJson)

    print(f"Arquivo JSON {dominio}-cname.json criado!")
</code>
</pre>

<p>E altere o dnsfoda.py assim:</p>

<pre>
<code>
from DnsScan import DnsScan
import sys

dominio = sys.argv[1]
wordlist = sys.argv[2]

dns = DnsScan()

# dns.subdominios(dominio, wordlist)
dns.verifCName(dominio, wordlist)
</code>
</pre>

<p>Pra finalizar, deixe ele assim:</p>

<pre>
<code>
from DnsScan import DnsScan
import sys

dominio = sys.argv[1]
wordlist = sys.argv[2]

dns = DnsScan()

print("Iniciando bruteforce de subdomínios!")
dns.subdominios(dominio, wordlist)
print("Iniciando bruteforce de CNAME!")
dns.verifCName(dominio, wordlist)
</code>
</pre>

<p>PS: Podemos criar condições também para escolher apenas um dos scans.</p>

<ul>
    <li><a href="tudo-sobre-python-pentest-2.html">Parte Anterior da Matéria!</a></li>
    <li><a href="tudo-sobre-python-pentest-4.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>