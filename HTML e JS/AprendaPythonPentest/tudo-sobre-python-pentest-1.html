<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda Python Pentest</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda Python Pentest</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-python-pentest-1.html" onclick="alert('Você já Está na Matéria desse Link!'); return false">Tudo sobre Python Pentest Parte 1!</a></li>
                    <li><a href="tudo-sobre-python-pentest-2.html">Tudo sobre Python Pentest Parte 2!</a></li>
                    <li><a href="tudo-sobre-python-pentest-3.html">Tudo sobre Python Pentest Parte 3!</a></li>
                    <li><a href="tudo-sobre-python-pentest-4.html">Tudo sobre Python Pentest Parte 4!</a></li>
                    <li><a href="tudo-sobre-python-pentest-5.html">Tudo sobre Python Pentest Parte 5!</a></li>
                    <li><a href="tudo-sobre-python-pentest-6.html">Tudo sobre Python Pentest Parte 6!</a></li>
                    <li><a href="tudo-sobre-python-pentest-7.html">Tudo sobre Python Pentest Parte 7!</a></li>
                    <li><a href="tudo-sobre-python-pentest-8.html">Tudo sobre Python Pentest Parte 8!</a></li>
                    <li><a href="tudo-sobre-python-pentest-9.html">Tudo sobre Python Pentest Parte 9!</a></li>
                    <li><a href="tudo-sobre-python-pentest-10.html">Tudo sobre Python Pentest Parte 10!</a></li>
                </menu>
            </header>
            
<h2>Tudo sobre Python Pentest Parte 1</h2>
            
<h3>Trabalhando com Arquivos ASCII Simples</h3>

<p>Para manipularmos um arquivo ASCII no Python, fazemos assim:</p>

<pre>
<code>
arquivo = open("cadastro.txt", "w")

"""
w - Write (escrever)
a - Append (acrescentar)
r - Read (ler)
"""
</code>
</pre>

<p>Caso o arquivo cadastro.txt exista, ao usar o <q>w</q> ele sobrescreverá, para adicionar usamos a opção <q>a</q>, e o <q>r</q> é usado para ler o arquivo.</p>

<p>Podemos fazer esse programa para criar um arquivo:</p>

<pre>
<code>
nome = str(input("Digite seu nome: "))
idade = int(input("Digite sua idade: "))
sexo = str(input("Digite seu sexo: "))

arquivo = open("cadastro.txt", "w")

arquivo.write("-" * 30)
arquivo.write("\n")
arquivo.write(f"Nome: {nome}\n")
arquivo.write(f"Idade: {idade}\n")
arquivo.write(f"Sexo: {sexo}\n")

arquivo.close()

print("\nArquivo cadastro criado com sucesso!")
</code>
</pre>

<p>No caso acima, ele sobrescreverá, para adicionar algo no arquivo, usamos a opção <q>a</q>.</p>

<p>Para ler o mesmo arquivo, basta isso:</p>

<pre>
<code>
arquivo = open("cadastro.txt", "r")

print(arquivo.read())

arquivo.close()
</code>
</pre>

<p>Podemos jogar o conteúdo em variáveis, veja um exemplo simples:</p>

<pre>
<code>
arquivo = open("cadastro.txt", "r")

conteudo = arquivo.read()

nome = conteudo.split("Nome: ")[1].split("\n")[0]
idade = int(conteudo.split("Idade: ")[1].split("\n")[0])
sexo = conteudo.split("Sexo: ")[1].split("\n")[0]

arquivo.close()

print(nome)
print(idade)
print(sexo)
</code>
</pre>

<p>PS: Podemos colocar isso num for para ler todos os nomes descritos no arquivo, já que este código só pega o primeiro cadastro.</p>

<h3>Trabalhando com JSON</h3>

<p>Como sabemos, podemos trabalhar com dicionários em Python, que permite trabalhar com nomes literais nos índices do mesmo, como por exemplo:</p>

<pre>
<code>
cadastro = dict()

cadastro["nome"] = str(input("Digite seu nome: "))
cadastro["idade"] = int(input("Digite sua idade: "))
cadastro["sexo"] = str(input("Digite seu sexo: "))

print(cadastro)
</code>
</pre>

<p>Sabendo disso, podemos transformar esse dicionário num JSON:</p>

<pre>
<code>
import json

cadastro = dict()

cadastro["nome"] = str(input("Digite seu nome: "))
cadastro["idade"] = int(input("Digite sua idade: "))
cadastro["sexo"] = str(input("Digite seu sexo: "))

cadJson = json.dumps(cadastro)

print(cadJson)
</code>
</pre>

<p>E da mesma forma, podemos salvar num arquivo com a extensão JSON, igual fizemos com o arquivo de texto:</p>

<pre>
<code>
import json

cadastro = dict()

cadastro["nome"] = str(input("Digite seu nome: "))
cadastro["idade"] = int(input("Digite sua idade: "))
cadastro["sexo"] = str(input("Digite seu sexo: "))

cadJson = json.dumps(cadastro)

arquivo = open("cadastro.json", "w")

arquivo.write(cadJson)
arquivo.close()

print("\nArquivo JSON escrito com sucesso!")
</code>
</pre>

<p>Da mesma forma, podemos ler um JSON assim:</p>

<pre>
<code>
import json

arquivo = open("cadastro.json", "r")

cadJson = json.loads(arquivo.read())

arquivo.close()

print(cadJson)
</code>
</pre>

<p>E podemos melhorar esse código, assim:</p>

<pre>
<code>
import json

arquivo = open("cadastro.json", "r")

cadJson = json.loads(arquivo.read())

arquivo.close()

nome = str(cadJson["nome"])
idade = int(cadJson["idade"])
sexo = str(cadJson["sexo"])

print(f"Nome: {nome}")
print(f"Idade: {idade}")
print(f"Sexo: {sexo}")
</code>
</pre>

<h3>Criando Servidor TCP</h3>

<p>Como sabemos, o Netcat é um programa no qual podemos ler e escrever dados através de conexões utilizando os protocolos TCP ou UDP. Sabendo de como ele funciona, podemos criar nosso servidor TCP e comunicar com ele através do Netcat. Para ele aguardar uma conexão, basta digitar <code>nc -lvp 8080</code>, que ele escutará o endereço <code>0.0.0.0</code> (que pode escutar qualquer IP que represente sua própria máquina).</p>

<p>Para trabalhar com TCP/IP, usaremos a biblioteca socket do Python, para criar nosso próprio servidor. Podemos fazer nosso código assim, por exemplo:</p>

<pre>
<code>
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

""""
AF_INET = IPv4
AF_INET6 = IPv6

SOCK_STREAM - TCP
SOCK_DGRAM - UDP
"""
</code>
</pre>

<p>Como visto <code>AF_INET</code> é para IPv4 e <code>AF_INET6</code> para IPv6. Da mesma forma, <code>SOCK_STREAM</code> é para TCP e <code>SOCK_DGRAM</code> é para UDP.</p>

<p>Para criar um servidor simples, podemos fazer assim:</p>

<pre>
<code>
import socket

ip = "0.0.0.0"
porta = 8080

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

sock.bind((ip, porta))
sock.listen(1) # Quantidade de conexões que serão aguardadas

print(f"Aguardando conexão {ip}:{porta}...")

sock.accept()
</code>
</pre>

<p>Rode primeiro o servidor acima, e no terminal digite <code>nc 127.0.0.1 8080</code> (que será nosso cliente). O servidor aceitará a conexão.</p>

<p>Para um poder mandar mensagem pro outro, podemos fazer assim, alterando o <code>sock.accept()</code> e abaixo dele:</p>

<pre>
<code>
conn, cliente = sock.accept() # A função retorna dois valores, um pra cada variável.

print(f"Conectado com {cliente}.") # Mostrará o endereço do cliente

msg = input("&gt; ")
msg += "\n"

conn.send(msg.encode()) # Transforma string em bytes e envia pro cliente.

dados = conn.recv(1024) # Buffer com a quantidade de informações em bytes a receber
</code>
</pre>

<p>Rode o servidor e depois rode o comando no Netcat. Ele se comunicará, mas cairá em seguida.</p>

<p>PS: Apesar de configurado, costuma dar erros ao transmitir e receber textos com acentuação.</p>

<p>Para ele ficar num loop infinito, podemos colocar o while assim:</p>

<pre>
<code>
while True:
    msg = input("&gt; ")
    msg += "\n"
    
    conn.send(msg.encode()) # Transforma string em bytes e envia pro cliente.
    
    dados = conn.recv(1024) # Buffer com a quantidade de informações em bytes a receber
    
    print(dados.decode(), end = "")
</code>
</pre>

<p>Podemos inclusive pedir uma senha que aparecerá no Netcat para conexão, colocando isso abaixo do print de conectado:</p>

<pre>
<code>
conn.send("Digite a senha: ".encode())

senha = conn.recv(1024)

if senha.decode().strip() == "senhafoda":
    while True:
        msg = input("&gt; ")

        if msg == "sair":
            conn.send(f"Servidor encerrando conexão com {cliente}...".encode())   
            sock.close()

            break

        msg += "\n"

        conn.send(msg.encode()) # Transforma string em bytes e envia pro cliente.

        dados = conn.recv(1024) # Buffer com a quantidade de informações em bytes a receber

        print(dados.decode(), end = "")
else:
    conn.send("Senha Incorreta!".encode())

    sock.close()
</code>
</pre>

<h3>Criando Cliente TCP</h3>

<p>O cliente é bem mais simples que o servidor. Da mesma forma, criaremos um socket simples assim:</p>

<pre>
<code>
import socket

ip = "127.0.0.1"
porta = 8080

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

sock.connect((ip, porta))

msg = sock.recv(1024).decode()
senha = input(msg)

sock.send(senha.encode())

while True:
    print(sock.recv(1024).decode(), end = "")

    msg = input("&gt; ")
    msg += "\n"

    sock.send(msg.encode())
</code>
</pre>

<p>Rode o servidor primeiro e depois o cliente.</p>

<p>PS: No servidor, podemos colocar parâmetros para serem passados pelo terminal, como por exemplo:</p>

<pre>
<code>
import socket
import sys

ip = "0.0.0.0"
porta = int(sys.argv[1])
</code>
</pre>

<p>Daí é só passar rodando o script com o <code>python3 ServidorTCP.py 8080</code> (ou a porta desejada).</p>

<p>E no cliente também podemos fazer assim:</p>

<pre>
<code>
import socket
import sys

ip = sys.argv[1]
porta = int(sys.argv[2])    
</code>
</pre>

<p>Da mesma forma, é só passar rodando o script com o <code>python3 ClienteTCP.py 127.0.0.1 8080</code> (ou o IP e a porta desejada).</p>

<h3>Criando Servidor e Cliente UDP</h3>

<p>O servidor e o cliente UDP são mais simples que os em TCP, já que o UDP é mais rápido e não estabelece conexões.</p>

<p>Veja um exemplo simples de servidor UDP:</p>

<pre>
<code>
import socket

porta = 8080

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

sock.bind(("0.0.0.0", porta))

print(f"Aguardando conexão UDP 0.0.0.0:{porta}.")

while True:
    dados, cliente = sock.recvfrom(1024) # Também retorna dois valores

    print(f"{cliente} - {dados.decode()}")
    
    msg = input("&gt; ")
    
    sock.sendto(msg.encode(), cliente)
</code>
</pre>

<p>Como o UDP não precisa estabelecer conexões, qualquer dispositivo pode se conectar ao servidor, que enviará a informação pro cliente.</p>

<p>Veja o exemplo do cliente UDP:</p>

<pre>
<code>
import socket

ip = "127.0.0.1"
porta = 8080

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

while True:
    msg = input("&gt; ")

    sock.sendto(msg.encode(), (ip, porta))

    dados, serv = sock.recvfrom(1024)

    print(f"{serv} - {dados.decode()}")
</code>
</pre>

<p>PS: Observe que não tem a função connect nesse caso, porque o UDP é orientado a datagrama, diferente do TCP, que é orientado a conexão.</p>

<p>Rode o servidor primeiro, e depois o cliente.</p>

<ul>
    <li><a href="tudo-sobre-python-pentest-2.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>